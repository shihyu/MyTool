<?xml encoding='UTF-8'?>

<!--
    SlickEdit(TM) lexer specifeleication file
-->
<!ELEMENT SlickLex (Lexer+,Parser?)>

<!--
   SlickLex lexer definition
-->
<!ELEMENT Lexer (Prologue?, VerifyLexer*, Token*, IdToken*, IdTokens*)>

    <!--
        This is a regular expression representing what character patterns are 
        allowed for identifiers in the language's syntax.
     -->
    <!ATTLIST Lexer IdentifierRegex CDATA #IMPLIED>
    <!--
        Are all characters over ASCII 128 to be considered as identifier characters? 
     -->
    <!ATTLIST Lexer ExtendedIdentifierChars  (yes | no) "yes">
    <!--
        Should we generate a case-sensitive lexer, or case-insensitive? 
        This applies to identifiers and keywords. 
     -->
    <!ATTLIST Lexer CaseSensitive (yes | no) "yes">
    <!--
        In order to generate faster and smaller code, separate keyword 
        tokens from the non-keyword tokens and generate a switch statement 
        that acts like a hash table to quickly guess which keyword an 
        identifier might be.  The way we can parse identifiers quickly, 
        then look up matches for keywords pivoting on the length of the keyword. 
        Note that this setting will be automatically turned off 
        if the lexer generator detects that the grammer contains tokens 
        which contain identifier characters as well as non-identifier characters. 
    -->
    <!ATTLIST Lexer SeparateKeywords (yes | no) "no">
    <!--
        EOL Character(s).  The default is to generate Unix line endings.
     -->
    <!ATTLIST Lexer EOL (Unix | Windows | Macos) "Unix">
    <!--
        Syntax indent amount (default is an indent of 3 spaces)
        A value of -1 means to use tabs for indentation.
     -->
    <!ATTLIST Lexer SyntaxIndent CDATA #IMPLIED>

    <!--
        This is the name of the lexer class which the parsing function will belong to.  
        The class must expect to have a parameterless "parse" function which 
        will return an integer value, typically an enumerated type (see below) 
        representing the kind of token or keyword that was recognized.  The only 
        responsibility of the parse function is to advance the cursor.  The contents 
        of the token is extracted generically by the base lexer class which this 
        lexer derives from. 
     -->
    <!ATTLIST Lexer LexerClass CDATA #REQUIRED>
    <!--
        This is the name of the header file to #include for the lexer class definition.
     -->
    <!ATTLIST Lexer LexerInclude CDATA #IMPLIED>
    <!--
        This is the name of the function to generate.  The default is "parse".
        If this attribute is blank, the lexer parse function will not be generated.
    -->
    <!ATTLIST Lexer ParseTokenFunction CDATA #IMPLIED>

    <!--
        This the enumerated type for identifying keywords, operators, punctuation, 
        and other special tokens for the language being parsed.   The default is "SETokenType"
     -->
    <!ATTLIST Lexer EnumType CDATA #REQUIRED>
    <!--
        This is the name of the header file to #include for the token enum definition.
        The default is "tagging/SETokenType.h"
     -->
    <!ATTLIST Lexer EnumInclude CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents a simple identifier in the language's syntax. 
        The default is "SETOKEN_IDENTIFIER".
     -->
    <!ATTLIST Lexer IdentifierToken CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents a variable in the language's syntax. 
        The default is "SETOKEN_VARIABLE".
     -->
    <!ATTLIST Lexer VariableToken CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents an atom in the language's syntax. 
        The default is "SETOKEN_ATOM".
     -->
    <!ATTLIST Lexer AtomToken CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents a built-in identifier in the language's syntax. 
        The default is "SETOKEN_BUILTIN".
     -->
    <!ATTLIST Lexer BuiltinToken CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents a string in the language's syntax. 
        The default is "SETOKEN_STRING".
     -->
    <!ATTLIST Lexer StringToken CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents a numeric constant in the language's syntax. 
        The default is "SETOKEN_NUMBER".
     -->
    <!ATTLIST Lexer NumberToken CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents a positional keyword token in the language's syntax. 
        The default is "SETOKEN_KEYWORD".
     -->
    <!ATTLIST Lexer KeywordToken CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents that a parsing error has occurred.
        The default is "SETOKEN_ERROR".
     -->
    <!ATTLIST Lexer ErrorToken CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents that a parsing warning has occurred.
        The default is "SETOKEN_WARNING".
     -->
    <!ATTLIST Lexer WarningToken CDATA #IMPLIED>

    <!--
        This the enumerated type for identifying parser error statuses.
        The default is "SETokenErrorStatus"
     -->
    <!ATTLIST Lexer StatusType CDATA #IMPLIED>
    <!--
        This is the name of the header file to #include for the status enum definition.
        The default is "tagging/SETokenType.h"
     -->
    <!ATTLIST Lexer StatusInclude CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents that a parsing error has occurred.
        The default is "SETOKEN_ERROR".
     -->
    <!ATTLIST Lexer ErrorStatus CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents that a parsing warning has occurred.
        The default is "SETOKEN_WARNING".
     -->
    <!ATTLIST Lexer WarningStatus CDATA #IMPLIED>

    <!--
        This is the name of the function to call to parse an identifier.
        The default is "parseIdentifier"
    -->
    <!ATTLIST Lexer ParseIdentifierFunction CDATA #IMPLIED>
    <!--
        This is the name of the function to call to parse a garbage charcter.
        The default is "parseGarbageChar"
    -->
    <!ATTLIST Lexer ParseGarbageCharFunction CDATA #IMPLIED>
    <!--
        This is the name of the function to call to check if a character 
        is a language-specific identifier character. 
        The default is "isIdentifierChar".
    -->
    <!ATTLIST Lexer IsIdentifierCharFunction CDATA #IMPLIED>
    <!--
        This is the name for the table of characters that can be used in
        identifiers.  This is used to speed up parsing.  If this attribute is blank,
        then no table will be generated, and instead the "isIdentifierChar" function
        will be called directly.
    -->
    <!ATTLIST Lexer IdentifierCharTable CDATA #IMPLIED>

    <!--
        This is the method of the lexer class called in order to move the 
        cursor forward a character or multiple characters, if that is
        supported.  The default is "skipCharUnchecked"
     -->
    <!ATTLIST Lexer SkipChar CDATA #IMPLIED>
    <!--
        Can the skipChar() function take an argument to skip ahead 
        multiple characters?
     -->
    <!ATTLIST Lexer SkipMultipleChars CDATA #IMPLIED>
    <!--
        This is the method of the lexer class called in order to return 
        the current character from the input stream. 
        The default is "currentChar".
     -->
    <!ATTLIST Lexer CurrChar CDATA #IMPLIED>
    <!--
        This is the method of the lexer class called in order to peek at the 
        next character in the input stream.  It may also take an argument to 
        peek 'n' characters into the input stream. 
        The default is "peekCharUnchecked".
     -->
    <!ATTLIST Lexer PeekChar CDATA #IMPLIED>
    <!--
        Can the peekChar() function take an argument to peek ahead 
        multiple characters?
     -->
    <!ATTLIST Lexer PeekMultipleChars CDATA #IMPLIED>
    <!--
        This is the method of the lexer class called in order to move the 
        cursor forward and return the next character from the input stream. 
        This is the fast version of the routine which does not check for end of 
        file boundaries.  It is only called in cases where we know it is safe 
        to advance to the next character.  The default is "nextCharUnchecked".
     -->
    <!ATTLIST Lexer NextCharUnchecked CDATA #IMPLIED>
    <!--
        This is the method of the lexer class called in order to move the 
        cursor forward and return the next character from the input stream. 
        This version of the routine checks for end of file boundaries. 
        The default is "nextChar".
     -->
    <!ATTLIST Lexer NextChar CDATA #IMPLIED>
    <!--
        This is the method of the lexer class called in order to move the 
        cursor backward and return the previous character from the input stream. 
        This version of the routine checks for end of file boundaries. 
        The default is "prevChar".
     -->
    <!ATTLIST Lexer PrevChar CDATA #IMPLIED>
    <!--
        This is the method of the lexer class called in order to get a 
        "const char *" pointer into the source buffer.
        The default is "currentBuffer".
     -->
    <!ATTLIST Lexer GetBuffer CDATA #IMPLIED>
    <!--
        This is the method of the lexer class called in order to compare 
        a keyword against the the source buffer.
        The default is "matchKeyword".
     -->
    <!ATTLIST Lexer MatchKeyword CDATA #IMPLIED>
    <!--
        This is the method of the lexer class called in order to compare 
        a case-insensitive keyword against the the source buffer.
        The default is "matchKeywordLowcase".
     -->
    <!ATTLIST Lexer MatchKeywordLowcase CDATA #IMPLIED>
    <!--
        This is the method of the lexer class called in order to compare 
        a string against the the source buffer.
        The default is "matchString".
     -->
    <!ATTLIST Lexer MatchString CDATA #IMPLIED>
    <!--
        This is the method of the lexer class called in order to compare 
        a Unix regular expression against the the source buffer.
        The default is "matchRegex".
     -->
    <!ATTLIST Lexer MatchRegex CDATA #IMPLIED>
    <!--
        This is the method of the lexer class called in order to check 
        if the lexer has hit the end of the source buffer.
        The default is "parseEOF".
     -->
    <!ATTLIST Lexer ParseEOFFunction CDATA #IMPLIED>
    <!--
        This is the method of the lexer class called to handle a new line char.
        The default is "parseNewline".
     -->
    <!ATTLIST Lexer ParseNewlineFunction CDATA #IMPLIED>
    <!--
        This is the method of the lexer class called to handle a carriage return.
        The default is "parseCRLine".
     -->
    <!ATTLIST Lexer ParseCRLineFunction CDATA #IMPLIED>
    <!--
        This is the method of the lexer class called to handle whitespace.
        The default is "parseWhitespace".
     -->
    <!ATTLIST Lexer ParseWhitespaceFunction CDATA #IMPLIED>
    <!--
        If this option is turned off, slicklex will not generate default
        rules for EOF, whitespace, and newline characters.
     -->
    <!ATTLIST Lexer DefaultWhitespaceHandling (yes | no) "yes">

    <!--
        Any code snippet you wish to have inserted in the parse 
        function before the switch statement.  At the point this code 
        is inserted, there is already a local int named 'ch' primed 
        with the currentChar() 
     -->
    <!ATTLIST Lexer Prologue CDATA #IMPLIED>


<!--
    Any code snippet you wish to have inserted in the parse 
    function before the switch statement.  At the point this code 
    is inserted, there is already a local int named 'ch' primed 
    with the currentChar() 
 -->
<!ELEMENT Prologue (#PCDATA)>

<!--
   SlickLex lexer definition to compare the lexer against in order to
   detect incompatibilities.  This is necessary when you have a multi-language
   parser using a virtual lexer and you want to make sure the virtual lexer is
   consistent with the actual language specific lexers being used.
-->
<!ELEMENT VerifyLexer EMPTY>
    <!--
        This is a regular expression representing what character patterns are 
        allowed for identifiers in the language's syntax.
     -->
    <!ATTLIST VerifyLexer File CDATA #REQUIRED>

<!--
    Defines a single token.  Tokens can be entire keywords, operators, or
    punctuation, or just a prefix string and a call to another lexer function to
    finish parsing.
-->
<!ELEMENT Token EMPTY>
    <!--
        Token text (may be just a prefix)
    -->
    <!ATTLIST Token Text  CDATA #REQUIRED>
    <!--
        Name of token (part of the token enumeration) associated with this token.
    -->
    <!ATTLIST Token Name  CDATA #IMPLIED>
    <!--
        Optional call-out to a function within the lexer, such as parseString() 
        or parseComment(), etc.
    -->
    <!ATTLIST Token Expr  CDATA #IMPLIED>
    <!--
        Regular expression for first character of token.
    -->
    <!ATTLIST Token StartRegex CDATA #IMPLIED>
    <!--
        Regular expression for parsing this token.  
        Note that the token start text or a start regex is required.
    -->
    <!ATTLIST Token Regex CDATA #IMPLIED>
    <!--
        Token ID (for referencing in parser specification)
    -->
    <!ATTLIST Token id    ID    #IMPLIED>
    <!--
        Should this token be treated as case-sensitive (yes) or 
        case-insensitive (no) as a special case?  Otherwise, the token
        will be treated as all tokens in the lexer with respect to
        case sensitivity.
    -->
    <!ATTLIST Token CaseSensitive (yes | no) "yes">
    <!--
        Indicates that even though this token looks like a keyword
        or identifier (that is, it starts with an identifier start character), 
        it should not be treated as a keyword because it requires special
        handling.
    -->
    <!ATTLIST Token NotKeyword (yes | no) "no">

<!--
    Defines an identifier token.  This is a token that would normally be
    regarded as an identifier, but in context the parser can consider this
    token as a specific keyword.
-->
<!ELEMENT IdToken EMPTY>
    <!--
        Identifier or keyword text
    -->
    <!ATTLIST IdToken Text CDATA #REQUIRED>
    <!--
        Token ID (for referencing in parser specification)
    -->
    <!ATTLIST IdToken id   ID    #IMPLIED>
    <!--
        Should this token be treated as case-sensitive (yes) or 
        case-insensitive (no) as a special case?  Otherwise, the token
        will be treated as all tokens in the lexer with respect to
        case sensitivity.
    -->
    <!ATTLIST IdToken CaseSensitive (yes | no) "yes">

<!--
    Defines a list of identifier tokens.  These tokens would normally be
    regarded as an identifier, but in context the parser can consider this
    token as a specific keyword.
-->
<!ELEMENT IdTokens (#PCDATA) >
    <!--
        Token group ID (for referencing in parser specification)
    -->
    <!ATTLIST IdTokens id   ID    #IMPLIED>
    <!--
        Name of token group section.
    -->
    <!ATTLIST IdTokens Name CDATA #IMPLIED>
    <!--
        Should this token be treated as case-sensitive (yes) or 
        case-insensitive (no) as a special case?  Otherwise, the token
        will be treated as all tokens in the lexer with respect to
        case sensitivity.
    -->
    <!ATTLIST IdTokens CaseSensitive (yes | no) "yes">

<!--
   SlickLex parser definition
-->
<!ELEMENT Parser ((Rule|Section)+) >
    <!--
        This is the name of the parser class which the parsing 
        functions will belong to.  
     -->
    <!ATTLIST Parser ParserClass CDATA #REQUIRED>
    <!--
        This is the name of the header file to #include for the 
        parser class definition.
    -->
    <!ATTLIST Parser ParserInclude CDATA #IMPLIED>

    <!--
        This is the name of the lexer class used by the parser.
     -->
    <!ATTLIST Parser LexerClass CDATA #IMPLIED>
    <!--
        This is the name of the header file to #include for the lexer class definition.
     -->
    <!ATTLIST Parser LexerInclude CDATA #IMPLIED>

    <!--
        This the enumerated type for identifying keywords, operators, punctuation, 
        and other special tokens for the language being parsed.   The default is "SETokenType"
     -->
    <!ATTLIST Parser EnumType CDATA #IMPLIED>
    <!--
        This is the name of the header file to #include for the token enum definition.
        The default is "tagging/SETokenType.h"
     -->
    <!ATTLIST Parser EnumInclude CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents a simple identifier in the language's syntax. 
        The default is "SETOKEN_IDENTIFIER".
     -->
    <!ATTLIST Parser IdentifierToken CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents a built-in identifier in the language's syntax. 
        The default is "SETOKEN_BUILTIN".
     -->
    <!ATTLIST Parser BuiltinToken CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents a positional keyword token in the language's syntax. 
        The default is "SETOKEN_KEYWORD".
     -->
    <!ATTLIST Parser KeywordToken CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents that a parsing error has occurred.
        The default is "SETOKEN_ERROR".
     -->
    <!ATTLIST Parser ErrorToken CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents that a parsing warning has occurred.
        The default is "SETOKEN_WARNING".
     -->
    <!ATTLIST Parser WarningToken CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents the end of file.  The default is "SETOKEN_EOF".
     -->
    <!ATTLIST Parser EOFToken CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents the end of a string input.  The default is "SETOKEN_EOS".
     -->
    <!ATTLIST Parser EOSToken CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents a line break.  The default is "SETOKEN_NEWLINE".
     -->
    <!ATTLIST Parser NewlineToken CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents the white space between tokens.  
        The default is "SETOKEN_WHITESPACE".
     -->
    <!ATTLIST Parser WhitespaceToken CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents a line comment.  The default is "SETOKEN_LINE_COMMENT".
     -->
    <!ATTLIST Parser LineCommentToken CDATA #IMPLIED>
    <!--
        This is the name of the constant in the above enumerated type which 
        represents a block comment.  The default is "SETOKEN_BLOCK_COMMENT".
     -->
    <!ATTLIST Parser BlockCommentToken CDATA #IMPLIED>

    <!--
        Should we generate a case-sensitive lexer, or case-insensitive? 
        This applies to identifiers and keywords. 
     -->
    <!ATTLIST Parser CaseSensitive (yes | no) "yes">
    <!--
        EOL Character(s).  The default is to generate Unix line endings.
     -->
    <!ATTLIST Parser EOL (Unix | Windows | Macos) "Unix">
    <!--
        Syntax indent amount (default is an indent of 3 spaces).
        A value of -1 means to use tabs for indentation.
     -->
    <!ATTLIST Parser SyntaxIndent CDATA #IMPLIED>

    <!--
        This is the name of the type used for integer variables.
        The default is "unsigned int".
    -->
    <!ATTLIST Parser IntegerType CDATA #IMPLIED>
    <!--
        This is the name of the header file to #include for the 
        integer type definition.
    -->
    <!ATTLIST Parser IntegerInclude CDATA #IMPLIED>
    <!--
        This is the name of type used for string variables.
        The default is "slickedit::SEString".
    -->
    <!ATTLIST Parser StringType CDATA #IMPLIED>
    <!--
        This is the name of the header file to #include for the 
        string class definition.
    -->
    <!ATTLIST Parser StringInclude CDATA #IMPLIED>
    <!--
        This is the name of the type used for boolean variables.
        The default is "bool".
    -->
    <!ATTLIST Parser BooleanType CDATA #IMPLIED>
    <!--
        This is the name of the member function to get a lower case
        copy of a string.  The default is "toLowcase".
    -->
    <!ATTLIST Parser Lowcase CDATA #IMPLIED>
    <!--
        This is the name of the member function to append to a string.
        The default is "append".
    -->
    <!ATTLIST Parser Append CDATA #IMPLIED>
    <!--
        This is the name of the member function to append a character
        to a string provided the char is not there already and the
        string is not empty.  The default is "maybeAppend".
    -->
    <!ATTLIST Parser MaybeAppend CDATA #IMPLIED>
    <!--
        This is the name of the function used to convert an integer to a string.
        The default is "fromNumber", which is a static member function of
        the default string class "SEString".  If you specify a value that
        does not contain a ::, we assume the function is a static member
        function of the string class type.  Otherwise, the function is used
        as specified, for example std::to_string() for the C++ STL.
    -->
    <!ATTLIST Parser FromNumber CDATA #IMPLIED>
    <!--
        This is the name of the member function to check if a string is
        an item in a delimited list which is passed in as a parameter.
        The default is "isInList".
    -->
    <!ATTLIST Parser IsInList CDATA #IMPLIED>
    <!--
        This is the name of the member function to retrieve the length of a string.
        The default is "length".
    -->
    <!ATTLIST Parser Length CDATA #IMPLIED>
    <!--
        This is the name of the member function to check if a string is empty.
        The default is "isEmpty".
    -->
    <!ATTLIST Parser IsEmpty CDATA #IMPLIED>
    <!--
        This is an expression that effeciently evaluates or converts to an 
        empty string constant (not to be confused with a null string).
        The default is "".
    -->
    <!ATTLIST Parser EmptyString CDATA #IMPLIED>
    <!--
        String suffix for user defined strings of the given StringType.
        The default is "".
    -->
    <!ATTLIST Parser UserDefinedStringSuffix CDATA #IMPLIED>
    
    <!--
        This string is used to access the lexer class instance from
        the parser class.  If the lexer is part of the class, this
        can be set to the empty string.  The default is "mLexer.".
    -->
    <!ATTLIST Parser LexerPrefix CDATA #IMPLIED>
    <!--
        This is the name of the member function to return the
        next token type from the lexer.  The default is "nextToken".
    -->
    <!ATTLIST Parser NextToken CDATA #IMPLIED>
    <!--
        This is the name of the member function to return the
        current token type from the lexer.  The default is "currentToken".
    -->
    <!ATTLIST Parser CurrToken CDATA #IMPLIED>
    <!--
        This is the name of the member function to modify the token
        type of the current token. The default is "setCurrentTokenType".
    -->
    <!ATTLIST Parser SetCurrToken CDATA #IMPLIED>
    <!--
        This is the name of the member function to modify the error status
        for the current token. The default is "setCurrentTokenErrorStatus".
    -->
    <!ATTLIST Parser SetCurrTokenError CDATA #IMPLIED>
    <!--
        This is the name of the member function to return the
        current token text from the lexer.  The default is "currentTokenValue".
    -->
    <!ATTLIST Parser CurrTokenText CDATA #IMPLIED>
    <!--
        This is the name of the member function to return the
        token ID of the upcoming 'n'th token from the lexer.
        The default is "peekToken".
    -->
    <!ATTLIST Parser PeekToken CDATA #IMPLIED>
    <!--
        This is the name of the member function to return the
        token text of the upcoming 'n'th token from the lexer.
        The default is "peekTokenValue".
    -->
    <!ATTLIST Parser PeekTokenText CDATA #IMPLIED>
    <!--
        This is the method of the lexer class called in order to append 
        the current token to the given string. 
    -->
   <!ATTLIST Parser AppendToken CDATA #IMPLIED>
    <!--
        This is the method of the lexer class called in order to append 
        the a string to the given contents string. 
    -->
   <!ATTLIST Parser LexerAppend CDATA #IMPLIED>
    <!--
        This is the name of the member function to start parsing
        down an experimental parsing path.  The default is "beginParse".
    -->
    <!ATTLIST Parser BeginParse CDATA #IMPLIED>
    <!--
        This is the name of the member function to finish parsing
        down an experimental parsing path.  The default is "endParse".
    -->
    <!ATTLIST Parser EndParse CDATA #IMPLIED>
    <!--
        This is the name of the member function to cancel parsing
        down an experimental parsing path and return to the starting token.
        The default is "cancelParse".
    -->
    <!ATTLIST Parser CancelParse CDATA #IMPLIED>

    <!--
        This is the method of the lexer class called to get the last 
        documentation comment type. 
    -->
    <!ATTLIST Parser GetDocCommentType CDATA #IMPLIED>
    <!--
        This is the method of the lexer class called to get the last 
        documentation comment text. 
    -->
    <!ATTLIST Parser GetDocCommentText CDATA #IMPLIED>
    <!--
        This is the method of the lexer class called to clear the 
        last documentation comment.
    -->
    <!ATTLIST Parser ClearDocComment CDATA #IMPLIED>
    <!--
        This is the value of the variable to use to represent a null
        documentation comment type (SE_TAG_DOCUMENTATION_NULL).
    -->
    <!ATTLIST Parser DocCommentTypeNull CDATA #IMPLIED>

    <!--
        This string is used to access the tagging context instance from
        the parser class.  If the context is part of the class, this
        can be set to the empty string.  The default is "mContext.".
    -->
    <!ATTLIST Parser ContextPrefix CDATA #IMPLIED>
    <!--
        This is the name of the member function to insert a tag
        in the current tagging context.  The default is "insertTag".
    -->
    <!ATTLIST Parser InsertTag CDATA #IMPLIED>
    <!--
        This is the name of the member function to insert an occurrence
        of an identifier name in the tagging context.
        The default is "insertIdOccurrence".
    -->
    <!ATTLIST Parser InsertOccurrence CDATA #IMPLIED>
    <!--
        This is the name of the member function to insert an embedded
        code section in the tagging context.
        The default is "insertEmbeddedSection".
    -->
    <!ATTLIST Parser InsertEmbedded CDATA #IMPLIED>
    <!--
        This is the name of the member function to return the language ID
        for the current tagging context.  The default is "getLanguageId".
    -->
    <!ATTLIST Parser GetLanguageId CDATA #IMPLIED>
    <!--
        This is the name of the member function to return the whether the
        current tagging operation is a local variable search or not.
        The default is "isTargetLocals".
    -->
    <!ATTLIST Parser IsLocals CDATA #IMPLIED>
    <!--
        This is the name of the member function to return the whether the
        current tagging operation is statement tagging or not.
        The default is "isTargetStatements".
    -->
    <!ATTLIST Parser IsStatements CDATA #IMPLIED>
    <!--
        This is the name of the member function to return the the
        name of the function to call to get the parse start seek position.
        The default is "getParseStartSeekPosition".
    -->
    <!ATTLIST Parser StartPosition CDATA #IMPLIED>
    <!--
        This is the name of the member function to return the the
        name of the function to call to get the parse stop seek position.
        The default is "getParseStopSeekPosition".
    -->
    <!ATTLIST Parser StopPosition CDATA #IMPLIED>
    <!--
        This is the name of the member function to indicate that
        a new local variable scope is starting.  The default is "pushLocals".
    -->
    <!ATTLIST Parser PushLocals CDATA #IMPLIED>
    <!--
        This is the name of the member function to indicate that
        a local variable scope is ending.  The default is "popLocals".
    -->
    <!ATTLIST Parser PopLocals CDATA #IMPLIED>
    <!--
        This is the name of the member function to undo the effects of
        a call to the pushLocals() function. The default is "unpushLocals".
    -->
    <!ATTLIST Parser UnPushLocals CDATA #IMPLIED>
    <!--
        This is the name of the member function to indicate that
        a new symbol scope is starting.  The default is "pushContext".
    -->
    <!ATTLIST Parser PushContext CDATA #IMPLIED>
    <!--
        This is the name of the member function to indicate that
        a symbol scope is ending.  The default is "popContext".
    -->
    <!ATTLIST Parser PopContext CDATA #IMPLIED>
    <!--
        This is the name of the member function that returns the text
        representing the current token.  The default is "currentTokenText".
    -->
    <!ATTLIST Parser CurrTokenText CDATA #IMPLIED>
    <!--
        This is the name of the member function that returns the current
        file name.  The default is "currentTokenFileName".
    -->
    <!ATTLIST Parser CurrFileName CDATA #IMPLIED>
    <!--
        This is the name of the member function that returns the start line number
        of the current token.  The default is "currentTokenStartLineNumber".
    -->
    <!ATTLIST Parser CurrTokenStartLine CDATA #IMPLIED>
    <!--
        This is the name of the member function that returns the start seek position
        of the current token.  The default is "currentTokenStartSeekPosition".
    -->
    <!ATTLIST Parser CurrTokenStartSeek CDATA #IMPLIED>
    <!--
        This is the name of the member function that returns the end line number
        of the current token.  The default is "currentTokenEndLineNumber".
    -->
    <!ATTLIST Parser CurrTokenEndLine CDATA #IMPLIED>
    <!--
        This is the name of the member function that returns the end seek position
        of the current token.  The default is "currentTokenEndSeekPosition".
    -->
    <!ATTLIST Parser CurrTokenEndSeek CDATA #IMPLIED>
    <!--
        This is the name of the member function that returns the column offset
        of the current token.  The default is "currentTokenFileColumnOffset".
    -->
    <!ATTLIST Parser CurrTokenColumnOffset CDATA #IMPLIED>
    <!--
        This is the name of the member function that returns whether the current
        token is the first token on the current line.  The default is "isFirstOnLine".
    -->
    <!ATTLIST Parser IsFirstTokenOnLine CDATA #IMPLIED>
    <!--
        Track whether we are in a function body?
        Name of parameter used to track if we are in a function body (inFunction)
    -->
    <!ATTLIST Parser TrackFunction  (yes | no) "yes" 
                     InFunctionName CDATA      #IMPLIED >
    <!--
        Track the current package scope?
        Name of variable used to track the current package name.
    -->
    <!ATTLIST Parser TrackPackage   (yes | no) "yes" 
                     PackageName    CDATA      #IMPLIED >
    <!--
        Track the current class scope?
        Name of variable used to track the current class name.
    -->
    <!ATTLIST Parser TrackClass     (yes | no) "yes" 
                     ClassName      CDATA      #IMPLIED >
    <!--
        Track the end line and seek position for this rule?
    -->
    <!ATTLIST Parser TrackEnd       (yes | no) "yes" >
    <!--
        Collect documentation comments for this parser?
    -->
    <!ATTLIST Parser CollectComments  (yes | no) "no" >


<!--
    This is the content model for grammar rule clauses.
-->
<!ENTITY % tokenClauses   "R | Id | T | NotTokens | ExpectTokens | RejectTokens | AnyToken" >
<!ENTITY % orClauses      "Or | OrRules | OrTokens | OrTokensAndRules | Default" >
<!ENTITY % controlClauses "Optional | Repeat | Sequence | Break | If" >
<!ENTITY % acceptClauses  "Accept | Reject | AcceptRule" >
<!ENTITY % taggingClauses "InsertEmbedded | InsertTag | PushLocals | PopLocals | UnPushLocals | PushContext | PopContext | SetTagEnd | SetTagFlag | SetTagType | InFunction" >
<!ENTITY % stringClauses  "Append | Trim | AppendClass | AppendPackage" >
<!ENTITY % clauseNames    "%tokenClauses; | %controlClauses; | %orClauses; | %acceptClauses; | %taggingClauses; | %stringClauses; | Expression" >
<!ENTITY % clauses "( #PCDATA | %clauseNames;)*" >
<!--
    This is the set of common atributes for all rule clauses.
-->
<!ENTITY % clauseattrs
         'id                 CDATA       #IMPLIED
          LangId             CDATA       #IMPLIED
          Append             (yes | no)  "yes"
          ContentsName       CDATA       #IMPLIED
          StartLineName      CDATA       #IMPLIED
          StartSeekName      CDATA       #IMPLIED
          EndLineName        CDATA       #IMPLIED
          EndSeekName        CDATA       #IMPLIED
          ColumnName         CDATA       #IMPLIED
          OnColumn           CDATA       #IMPLIED
          OnLine             CDATA       #IMPLIED
          IsFirstTokenOnLine (yes | no)  "no"' >

<!--
   SlickLex parser definition rule section or sub-section
-->
<!ELEMENT Section ((Rule|Section)*) >

<!--
    Name of grammar section.
-->
<!ATTLIST Section Name CDATA #IMPLIED>
<!--
    Unique ID for grammar section
-->
<!ATTLIST Section id CDATA #IMPLIED>

<!--
   SlickLex parser rule (equates to a grammar rule)
-->
<!ELEMENT Rule (#PCDATA | Argument | %clauseNames;)* >
    <!--
        Name of grammar rule begin defined.
    -->
    <!ATTLIST Rule id CDATA #REQUIRED>
    <!--
        This grammar rule already has a prototype in the class definition.
    -->
    <!ATTLIST Rule HasPrototype (yes | no) "no">
    <!--
        This grammar rule is implemented manually, so the parser generator
        does not need to generate code for it.
    -->
    <!ATTLIST Rule HasImplementation (yes | no) "no">
    <!--
        Append parsed tokens to string contents?
    -->
    <!ATTLIST Rule Append        (yes | no) "yes" >
    <!--
        Name of variable used to track string contents of this rule.
    -->
    <!ATTLIST Rule ContentsName  CDATA      #IMPLIED >
    <!--
        Track whether we are in a function body?
        Name of parameter used to track if we are in a function body (inFunction)
    -->
    <!ATTLIST Rule TrackFunction  (yes | no) "yes" 
                   InFunctionName CDATA      #IMPLIED >
    <!--
        Track the current package scope?
        Name of variable used to track the current package name.
    -->
    <!ATTLIST Rule TrackPackage   (yes | no) "yes" 
                   PackageName    CDATA      #IMPLIED
                   NewPackageName CDATA      #IMPLIED >
    <!--
        Track the current class scope?
        Name of variable used to track the current class name.
    -->
    <!ATTLIST Rule TrackClass     (yes | no) "yes" 
                   ClassName      CDATA      #IMPLIED
                   NewClassName   CDATA      #IMPLIED >
    <!--
        Track the end line and seek position for this rule?
    -->
    <!ATTLIST Rule TrackEnd       (yes | no) "yes" >
    <!--
        Collect documentation comments for this rule?
    -->
    <!ATTLIST Rule CollectComments  (yes | no) "no" >
    <!--
        Start and end line number variables for this rule
    -->
    <!ATTLIST Rule 
              StartLineName CDATA      #IMPLIED
              StartSeekName CDATA      #IMPLIED
              EndLineName   CDATA      #IMPLIED
              EndSeekName   CDATA      #IMPLIED
              ColumnName    CDATA      #IMPLIED >

<!--
   SlickLex parser definition rule argument
-->
<!ELEMENT Argument EMPTY>
   <!--
       Argument name, type and default value
   -->
   <!ATTLIST Argument Name CDATA #IMPLIED
                      Type      (String|Boolean|Integer|TagType|TagFlags|TokenType|bool|int|short|long|float|double|char|wchar_t|size_t) #IMPLIED
                      OtherType CDATA #IMPLIED
                      Ref       (yes|no) #IMPLIED
                      Default   CDATA #IMPLIED
                      Required  (yes|no) #IMPLIED>

<!--
   SlickLex parser rule reference clause
-->
<!ELEMENT R EMPTY>
<!ATTLIST R %clauseattrs; >
    <!--
        Name of grammar rule referenced.
    -->
    <!ATTLIST R Name CDATA #REQUIRED>
    <!--
        Additional argument names to pass to this rule
    -->
    <!ATTLIST R 
              Arg0           CDATA #IMPLIED
              Arg1           CDATA #IMPLIED
              Arg2           CDATA #IMPLIED
              Arg3           CDATA #IMPLIED
              Arg4           CDATA #IMPLIED
              Arg5           CDATA #IMPLIED
              Arg6           CDATA #IMPLIED
              Arg7           CDATA #IMPLIED
              Arg8           CDATA #IMPLIED
              Arg9           CDATA #IMPLIED >

<!--
   SlickLex parser rule identifier keyword clause
-->
<!ELEMENT Id EMPTY>
<!ATTLIST Id %clauseattrs; >
    <!--
        Identifier keyword token for context sensitive keywords
        (keywords that are plain identifiers in other contexts).
    -->
    <!ATTLIST Id Text CDATA #REQUIRED>
    <!--
        Should this token be treated as case-sensitive (yes) or 
        case-insensitive (no) as a special case?  Otherwise, the token
        will be treated as all tokens in the lexer with respect to
        case sensitivity.
    -->
    <!ATTLIST Id CaseSensitive (yes | no) "yes">

<!--
   SlickLex parser rule token (T) clause
-->
<!ELEMENT T EMPTY>
<!ATTLIST T %clauseattrs; >
    <!--
        Identifier keyword token for context sensitive keywords
        (keywords that are plain identifiers in other contexts).
    -->
    <!ATTLIST T Text CDATA #REQUIRED>

<!--
   SlickLex parser rule or clause
-->
<!ELEMENT Or (Case+,Default?) >
<!ATTLIST Or %clauseattrs; >
<!ATTLIST Or Optional (yes | no) "no">

<!--
   SlickLex parser rule or case clause
-->
<!ELEMENT Case %clauses; >
<!ATTLIST Case %clauseattrs; >
<!ATTLIST Case Cond CDATA #IMPLIED >

<!--
   SlickLex parser rule or default clause
-->
<!ELEMENT Default %clauses; >
<!ATTLIST Default %clauseattrs; >
    <!--
        Name of grammar rule referenced.
    -->
    <!ATTLIST Default Name CDATA #IMPLIED>

<!--
   SlickLex parser rule or clause for a set of rules
-->
<!ELEMENT OrRules ( #PCDATA | R | Default )* >
<!ATTLIST OrRules %clauseattrs; >
<!ATTLIST OrRules Optional (yes | no) "no">

<!--
   SlickLex parser rule or clause for a set of tokens
-->
<!ELEMENT OrTokens ( #PCDATA | Id | T )* >
<!ATTLIST OrTokens %clauseattrs; >
<!ATTLIST OrTokens Optional (yes | no) "no">

<!--
   SlickLex parser rule or clause for a set of tokens or rules
-->
<!ELEMENT OrTokensAndRules ( #PCDATA | R | Default )* >
<!ATTLIST OrTokensAndRules %clauseattrs; >
<!ATTLIST OrTokensAndRules Optional (yes | no) "no">

<!--
   SlickLex parser rule or clause for a set of tokens NOT to match.
-->
<!ELEMENT NotTokens ( #PCDATA | Id | T )* >
<!ATTLIST NotTokens %clauseattrs; >
<!ATTLIST NotTokens Error    ( yes | no ) "no" >
<!ATTLIST NotTokens Warning  ( yes | no ) "no" >

<!--
   SlickLex parser rule or clause for specifying to reject a clause if
   the current token matches any tokens in the given set of tokens
-->
<!ELEMENT RejectTokens ( #PCDATA | Id | T )* >
<!ATTLIST RejectTokens LookAhead CDATA #IMPLIED >

<!--
   SlickLex parser rule or clause for specifying to expect a certain
   set of tokens at a and to fail if the current token does not match
   any tokens in the given set of tokens
-->
<!ELEMENT ExpectTokens ( #PCDATA | Id | T )* >
<!ATTLIST ExpectTokens LookAhead CDATA #IMPLIED >

<!--
   SlickLex parser rule or clause for matching any token except for EOF.
-->
<!ELEMENT AnyToken EMPTY >
<!ATTLIST AnyToken %clauseattrs; >
<!ATTLIST AnyToken Error    ( yes | no ) "no" >
<!ATTLIST AnyToken Warning  ( yes | no ) "no" >

<!--
   SlickLex parser rule optional clause
-->
<!ELEMENT Optional %clauses; >
<!ATTLIST Optional %clauseattrs; >

<!--
   SlickLex parser rule repeat clause
-->
<!ELEMENT Repeat %clauses; >
<!ATTLIST Repeat %clauseattrs; >
<!ATTLIST Repeat Separator              CDATA  #IMPLIED >
<!ATTLIST Repeat Min                    CDATA  #IMPLIED >
<!ATTLIST Repeat Max                    CDATA  #IMPLIED >
<!ATTLIST Repeat CheckEnd               ( yes | no ) "no" >
<!ATTLIST Repeat Contiguous             ( yes | no ) "no" >
<!ATTLIST Repeat AllowTrailingSeparator ( yes | no ) "no" >
<!ATTLIST Repeat RepeatCountName        CDATA #IMPLIED >
<!ATTLIST Repeat ContentsArrayName      CDATA #IMPLIED >
<!ATTLIST Repeat StartLineArrayName     CDATA #IMPLIED >
<!ATTLIST Repeat StartSeekArrayName     CDATA #IMPLIED >
<!ATTLIST Repeat EndLineArrayName       CDATA #IMPLIED >
<!ATTLIST Repeat EndSeekArrayName       CDATA #IMPLIED >

<!--
   SlickLex parser rule subsection clause
-->
<!ELEMENT Sequence %clauses; >
<!ATTLIST Sequence %clauseattrs; >
<!ATTLIST Sequence Contiguous ( yes | no ) "no" >

<!--
   SlickLex parser rule expression clause
-->
<!ELEMENT Expression (Operator+,Operand) >
<!ATTLIST Expression %clauseattrs; >
<!ATTLIST Expression InitialLevel  CDATA  #IMPLIED >

<!--
   SlickLex parser rule subsection clause
-->
<!ELEMENT Operator %clauses; >
<!ATTLIST Operator %clauseattrs; >
<!ATTLIST Operator Type ( binary | prefix | postfix ) "binary" >
<!ATTLIST Operator Level CDATA #IMPLIED >

<!--
   SlickLex parser rule subsection clause
-->
<!ELEMENT Operand %clauses; >
<!ATTLIST Operand %clauseattrs; >

<!--
   SlickLex parser rule if condition clause
-->
<!ELEMENT If (Then,Else*) >
<!ATTLIST If Cond CDATA #REQUIRED >
<!ATTLIST If %clauseattrs; >
<!--
   SlickLex parser rule for the then clause in an if.
-->
<!ELEMENT Then %clauses; >
<!ATTLIST Then %clauseattrs; >
<!--
   SlickLex parser rule for an else clause in an if.
-->
<!ELEMENT Else %clauses; >
<!ATTLIST Else %clauseattrs; >
<!ATTLIST Else Cond CDATA #IMPLIED >

<!--
   SlickLex parser rule accept entire rule to indicate the point of no return.
-->
<!ELEMENT AcceptRule EMPTY >
<!--
   SlickLex parser rule accept clause to indicate the point of no return.
-->
<!ELEMENT Accept EMPTY >
<!--
   SlickLex parser rule accept clause to indicate an parsing path is impossible.
-->
<!ELEMENT Reject EMPTY >

<!--
   SlickLex parser rule to break out of a repeat sequence early
-->
<!ELEMENT Break EMPTY >

<!--
   SlickLex parser rule to indicate that we are in a function body.
-->
<!ELEMENT InFunction EMPTY >
<!ATTLIST InFunction Value (yes | no) "yes" >

<!--
   SlickLex parser rule insert tag action.
-->
<!ELEMENT InsertTag EMPTY >
<!ATTLIST InsertTag
          IsLocal         (yes | no) "no"
          NotLocal        (yes | no) "no"
          InClass         (yes | no) "no"
          IsStatement     (yes | no) "no"
          NotStatement    (yes | no) "no"
          CollectComments (yes | no) "yes"
          TagId         CDATA #IMPLIED
          Statement     CDATA #IMPLIED
          Name          CDATA #IMPLIED
          Package       CDATA #IMPLIED  
          Class         CDATA #IMPLIED  
          Type          CDATA #IMPLIED
          Flags         CDATA #IMPLIED
          File          CDATA #IMPLIED
          Start         CDATA #IMPLIED
          StartLine     CDATA #IMPLIED
          StartSeek     CDATA #IMPLIED
          NameLine      CDATA #IMPLIED
          NameSeek      CDATA #IMPLIED
          Scope         CDATA #IMPLIED
          ScopeLine     CDATA #IMPLIED
          ScopeSeek     CDATA #IMPLIED
          End           CDATA #IMPLIED
          EndLine       CDATA #IMPLIED
          EndSeek       CDATA #IMPLIED
          Signature     CDATA #IMPLIED
          Return        CDATA #IMPLIED
          Value         CDATA #IMPLIED
          Parents       CDATA #IMPLIED
          TemplateSig   CDATA #IMPLIED
          ExceptionSig  CDATA #IMPLIED
          DocType       CDATA #IMPLIED
          DocComments   CDATA #IMPLIED >

<!--
   SlickLex parser rule push locals action
-->
<!ELEMENT PushLocals EMPTY >
<!--
   SlickLex parser rule push locals action
-->
<!ELEMENT PopLocals EMPTY >
<!--
   SlickLex parser rule unpush locals action
-->
<!ELEMENT UnPushLocals EMPTY >
<!--
   SlickLex parser rule push locals action
-->
<!ELEMENT PushContext EMPTY >
<!--
   SlickLex parser rule push locals action
-->
<!ELEMENT PopContext EMPTY >

<!--
   SlickLex parser rule set end tag action.
-->
<!ELEMENT SetEndTag EMPTY >
<!ATTLIST SetEndTag
          TagId         CDATA #IMPLIED
          End           CDATA #IMPLIED
          EndLine       CDATA #IMPLIED
          EndSeek       CDATA #IMPLIED >

<!--
   SlickLex parser rule to insert an embedded code section
-->
<!ELEMENT InsertEmbedded EMPTY >
<!ATTLIST InsertEmbedded
          Start         CDATA #IMPLIED
          StartLine     CDATA #IMPLIED
          StartSeek     CDATA #IMPLIED
          End           CDATA #IMPLIED
          EndLine       CDATA #IMPLIED
          EndSeek       CDATA #IMPLIED
          File          CDATA #IMPLIED
          LangId        CDATA #IMPLIED
          Parse         (collate|immediate|individual|no) "collate" >

<!--
   SlickLex parser rule set tag flags.
-->
<!ELEMENT SetTagFlag EMPTY >
<!ATTLIST SetTagFlag
          Name          CDATA #IMPLIED
          Flag          CDATA #IMPLIED
          NotFlag       CDATA #IMPLIED >

<!--
   SlickLex parser rule set tag type.
-->
<!ELEMENT SetTagType EMPTY >
<!ATTLIST SetTagType
          Name          CDATA #IMPLIED
          Type          CDATA #REQUIRED >

<!--
   SlickLex parser rule string append clause

    To - variable to append to
    From - appends from a variable
    Value - appends a string literal
    IfEmpty - If no, does not append to an empty string
    Space - If yes, appends a space before appending the specified string
    Clear - If yes, clear the string contents before appending text
-->
<!ELEMENT Append %clauses; >
<!ATTLIST Append
          To            CDATA #IMPLIED
          From          CDATA #IMPLIED  
          Value         CDATA #IMPLIED
          IfEmpty       ( yes | no ) "yes"
          Space         ( yes | no ) "yes"
          Clear         ( yes | no ) "no"  >

<!--
   SlickLex parser rule string trim clause

    From - trim from a string variable
    Head - number of characters to trim from front of string
    Tail - number of characters to trim from tail of string
-->
<!ELEMENT Trim %clauses; >
<!ATTLIST Trim
          From          CDATA #IMPLIED  
          Head          CDATA #IMPLIED
          Tail          CDATA #IMPLIED >

<!--
   SlickLex parser rule string append clause for current class name

    To - variable to append to
    From - appends from a variable
    Value - appends a string literal
    Clear - If yes, clear the string contents before appending text
-->
<!ELEMENT AppendClass %clauses; >
<!ATTLIST AppendClass
          To            CDATA #IMPLIED
          From          CDATA #IMPLIED  
          Value         CDATA #IMPLIED
          Reset         ( yes | no ) "no"
          Clear         ( yes | no ) "no"  >

<!--
   SlickLex parser rule string append clause for current package name

    To - variable to append to
    From - appends from a variable
    Value - appends a string literal
    Clear - If yes, clear the string contents before appending text
-->
<!ELEMENT AppendPackage %clauses; >
<!ATTLIST AppendPackage
          To            CDATA #IMPLIED
          From          CDATA #IMPLIED  
          Value         CDATA #IMPLIED
          Reset         ( yes | no ) "no"
          Clear         ( yes | no ) "no"  >

