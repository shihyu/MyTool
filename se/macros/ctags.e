////////////////////////////////////////////////////////////////////////////////////
// Copyright 2010 SlickEdit Inc. 
// You may modify, copy, and distribute the Slick-C Code (modified or unmodified) 
// only if all of the following conditions are met: 
//   (1) You do not include the Slick-C Code in any product or application 
//       designed to run independently of SlickEdit software programs; 
//   (2) You do not use the SlickEdit name, logos or other SlickEdit 
//       trademarks to market Your application; 
//   (3) You provide a copy of this license with the Slick-C Code; and 
//   (4) You agree to indemnify, hold harmless and defend SlickEdit from and 
//       against any loss, damage, claims or lawsuits, including attorney's fees, 
//       that arise or result from the use or distribution of Your application.
////////////////////////////////////////////////////////////////////////////////////
#pragma option(pedantic,on)
#region Imports
#include "slick.sh"
#include "tagsdb.sh"
#import "se/tags/TaggingGuard.e"
#import "cbrowser.e"
#import "complete.e"
#import "codehelp.e"
#import "context.e"
#import "dir.e"
#import "ex.e"
#import "help.e"
#import "main.e"
#import "pipe.e"
#import "projconv.e"
#import "setupext.e"
#import "stdcmds.e"
#import "stdprocs.e"
#import "tagform.e"
#import "tags.e"
#import "wkspace.e"
#endregion

/** 
 * Full path to executable to use for CTags-based workspace tagging for 
 * SlickEdit Standard. 
 *
 * @default ""
 * @categories Configuration_Variables, Tagging_Functions
 */
_str def_ctags_exe = "";

/** 
 * Command line options to pass to ctags when building tag files. 
 *  
 * The default is "-w" which indicates that it should ignore warnings.
 * 
 * To create tags for typedefs, structs, unions, and enums, as
 * well as #defines that do not take arguments, use "-tdw"
 *
 * @default "-w"
 * @categories Configuration_Variables, Tagging_Functions
 */
_str def_ctags_options = "-w";

/** 
 * @return 
 * Return the absolute path to the current active 'tags' file (presumably 
 * generated by ctags).  Returns "" if there is no such file.
 *  
 * SlickEdit will use just one tags file, depending on what is found.
 * <ul> 
 * <li>A tags file in the current project directory: <em>project_name.tags</em>
 * <li>A tags file in the current project directory named "tags".
 * <li>A tags file in the current workspace directory: <em>workspace_name.tags</em>
 * <li>A tags file in the current workspace directory named "tags".
 * <li>A tags file in the current directory named "tags". 
 * </ul> 
 * ctags can be used by SlickEdit Standard, and also in the Pro 
 * edition by using the {@link find_ctags} command.
 *  
 * @see tags_filename 
 * @see find_ctags
 *  
 * @categories Tagging_Functions 
 * @since 21.0
 */
_str ctags_filename()
{
   // no ctags, then no ctags tag files
   if (!_haveCtags()) {
      return "";
   }

   // cache most recent successful result
   static _str last_project;
   static _str last_workspace;
   static _str last_cwd;
   static _str last_result;
   if (last_result != "" && 
       last_project == _project_name &&
       last_workspace == _workspace_filename &&
       last_cwd == getcwd() &&
       file_exists(last_result)) {
      return last_result;
   }
   last_project = _project_name;
   last_workspace = _workspace_filename;
   last_cwd = getcwd();

   // look for a project-specific tags file
   if (_project_name != "") {
      filename := _strip_filename(_project_name, 'E') :+ ".tags";
      if (file_exists(filename)) {
         return filename;
      }
      filename = _strip_filename(_project_name, 'N') :+ "tags";
      if (file_exists(filename)) {
         return filename;
      }
   }

   // look for a workspace-specific tags file
   if (_workspace_filename != "") {
      filename := _strip_filename(_workspace_filename, 'E') :+ ".tags";
      if (file_exists(filename)) {
         return filename;
      }
      filename = _strip_filename(_workspace_filename, 'N') :+ "tags";
      if (file_exists(filename)) {
         return filename;
      }
   }

   // look for a tags file in the current directory
   if (file_exists("tags")) {
      return absolute("tags", last_cwd);
   }

   // no tags
   return "";
}

/**
 * Insert a match into the current match set corresponding to the given 
 * line from a ctags generated tag file. 
 * 
 * @param tag_file        ctags generated tags file 
 * @param line            line extracted from the tags file     
 * @param refineSymbol    refine the symbol using SlickEdit's tagging (slower)
 * @param caseSensitive   use case-sensitive matching to refine symbol
 * 
 * @return 0 on success, message code &lt; 0 on error.
 */
static int tag_add_match_from_ctags_file(_str tag_file, _str line, 
                                         bool refineSymbol=true,
                                         bool caseSensitive=true)
{
   // parse the ctags information, ignore anything after the tag address
   parse line with auto tagname "\t" auto filename "\t" auto tagaddress ";\"\t" .;
   if (tagname == "" || filename == "") {
      return STRING_NOT_FOUND_RC;
   }

   // get the file name
   tag_file_dir := _strip_filename(tag_file, 'N');
   filename = relative(filename, tag_file_dir);

   // open the file in a temporary view
   status := _open_temp_view(filename, auto temp_wid, auto orig_wid);
   if (status < 0) {
      return status;
   }

   // now we search for the tag
   save_search(auto s1,auto s2,auto s3, auto s4, auto s5);
   tagaddress = strip(tagaddress);
   if (isuinteger(tagaddress)) {
      // simple line number
      p_RLine = (int)tagaddress;
   } else if (_first_char(tagaddress) == "/" && _last_char(tagaddress) == "/") {
      // forward search expression
      tagaddress = substr(tagaddress,2,length(tagaddress)-2);
      tagaddress = stranslate(tagaddress,"","\r");
      if (_first_char(tagaddress) == "^" && _last_char(tagaddress) == "$") {
         tagaddress = "^":+_escape_re_chars(substr(tagaddress,2,length(tagaddress)-2),'U'):+"$";
      } else if (_first_char(tagaddress) == "^") {
         tagaddress = "^":+_escape_re_chars(substr(tagaddress,2),'U');
      } else if (_last_char(tagaddress) == "R") {
         tagaddress = _escape_re_chars(substr(tagaddress,1,length(tagaddress)-1),'U'):+"$";
      } else {
         tagaddress = _escape_re_chars(tagaddress,'U');
      }
      top(); _begin_line();
      status = search(tagaddress, '@Uh+');
   } else if (_first_char(tagaddress) == "?" && _last_char(tagaddress) == "?") {
      // reverse search expression
      tagaddress = substr(tagaddress,2,length(tagaddress)-2);
      tagaddress = stranslate(tagaddress,"","\r");
      if (_first_char(tagaddress) == "^" && _last_char(tagaddress) == "$") {
         tagaddress = "^":+_escape_re_chars(substr(tagaddress,2),'U'):+"$";
      } else if (_first_char(tagaddress) == "^") {
         tagaddress = "^":+_escape_re_chars(substr(tagaddress,2),'U');
      } else if (_last_char(tagaddress) == "R") {
         tagaddress = _escape_re_chars(substr(tagaddress,2),'U'):+"$";
      } else {
         tagaddress = _escape_re_chars(tagaddress,"U");
      }
      bottom(); _end_line();
      status = search(tagaddress, '@Uh-');
   } else {
      // some other 'vi' command
      status = ex_parse_and_execute(tagaddress);
   }
   restore_search(s1,s2,s3,s4,s5);

   // now we get fancy, to convert the primative ctags match to a
   // beautiful SlickEdit tagging match.
   found_one := false;
   if (refineSymbol) {
      _UpdateContext(true);
      context_id := tag_current_context();
      if (context_id <= 0) {
         context_id = tag_nearest_context(p_RLine, SE_TAG_FILTER_ANYTHING, true);
      }
      if (context_id > 0) {
         tag_get_detail2(VS_TAGDETAIL_context_name, context_id, auto cur_tag_name);
         if (pos(tagname,cur_tag_name)) {
            tag_insert_match_fast(VS_TAGMATCH_context, context_id);
            found_one = true;
         }
      }
      if (!found_one) {
         context_id = tag_find_context_iterator(tagname, true, caseSensitive);
         while (context_id > 0) {
            tag_insert_match_fast(VS_TAGMATCH_context, context_id);
            found_one = true;
            context_id = tag_next_context_iterator(tagname, context_id, true, caseSensitive);
         }
      }
   }

   // just insert a primative match
   if (!found_one) {
      tag_init_tag_browse_info(auto cm, tagname, "", SE_TAG_TYPE_NULL, SE_TAG_FLAG_NULL, filename, p_RLine);
      tag_insert_match_browse_info(cm);
   }

   // that's all folks
   _delete_temp_view(temp_wid);
   activate_window(orig_wid);
   return 0;
}

/**
 * Find the given symbol in the current active tags file.
 * 
 * @param tag_file        ctags generated tags file 
 * @param cur_symbol      symbol (or regular expression for symbol) to search for
 * @param exactMatch      if 'true' expect an exact match, otherwise expect a prefix match
 * @param prefixMatch     if 'true', look for a prefix match, otherwise 
 *                        expect a substring match
 * @param refineSymbol    refine the symbol using SlickEdit's tagging (slower)
 * @param caseSensitive   use case-sensitive matching to find symbols
 * @param regex_type      if 'cur_symbol' is a regular expression, indicate the type 
 *                        of regular expression to use ('P' = Perl/Unix, or 'R' = SlickEdit) 
 * @param max_matches     maximum number of results to return
 *  
 * @return 0 on success, message code &lt; 0 on error.
 * 
 * @see find_ctags
 *  
 * @categories Tagging_Functions 
 * @since 21.0
 */
int tag_list_symbols_in_ctags_file(_str tag_file, 
                                   _str cur_symbol, 
                                   bool exactMatch=true, 
                                   bool prefixMatch=true,
                                   bool refineSymbol=true,
                                   bool caseSensitive=false,
                                   _str regex_type="",
                                   int &num_matches=0,
                                   int max_matches=def_tag_max_find_context_tags)
{
   // no ctags, then just bail out
   if (!_haveCtags()) {
      return VSRC_FEATURE_REQUIRES_STANDARD_EDITION;
   }

   // make sure they provided a tag file
   if (tag_file == "") {
      tag_file = ctags_filename();
      if (tag_file == "") {
         return FILE_NOT_FOUND_RC;
      }
   }

   // open the ctags file in a temp view
   status := _open_temp_view(tag_file, 
                             auto temp_wid, auto orig_wid, 
                             "+fu", auto buffer_already_exists, 
                             false, 
                             false /* force fundamental mode for speed */ );
   if (status < 0) {
      return status;
   }

   // set up search options
   cur_symbol_re := cur_symbol;
   if (regex_type == "") {
      regex_type = "U";
      cur_symbol_re = _escape_re_chars(cur_symbol, regex_type);
   }
   if (prefixMatch) cur_symbol_re = "^" :+ cur_symbol_re;
   search_opts :=  regex_type;
   search_opts :+= caseSensitive? "":"i";
   search_opts :+= exactMatch? "w":"";

   // find all matches
   save_search(auto s1,auto s2,auto s3, auto s4, auto s5);
   status = search(cur_symbol_re, search_opts:+"@h");
   while (!status) {
      get_line(auto line);
      parse line with auto tagname "\t";
      if (!pos(cur_symbol_re, tagname, 1, search_opts)) {
         status = repeat_search();
         continue;
      }
      status = tag_add_match_from_ctags_file(tag_file, line, refineSymbol, caseSensitive);
      if (status < 0) {
         status = repeat_search();
         continue;
      }
      if (++num_matches >= max_matches) break;
      if (_CheckTimeout()) break;
      if (_IsKeyPending()) break;
      status = repeat_search();
   }
   restore_search(s1,s2,s3,s4,s5);

   _delete_temp_view(temp_wid);
   activate_window(orig_wid);
   if (num_matches <= 0) {
      return VSCODEHELPRC_NO_SYMBOLS_FOUND;
   }

   // that's all folks
   return num_matches;
}

/**
 * Search for a symbol matching the given symbol in the current ctags generated 
 * tag file, and navigate to that symbol.
 * 
 * @param cur_symbol   symbol to search for
 * @param quiet        display message if symbol is not found
 * 
 * @return 0 on success, message code &lt; 0 on error.
 *  
 * @see ctags_filename 
 * @see find_tag 
 * @see push_tag
 *  
 * @categories Tagging_Functions 
 * @since 21.0
 */
_command find_ctags(_str cur_symbol="", bool quiet=false) name_info(CTAGS_ARG','VSARG2_EDITORCTL|VSARG2_READ_ONLY|VSARG2_REQUIRES_MDI)
{
   if (!_haveCtags()) {
      popup_nls_message(VSRC_FEATURE_REQUIRES_STANDARD_EDITION, "C-Tags");
      return VSRC_FEATURE_REQUIRES_STANDARD_EDITION;
   }

   // do we even have a 'ctags' file?
   tag_file := ctags_filename();
   if (tag_file == "") {
      if (!quiet) {
         message("Could not find ctags database.");
      }
      return FILE_NOT_FOUND_RC;
   }

   // did they give us something to look for?
   if (cur_symbol == "") {
      if (!quiet) {
         message("No identifier under cursor.");
      }
      return VSCODEHELPRC_CONTEXT_NOT_VALID;
   }

   // clear the match set and search
   _SetTimeout(def_tag_max_list_matches_time);
   tag_lock_matches();
   tag_push_matches();
   caseSensitive := (_GetCodehelpFlags() & VSCODEHELPFLAG_GO_TO_DEF_CASE_SENSITIVE) != 0;
   status := tag_list_symbols_in_ctags_file(tag_file, cur_symbol, true, true, true, caseSensitive);
   if (status < 0) {
      if (!quiet) {
         message(get_message(status, cur_symbol));
      }
      tag_pop_matches();
      tag_unlock_matches();
      _SetTimeout(0);
      return status;
   }

   // select a symbol from the list of matches
   tag_init_tag_browse_info(auto cm);
   tag_remove_duplicate_symbol_matches();
   match_id := tag_select_symbol_match(cm);
   tag_pop_matches();
   tag_unlock_matches();
   _SetTimeout(0);

   // this can only happen if cancelled from the select symbol dialog
   if (match_id < 0) {
      return match_id;
   }

   // that's all folks!
   push_tag_in_file(cm.member_name, cm.file_name, cm.class_name, cm.type_name, cm.line_no);
   return 0;
}
int _OnUpdate_find_ctags(CMDUI &cmdui,int target_wid,_str command)
{
   if (!_haveCtags()) return MF_GRAYED;
   if (ctags_filename() == "") return MF_GRAYED;
   return(_OnUpdate_push_ref(cmdui,target_wid,command));
}

/**
 * Search for a symbol matching the given Unix regular expression in the 
 * current ctags generated tag file, and navigate to that symbol.
 * 
 * @param cur_symbol   symbol to search for
 * @param quiet        display message if symbol is not found
 * 
 * @return 0 on success, message code &lt; 0 on error.
 *  
 * @see ctags_filename 
 * @see find_ctags
 * @see find_tag 
 * @see push_tag
 *  
 * @categories Tagging_Functions 
 * @since 21.0
 */
_command grep_ctags(_str cur_symbol="", _str options="", bool quiet=false) name_info(','VSARG2_EDITORCTL|VSARG2_READ_ONLY|VSARG2_REQUIRES_MDI)
{
   if (!_haveCtags()) {
      popup_nls_message(VSRC_FEATURE_REQUIRES_STANDARD_EDITION, "C-Tags");
      return VSRC_FEATURE_REQUIRES_STANDARD_EDITION;
   }

   // do we even have a 'ctags' file?
   tag_file := ctags_filename();
   if (tag_file == "") {
      if (!quiet) {
         message("Could not find ctags database.");
      }
      return FILE_NOT_FOUND_RC;
   }

   // did they give us something to look for?
   if (cur_symbol == "") {
      if (!quiet) {
         message("No identifier under cursor.");
      }
      return VSCODEHELPRC_CONTEXT_NOT_VALID;
   }

   // default search options
   regex_type := "";
   caseSensitive := (_GetCodehelpFlags() & VSCODEHELPFLAG_GO_TO_DEF_CASE_SENSITIVE) != 0;
   exactMatch := false;

   // parse search options
   options = upcase(options);
   if (pos("R", options)) regex_type = "R";
   if (pos("L", options)) regex_type = "U";
   if (pos("U", options)) regex_type = "U";
   if (pos("B", options)) regex_type = "U";
   if (pos("%", options)) regex_type = "&";
   if (pos("I", options)) caseSensitive = false;
   if (pos("E", options)) caseSensitive = true;
   if (pos("W", options)) exactMatch = true;

   // clear the match set and search
   _SetTimeout(def_tag_max_list_matches_time*10);
   tag_lock_matches();
   tag_push_matches();
   status := tag_list_symbols_in_ctags_file(tag_file, cur_symbol, exactMatch, false, true, caseSensitive, regex_type);
   if (status < 0) {
      if (!quiet) {
         message(get_message(status, cur_symbol));
      }
      tag_pop_matches();
      tag_unlock_matches();
      _SetTimeout(0);
      return status;
   }

   // select a symbol from the list of matches
   tag_init_tag_browse_info(auto cm);
   tag_remove_duplicate_symbol_matches();
   match_id := tag_select_symbol_match(cm);
   tag_pop_matches();
   tag_unlock_matches();
   _SetTimeout(0);

   // this can only happen if cancelled from the select symbol dialog
   if (match_id < 0) {
      return match_id;
   }

   // that's all folks!
   push_tag_in_file(cm.member_name, cm.file_name, cm.class_name, cm.type_name, cm.line_no);
   return 0;
}
int _OnUpdate_grep_ctags(CMDUI &cmdui,int target_wid,_str command)
{
   if (!_haveCtags()) return MF_GRAYED;
   if (ctags_filename() == "") return MF_GRAYED;
   return(_OnUpdate_push_ref(cmdui,target_wid,command));
}

/**
 * Perform argument completion matching on a symbol in the current 
 * ctags generated tag file.
 * 
 * @param name         symbol prefix to look for
 * @param find_first   find first match, or find subsequent matches?
 * 
 * @return Returns "" if there are no more matches, or a symbol name otherwise.
 *  
 * @see find_ctags 
 * @see grep_ctags
 *  
 * @categories Tagging_Functions 
 * @since 21.0
 */
_str ctags_match(_str name, bool find_first)
{
   // used to iterate through match set
   static int match_index;

   // first time in
   if (find_first) {
      // do we even have a 'ctags' file?
      tag_file := ctags_filename();
      if (tag_file == "") {
         return "";
      }
      if (name == "") {
         return "";
      }

      // clear the match set and search
      tag_clear_matches();
      _SetTimeout(500);
      caseSensitive := (_GetCodehelpFlags() & VSCODEHELPFLAG_GO_TO_DEF_CASE_SENSITIVE) != 0;
      status := tag_list_symbols_in_ctags_file(tag_file, name, false, true, false, caseSensitive, "", auto n=0, def_argument_completion_maximum);
      if (status < 0) {
         _SetTimeout(0);
         return "";
      }

      // initialize iterator for match set
      match_index=0;
      _SetTimeout(0);
   }

   // do we have more items to return?
   if (++match_index <= tag_get_num_of_matches()) {
      tag_get_detail2(VS_TAGDETAIL_match_name, match_index, auto cur_tag_name);
      return cur_tag_name;
   }

   // no more matches
   return "";
}

static void tag_build_ctags_progress_message(int i, int n, _str filename)
{
   message("CTags Searching ("(i+1)" of "n", press any key to cancel): ":+filename);
}

/**
 * Use ctags to generate a tag file for the source files listed.
 * 
 * @param tag_file    tags file to generate
 * @param fileList    array of source files to tag
 * @param quiet       suppress progress messages
 * 
 * @return 0 on success, message code &lt; 0 on error.
 */
static int tag_build_ctags_file(_str tag_file, _str (&fileList)[], 
                                bool quiet=false, bool doAppend=false, 
                                int &runningCount=0, int runningTotal=0)
{
   if (!_haveCtags()) {
      return VSRC_FEATURE_REQUIRES_STANDARD_EDITION;
   }

   // try to use user setting, or do a path search to find it.
   ctags_exe := def_ctags_exe;
   if (!file_exists(ctags_exe)) {
      ctags_exe = "";
   }
   if (ctags_exe == "") {
      ctags_exe = get_env("VSLICKBIN1");
      _maybe_append_filesep(ctags_exe);
      ctags_exe :+= "ctags":+EXTENSION_EXE;
   }
   if (!file_exists(ctags_exe)) {
      ctags_exe = "";
   }
   if (ctags_exe == "") {
      ctags_exe = path_search("ctags":+EXTENSION_EXE);
   }
   if (ctags_exe == "") {
      if (!quiet) {
         message("No 'ctags' executable in the current path");
      }
      return FILE_NOT_FOUND_RC;
   }

   // build tag file relative to tag file directory
   tag_file_dir  := _strip_filename(tag_file, "n");
   tag_file_name := _strip_filename(tag_file, "p");
   current_dir := getcwd();
   _maybe_append_filesep(current_dir);
   needToPopDirectory := false;
   if (!_file_eq(current_dir, tag_file_dir)) {
      pushd(tag_file_dir, true);
      needToPopDirectory = true;
   }

   status := 0;
   i := 0;
   n := fileList._length();
   if (!doAppend) runningCount=0;
   if (!runningTotal) runningTotal=n;
   if (n > 0) {

      // On MacOS, and perhaps also older Unix platforms, 
      // ctags does not support the -L argument, so don't bother with
      // the more elegent approach of sending files to standard input
#if 0

      pipe_handle := _PipeProcess(_maybe_quote_filename(ctags_exe):+" -t -d -L - -f ":+_maybe_quote_filename(tag_file), auto hvarIn, auto hvarOut, auto hvarErr, "");
      if (pipe_handle < 0) {
         return pipe_handle;
      }
      for (i=0; i<n; i++) {
         if (!quiet) {
            tag_build_ctags_progress_message(i, n, fileList[i]);
         }
         _PipeWrite(hvarIn, fileList[i]:+"\n");
         process_events(auto cancel);
         if (_IsKeyPending(false)) break;
      }
      if (_isWindows()) {
         _PipeWrite(hvarIn,"\x1a");
      }
      _PipeCloseProcess(pipe_handle);

#else

      if (!quiet) {
         tag_build_ctags_progress_message(runningCount, runningTotal, fileList[i]);
      }
      append_option := doAppend? "-a" : "";
      while ( i<n ) {
         if (!quiet) {
            tag_build_ctags_progress_message(runningCount, runningTotal, fileList[i]);
            process_events(auto cancel);
         }
         cmdline :=  _maybe_quote_filename(ctags_exe);
         cmdline :+= " " :+ def_ctags_options;
         cmdline :+= " " :+ append_option;
         cmdline :+= " -f " :+ _maybe_quote_filename(tag_file_name);
         for (j:=0; i<n && length(cmdline) < 800; j++,i++,runningCount++) {
            src_file_name := relative(fileList[i], tag_file_dir);
            cmdline :+= " " :+ _maybe_quote_filename(src_file_name);
         }
         _PipeShellResult(cmdline, status, "");
         if (status < 0) break;
         if (_IsKeyPending(false)) {
            status = COMMAND_CANCELLED_RC;
            break;
         }
         append_option = "-a";
      }

#endif

   }

   // restore current working directory 
   if (needToPopDirectory) {
      popd(true); 
   }

   // That's all folks
   if (!quiet) {
      if (i < n) {
         sticky_message("CTags interrupted building: ":+tag_file" -- ":+get_message(status));
      } else {
         message("CTags finished building: ":+tag_file);
      }
   }
   return 0;
}

/**
 * Use ctags to generate a tag file for the source files in the current project.
 *  
 * @param projectName   project to build tags for
 * @param quiet         suppress informational messages
 * 
 * @return 0 on success, message code &lt; 0 on error.
 *  
 * @categories Tagging_Functions 
 * @since 21.0
 */
_command int project_build_ctags(_str projectName=_project_name, bool quiet = false) name_info(','VSARG2_REQUIRES_PROJECT_SUPPORT)
{
   if (!_haveCtags()) {
      popup_nls_message(VSRC_FEATURE_REQUIRES_STANDARD_EDITION, "C-Tags");
      return VSRC_FEATURE_REQUIRES_STANDARD_EDITION;
   }
   if (_workspace_filename == "" || projectName == "") {
      return FILE_NOT_FOUND_RC;
   }

   status := _getProjectFiles(_workspace_filename, projectName, auto fileList, 1);
   if (status < 0) {
      return status;
   }

   tag_file := _strip_filename(projectName,'E'):+".tags";
   return tag_build_ctags_file(tag_file, fileList, quiet);
}

int _OnUpdate_project_build_ctags(CMDUI &cmdui,int target_wid,_str command)
{
   if (!_haveCtags()) {
      return MF_GRAYED;
   }
   if (_workspace_filename=="" || _project_name=="") {
      return(MF_GRAYED);
   }
   return(MF_ENABLED);
}

/**
 * Use ctags to generate a tag file for the source files in the current workspace.
 * 
 * @param quiet      suppress informational messages
 * 
 * @return 0 on success, message code &lt; 0 on error.
 *  
 * @categories Tagging_Functions 
 * @since 21.0
 */
_command int workspace_build_ctags(bool quiet = false) name_info(','VSARG2_REQUIRES_PROJECT_SUPPORT)
{
   if (!_haveCtags()) {
      popup_nls_message(VSRC_FEATURE_REQUIRES_STANDARD_EDITION, "C-Tags");
      return VSRC_FEATURE_REQUIRES_STANDARD_EDITION;
   }
   if (_workspace_filename == "") {
      return FILE_NOT_FOUND_RC;
   }

   status := _getProjectFilesInWorkspace(_workspace_filename, auto ProjectFilenames);
   if (status < 0) {
      return status;
   }

   tag_file := _strip_filename(_workspace_filename,'E'):+".tags";
   doAppend := false;
   result   := 0;
   runningCount := 0;
   runningTotal := 0;

   // first get the total number of files to tag
   for (i:=0;i<ProjectFilenames._length();++i) {
      absProjectFilename := _AbsoluteToWorkspace(ProjectFilenames[i]);
      if (!_ProjectFileExists(absProjectFilename)) continue;
      taggingOption := _ProjectGet_TaggingOption(_ProjectHandle(absProjectFilename));
      if (taggingOption != VPJ_TAGGINGOPTION_NONE) {
         runningTotal += _getNumProjectFiles(_workspace_filename, absProjectFilename);
      }
   }

   // make the current working directory the tag file directory
   needToPopDirectory := false;
   tag_file_dir := _strip_filename(tag_file, 'n');
   current_dir  := getcwd();
   _maybe_append_filesep(current_dir);
   if (!_file_eq(current_dir, tag_file_dir)) {
      pushd(tag_file_dir, true);
      needToPopDirectory = true;
   }

   // now go through and tag each project
   for (i=0;i<ProjectFilenames._length();++i) {
      // Get this project and check if it has a project-specific tag file
      absProjectFilename := _AbsoluteToWorkspace(ProjectFilenames[i]);
      if (!_ProjectFileExists(absProjectFilename)) continue;
      taggingOption := _ProjectGet_TaggingOption(_ProjectHandle(absProjectFilename));
      if (taggingOption != VPJ_TAGGINGOPTION_NONE) {
         _getProjectFiles(_workspace_filename, absProjectFilename, auto projectFileList, 1);
         status = tag_build_ctags_file(tag_file, projectFileList, quiet, doAppend, runningCount, runningTotal);
         if (status < 0) result = status;
         doAppend = true;
      }
   }

   // restore current working directory 
   if (needToPopDirectory) {
      popd(true); 
   }

   // that's all folks
   return result;
}

int _OnUpdate_workspace_build_ctags(CMDUI &cmdui,int target_wid,_str command)
{
   if (!_haveCtags()) {
      return MF_GRAYED;
   }
   if (_workspace_filename=="") {
      return(MF_GRAYED);
   }
   return(MF_ENABLED);
}

