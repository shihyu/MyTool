////////////////////////////////////////////////////////////////////////////////////
// Copyright 2010 SlickEdit Inc. 
// You may modify, copy, and distribute the Slick-C Code (modified or unmodified) 
// only if all of the following conditions are met: 
//   (1) You do not include the Slick-C Code in any product or application 
//       designed to run independently of SlickEdit software programs; 
//   (2) You do not use the SlickEdit name, logos or other SlickEdit 
//       trademarks to market Your application; 
//   (3) You provide a copy of this license with the Slick-C Code; and 
//   (4) You agree to indemnify, hold harmless and defend SlickEdit from and 
//       against any loss, damage, claims or lawsuits, including attorney's fees, 
//       that arise or result from the use or distribution of Your application.
////////////////////////////////////////////////////////////////////////////////////
#pragma option(pedantic,on)
#region Imports
#include "slick.sh"
#include "project.sh"
#include "xml.sh"
#import "compile.e"
#import "files.e"
#import "makefile.e"
#import "projconv.e"
#import "saveload.e"
#import "stdcmds.e"
#import "stdprocs.e"
#import "wkspace.e"
#endregion


static const MAKEFILE_BANNER=          "# SlickEdit generated file.  Do not edit this file except in designated areas.";
static const MAKEFILE_USERMOD_BEGIN=   "# -----Begin user-editable area-----";
static const MAKEFILE_USERMOD_END=     "# -----End user-editable area-----";
static const MAKEFILE_EXTENSION=       ".mak";
static const MAKEFILE_GENERATION_MSG=  "Generating makefile for project '%s1'...";
static const MAKEFILE_DEFAULT_FILE=    "%rp%rn.mak";

static const MAKEFILE_FORMAT_GNUMAKE=  1;
static const MAKEFILE_FORMAT_NMAKE=    2;
static const MAKEFILE_FILESEP_GNUMAKE= "/";
static const MAKEFILE_FILESEP_NMAKE=   "\\";

static const SOURCE_EXTENSION_LIST=    ";*.c;*.cc;*.cp;*.cpp;*.cppm;*.cxx;*.c++;*.C;*.s;*.asm;*.masm;";
static const HEADER_EXTENSION_LIST=    ";*.h;*.hh;*.hp;*.hpp;*.hxx;*.h++;*.H;*.inl;*.ixx;*.qth;";

/**
 * If true, automatically generated makefiles will include header file dependencies.
 *
 * @default true
 * @categories Configuration_Variables
 */
bool def_projmake_makedepend=true;


struct COMPILE_TOOL_INFO
{
   _str     cmdLine;
   _str     variableName;
   _str     inputExt;
   _str     outputExt;
   bool  linkObject; // add files of this type to link object list
   _str     chainedOutputExt; // final output ext after all rules are chained
   bool  chainedLinkObject;
   bool  ignore; // true for headers and other files that should not be included in the makefile
};


/**
 * Generate a makefile from the specified project
 *
 * @param projectName
 *               Absolute filename of the project to build a makefile for
 * @param makefileName
 *               Filename to use for the makefile.  This should be relative
 *               to the project directory
 * @param openAfterGen
 *               Open the makefile for editing after generation
 * @param promptForInfo
 *               Prompt the user for information about the makefile
 * @param replaceEnvVars
 *               Replace %(ENVVAR) with its value
 *
 *               T - Replace %(ENVVAR) with value
 *               F - Replace %(ENVVAR) with $(ENVVAR)
 *
 * @return 0 on success, <0 otherwise
 */
_command int generate_makefile(_str projectName = _project_name, _str makefileName = "",
                               bool openAfterGen = true, bool promptForInfo = false,
                               bool replaceEnvVars = false, bool quiet = false) name_info(','VSARG2_CMDLINE|VSARG2_REQUIRES_MDI)
{
   status := 0;

   // note that the makefile is being generated
   mou_hour_glass(true);

   // open the project
   int projectHandle = _xmlcfg_open(projectName, status);
   if (status) return status;

   // load the configurations list
   numConfigs := 0;
   _str configList[] = null;
   _str gnucConfigList[] = null;
   _str vcppConfigList[] = null;
   _ProjectGet_ConfigNames(projectHandle, configList);
   int i;
   for (i = 0; i < configList._length(); i++) {
      // if this config supports makefile generation, put it in the proper list
      switch(lowcase(_ProjectGet_Type(projectHandle, configList[i]))) {
         case "gnuc":
            gnucConfigList[gnucConfigList._length()] = configList[i];
            numConfigs++;
            break;

         case "vcpp":
            vcppConfigList[vcppConfigList._length()] = configList[i];
            numConfigs++;
            break;

         default:
            // config not supported for makefile generation
            break;
      }
   }

   // make sure there were configurations that support makefile generation
   if (numConfigs <= 0) {
      // notify user
      _message_box("The project '" projectName "' has no configurations that support makefile generation.");
      return 0;
   }

   // build the filename for the makefile.  if no makefile is specified, it will default
   // to projectname.mak.  this is done by passing %rp%rn.mak to _parse_project_command
   _str filename = makefileName;
   if (filename == "") {
      // check the project file for the makefile name
      filename = _ProjectGet_BuildMakeFile(projectHandle);

      // if still empty supply the default
      if (filename == "") {
         filename = MAKEFILE_DEFAULT_FILE;
      }
   }
   filename = _parse_project_command(filename, "", projectName, "");

   // prompt the user for the makefile name if necessary
   if (promptForInfo) {
      // get the makefilename relative to the project dir
      if (filename != "") {
         filename = _RelativeToProject(filename, projectName);
      }

      // clear the generating makefile message
      clear_message();
      mou_set_pointer(0); //mou_hour_glass(false);

      _str promptResult = show("-modal _textbox_form",
                               "Enter the name for the makefile",
                               0,
                               "",
                               "",
                               "",
                               "",
                               "Makefile name:" filename);
      if (promptResult == "") {
         // user cancelled makefile generation
         return 0;
      }

      filename = _param1;
      if (filename == "") {
         filename = MAKEFILE_DEFAULT_FILE;
      }

      filename = _parse_project_command(filename, "", projectName, "");

      // get the filename absolute to the project dir
      filename = _AbsoluteToProject(filename, projectName);

      // note that the makefile is being generated
      mou_hour_glass(true);
      //message(MAKEFILE_GENERATION_MSG);
   }

   makefileGenMsg := stranslate(MAKEFILE_GENERATION_MSG, _strip_filename(projectName, "P"), "%s1");
   message(makefileGenMsg);

   // expand the Files node to make sure wildcards are expanded
   _ExpandXMLFilesNode(projectHandle, _ProjectGet_FilesNode(projectHandle));

   // if there are both gnuc and vcpp makefiles to generate, the makefile name must be modified
   // so that both files can be generated
   if (gnucConfigList._length() > 0 && vcppConfigList._length() > 0) {
      // this do while(false) loop is here to allow breaking out of this code early without
      // using a return statement (so it will still go thru the cleanup code at the end)
      do {
         // generate gnuc makefile with the gnuc configurations
         gnucMakefileName := _strip_filename(filename,'E') "-gnu" _get_extension(filename, true);
         status = generate_makefile_type(projectHandle, gnucMakefileName, MAKEFILE_FORMAT_GNUMAKE,
                                         gnucConfigList, openAfterGen, replaceEnvVars, quiet);
         if (status) break;

         // generate vcpp makefile with the vcpp configurations
         vcppMakefileName := _strip_filename(filename,'E') "-vcpp" _get_extension(filename, true);
         status = generate_makefile_type(projectHandle, vcppMakefileName, MAKEFILE_FORMAT_NMAKE,
                                         vcppConfigList, openAfterGen, replaceEnvVars, quiet);
      } while(false);

   } else if (gnucConfigList._length() > 0) {
      // generate the makefile
      status = generate_makefile_type(projectHandle, filename, MAKEFILE_FORMAT_GNUMAKE,
                                      gnucConfigList, openAfterGen, replaceEnvVars, quiet);

   } else if (vcppConfigList._length() > 0) {
      // generate the makefile
      status = generate_makefile_type(projectHandle, filename, MAKEFILE_FORMAT_NMAKE,
                                      vcppConfigList, openAfterGen, replaceEnvVars, quiet);
   }

   // clear the generating makefile message
   if (status) {
      message("Makefile generation failed (" status ")");
   } else {
      clear_message();
   }
   mou_hour_glass(false);

   // close the project file
   _xmlcfg_close(projectHandle);

   return status;
}

static _str getRecursiveDependenciesForSourceFile(_str relSourceFile, 
                                                  _str (&dependenciesForSourceFiles):[][], 
                                                  _str (&dependenciesForHeaderFiles):[],
                                                  bool foundHeaderFiles:[]) 
{
   relSourceFile = _file_case(relSourceFile);
   if (!dependenciesForSourceFiles._indexin(relSourceFile)) {
      return "";
   }
   if (dependenciesForHeaderFiles._indexin(relSourceFile)) {
      return dependenciesForHeaderFiles:[relSourceFile];
   }
   includeFileDependencies := "";
   foreach ( auto relIncludeFile in dependenciesForSourceFiles:[relSourceFile] ) {
      if (foundHeaderFiles._indexin(_file_case(relIncludeFile))) {
         continue;
      }
      _maybe_append(includeFileDependencies, ' ');
      includeFileDependencies :+= _maybe_quote_filename(relIncludeFile);
      foundHeaderFiles:[_file_case(relIncludeFile)] = true;
      recursiveDependencies := getRecursiveDependenciesForSourceFile(relIncludeFile, dependenciesForSourceFiles, dependenciesForHeaderFiles, foundHeaderFiles);
      if ( recursiveDependencies != "" ) {
         _maybe_append(includeFileDependencies, ' ');
         includeFileDependencies :+= recursiveDependencies;
      }
   }
   dependenciesForHeaderFiles:[relSourceFile] = includeFileDependencies;
   return includeFileDependencies;
}

/**
 */
static int generate_makefile_type(int projectHandle, 
                                  _str makefileName, int makefileFormat,
                                  _str (&configList)[], bool openAfterGen,
                                  bool replaceEnvVars, bool quiet)
{
   status := 0;
   warnAboutPaths := false;
   projectName := _xmlcfg_get_filename(projectHandle);

   // check project name for spaces
   if (pos(" ", projectName)) {
      warnAboutPaths = true;
   }

   // open the file
   tempViewID := 0;
   origViewID := 0;
   status = _open_temp_view(makefileName, tempViewID, origViewID);
   if (status) {
      // if the file was not found, create it
      if (status == FILE_NOT_FOUND_RC) {
         origViewID = _create_temp_view(tempViewID);
         if (origViewID == "") {
            return INSUFFICIENT_MEMORY_RC;
         }
      } else {
         return status;
      }
   }

   // scan for user changes that should be preserved
   userMod := "";
   top();
   status = search("^"_escape_re_chars(MAKEFILE_USERMOD_BEGIN) "$","@rh");
   if (status == 0) {
      // step to next line
      down();
      userModStart := _QROffset();

      status = search("^" _escape_re_chars(MAKEFILE_USERMOD_END) "$", "@rh");
      if (status == 0) {
         userModEnd := _QROffset();
         long userModLength = userModEnd - userModStart;
         if (userModLength > 0) {
            userMod = get_text((int)userModLength, (int)userModStart);
         }
      }
   }

   // now that the users modifications have been saved, clear the file and start over
   p_window_id = origViewID;
   _delete_temp_view(tempViewID);
   tempViewID = 0;

   origViewID = _create_temp_view(tempViewID);
   if (origViewID == "") {
      // clear the generating makefile message
      clear_message();
      mou_hour_glass(false);
      return INSUFFICIENT_MEMORY_RC;
   }
   p_buf_name = makefileName;
   p_UTF8 = _load_option_UTF8(p_buf_name);

   // add the banner to the top of the file
   insert_line(MAKEFILE_BANNER);

   // set the make command that will be used to make all dependencies
   insert_line("");
   insert_line("# Make command to use for dependencies");
   switch(makefileFormat) {
      case MAKEFILE_FORMAT_GNUMAKE:
         insert_line("MAKE="  _findGNUMake());
         insert_line("RM=rm");
         insert_line("MKDIR=mkdir");
         break;

      case MAKEFILE_FORMAT_NMAKE:
         insert_line("MAKE=nmake");
         insert_line("RM=del");
         insert_line("MKDIR=mkdir");
         break;
   }
   insert_line("");

   // add the users modifications
   insert_line(MAKEFILE_USERMOD_BEGIN);
   if (length(userMod) > 0) {
      // userMod is exactly as it was entered by the user, including
      // any line endings.  therefore, a blank line is entered to move
      // to the next line and then the data is entered.  this always
      // results in an extra blank line so it is removed from the end
      insert_line("");
      _insert_text(userMod);
      _insert_text(MAKEFILE_USERMOD_END);
      //down();
      //delete_line();
   } else {
      // leave one blank line for the user to begin editing
      insert_line("");
      insert_line(MAKEFILE_USERMOD_END);
   }
   //insert_line(MAKEFILE_USERMOD_END);

   // this will be populated with relative paths to source files.  the list will then
   // be used to construct build rules that cover source files in each folder
   bool sourcedirHash:[];
   _str sourcefileArray[];

   // this will be populated with absolute paths to include directories
   bool absIncludeDirsFound:[];
   _str absIncludeDirsArray[];

   // array of all compile commands for a configuration (includes extension-specific commands)
   // NOTE: this array is used to build the list of commands (COMPILE, COMPILE_RULE1, etc), but
   //       is not used in generation of pattern rules.  pattern rules are generated as needed
   //       based on the compileToolInputHash table
   COMPILE_TOOL_INFO compileToolArray[] = null;

   // hash of compile tools for quick lookup when building pattern rules later
   COMPILE_TOOL_INFO compileToolInputHash:[] = null;
   bool compileToolOutputHash:[] = null;

   // remember which configuration was active
   activeConfig := getActiveProjectConfig(projectName);

   // NOTE: if there is only one configuration, do not use any conditionals when
   // constructing the makefile and do not specify a default config
   if (configList._length() > 1) {
      // setup default configuration if none is specified
      insert_line("");
      insert_line("# If no configuration is specified, \"" configList[0] "\" will be used");
      switch(makefileFormat) {
         case MAKEFILE_FORMAT_GNUMAKE:
            insert_line("ifndef CFG");
            insert_line("CFG=" configList[0]);
            insert_line("endif");
            break;

         case MAKEFILE_FORMAT_NMAKE:
            insert_line("!if \"$(CFG)\" == \"\"");
            insert_line("CFG=" configList[0]);
            insert_line("!endif");
            break;
      }
   }

   // for each configuration, setup its variables
   foreach( auto configName in configList) {

      // find config node
      configNode := _ProjectGet_ConfigNode(projectHandle, configName);
      if (configNode < 0) continue;

      // check configuration name for spaces
      if (pos(" ", configName)) {
         warnAboutPaths = true;
      }

      // clear compile tool information
      compileToolArray._makeempty();
      compileToolInputHash._makeempty();
      compileToolOutputHash._makeempty();

      // make the config active
      // NOTE: at this time, project_config_set_active causes all projects this one is
      //       dependant on to also change configs (which can be quite slow).  it would
      //       be better to make project_config_set_active take a recursive boolean that
      //       defaults to true
      //say("Change config: " configName);
      project_config_set_active(_maybe_quote_filename(configName), projectName, true);

      // restore temp view id after project_config_set_active because it may have been changed
      p_window_id = tempViewID;

      // add configuration label and conditional
      insert_line("");
      insert_line("#");
      insert_line("# Configuration: " configName);
      insert_line("#");
      if (configList._length() > 1) {
         switch(makefileFormat) {
            case MAKEFILE_FORMAT_GNUMAKE:
               insert_line("ifeq \"$(CFG)\" \"" configName "\"");
               break;

            case MAKEFILE_FORMAT_NMAKE:
               insert_line("!if \"$(CFG)\" == \"" configName "\"");
               break;
         }
      }

      // parse primary compile tool
      compileTargetNode := _ProjectGet_TargetNode(projectHandle, "compile", configName);
      compileToolLine := "";
      if (compileTargetNode >= 0) {
         cmdLine   := _ProjectGet_TargetCmdLine(projectHandle, compileTargetNode);
         otherOpts := _ProjectGet_TargetOtherOptions(projectHandle, compileTargetNode);
         outputExt := _ProjectGet_TargetOutputExts(projectHandle,compileTargetNode);

         // build and save the compile command for insertion into the makefile later
         cmdLine = prepareCommand(projectName, makefileFormat, cmdLine, "compile", "", otherOpts, replaceEnvVars, outputExt);
         compileToolLine = "COMPILE=" makeCommandCLSafe(cmdLine);

         //// save information about this compile tool for use building rules
         //COMPILE_TOOL_INFO compileToolInfo;
         //compileToolInfo.cmdLine = cmdLine;
         //compileToolInfo.variableName = "COMPILE";
         //compileToolInfo.inputExt = "";
         //compileToolInfo.outputExt = _ProjectGet_TargetOutputExts(projectHandle, compileTargetNode);
         //compileToolInfo.linkObject = true;
         //compileToolInfo.chainedOutputExt = "";
         //compileToolInfo.chainedLinkObject = true;
         //
         //// remove the wildcard
         //if (first_char(compileToolInfo.outputExt) == '*') {
         //   compileToolInfo.outputExt = substr(compileToolInfo.outputExt, 2);
         //}
         //
         //if (compileToolInfo.outputExt == "") {
         //   // use default
         //   switch(makefileFormat) {
         //      case MAKEFILE_FORMAT_GNUMAKE:
         //         compileToolInfo.outputExt = ".o";
         //         break;
         //
         //      case MAKEFILE_FORMAT_NMAKE:
         //         compileToolInfo.outputExt = ".obj";
         //         break;
         //   }
         //}
         //
         //// add it to the compile tool array for *.c files
         //compileToolInfo.inputExt = ".c";
         //compileToolArray[compileToolArray._length()] = compileToolInfo;
         //
         //// add it to the compile tool array for *.cpp files
         //compileToolInfo.inputExt = ".cpp";
         //compileToolArray[compileToolArray._length()] = compileToolInfo;
      }

      // parse compile rules
      int rulesList[] = null;
      _ProjectGet_Rules(projectHandle, rulesList, "compile", configName);
      foreach (auto ruleNode in rulesList) {
         if (ruleNode < 0) continue;

         cmdLine   := _ProjectGet_TargetCmdLine(projectHandle, ruleNode);
         otherOpts := _ProjectGet_TargetOtherOptions(projectHandle, ruleNode);
         outputExt := _ProjectGet_TargetOutputExts(projectHandle,ruleNode);

         // get list of input extensions
         _str extensionArray[] = null;
         extensionList := _ProjectGet_TargetInputExts(projectHandle, ruleNode);
         loop {
            curExtension := "";
            parse extensionList with curExtension ";" extensionList;

            // remove the wildcard
            _maybe_strip(curExtension, '*', stripFromFront:true);
            if (curExtension == "") break;
            //say("curExtension: " curExtension);

            // add this extension to the array
            extensionArray[extensionArray._length()] = strip(curExtension);
         }

         // build the rule name
         ruleName := "COMPILE";
         if (extensionArray._length() > 0) {
            ruleName :+= extensionArray[0];
         }
         ruleName = stranslate(ruleName, '_', '.');
         ruleName = upcase(ruleName);
         //say("ruleName: " ruleName);

         // create dummy filename with the first extension so that _parse_project_command
         // pulls info from the proper line in the project
         dummyFilename := "";
         if (extensionArray._length() >= 1) {
            dummyFilename = "dummyFilename" extensionArray[0];
         }

         cmdLine = prepareCommand(projectName, makefileFormat, cmdLine, "compile", dummyFilename, otherOpts, replaceEnvVars, outputExt);

         // save information about this compile tool for use building rules
         m := 0;
         for (m = 0; m < extensionArray._length(); m++) {
            COMPILE_TOOL_INFO compileToolInfo;
            compileToolInfo.cmdLine = cmdLine;
            compileToolInfo.variableName = ruleName;
            compileToolInfo.inputExt = extensionArray[m];
            compileToolInfo.outputExt = _ProjectGet_TargetOutputExts(projectHandle, ruleNode);
            compileToolInfo.linkObject = (_ProjectGet_TargetLinkObject(projectHandle, ruleNode) == "0") ? false : true;
            compileToolInfo.chainedOutputExt = "";
            compileToolInfo.chainedLinkObject = true;
            compileToolInfo.ignore = false;

            // remove the wildcard
            _maybe_strip(compileToolInfo.outputExt, '*', stripFromFront:true);
            if (compileToolInfo.outputExt == "") {
               // use default
               switch(makefileFormat) {
                  case MAKEFILE_FORMAT_GNUMAKE:
                     compileToolInfo.outputExt = ".o";
                     break;

                  case MAKEFILE_FORMAT_NMAKE:
                     compileToolInfo.outputExt = ".obj";
                     break;
               }
            }

            // add it to the compile tool array
            compileToolArray[compileToolArray._length()] = compileToolInfo;

            // add it to the compile tool hash table by the input extension
            compileToolInputHash:[compileToolInfo.inputExt] = compileToolInfo;

            // flag the output extension as generated by at least one rule
            compileToolOutputHash:[compileToolInfo.outputExt] = true;
         }
      }

      // build object list of files that are common to all configurations
      commonObjs := "";
      nlCommonObjs := "";
      getObjectList(projectHandle, makefileFormat, sourcedirHash, sourcefileArray, compileToolInputHash, configName, commonObjs, nlCommonObjs, warnAboutPaths, true);

      // check other strings for variables that should be expanded
      outputFile := prepareCommand(projectName, makefileFormat, _ProjectGet_OutputFile(projectHandle, configName), "outfile", "", "", replaceEnvVars);
      includes := prepareCommand(projectName, makefileFormat, "%ir", "includes", "", "", replaceEnvVars);
      libs := prepareCommand(projectName, makefileFormat, "%libs", "libs", "", "", replaceEnvVars);
      dep_libs := getExistingFilesFromList(libs);
      // add any object files that are listed as part of the project directly
      append_object_files(libs,projectHandle,configName,makefileFormat);

      // get the list of include directories for this project
      _ProjectGet_Includes(projectHandle, auto includesArray, configName);
      foreach (auto incdir in includesArray) {
         abs_include_dir := absolute(incdir, _strip_filename(projectName, 'NE'));
         _maybe_append_filesep(abs_include_dir);
         if ( absIncludeDirsFound._indexin(_file_case(abs_include_dir)) ) {
            continue;
         }
         absIncludeDirsFound:[_file_case(abs_include_dir)] = true;
         absIncludeDirsArray :+= abs_include_dir;
      }

      cfgObjs := "";
      nlCfgObjs := "";
      getObjectList(projectHandle, makefileFormat, sourcedirHash, sourcefileArray, compileToolInputHash, configName, cfgObjs, nlCfgObjs, warnAboutPaths);

      // determine whether non-linkable object support is needed
      hasNLObjects := (nlCommonObjs != "" || nlCfgObjs != "");

      fullObjectList := _generate_objs_list(cfgObjs' 'commonObjs,libs,_ProjectGet_PreObjectLibs(projectHandle, configName));

      // if no outdir is specified, default to a dir of the same name as the configuration
      // and make sure it ends with a filesep
      outdir := prepareCommand(projectName, makefileFormat, "%bd", "outdir", "", "", replaceEnvVars);
      if (outdir == "") {
         outdir = configName;
      }

      // make outdir relative to project
      outdir = _RelativeToProject(outdir, projectName);
      outdir = strip(outdir, "T", FILESEP);
      outdir = strip(outdir, "T", FILESEP2);

      // fix fileseps on variables that contain files
      outputFile = fixFileSeps(outputFile, makefileFormat);
      includes = fixFileSeps(includes, makefileFormat);
      libs = fixFileSeps(libs, makefileFormat);
      fullObjectList = fixFileSeps(fullObjectList, makefileFormat);
      outdir = fixFileSeps(outdir, makefileFormat);

      // check outdir for spaces
      if (pos(" ", outdir)) {
         warnAboutPaths = true;
      }

      // add commands
      insert_line("OUTDIR=" outdir);
      insert_line("OUTFILE=" makeCommandCLSafe(outputFile));
      splitAndInsertValueList("CFG_INC", makeCommandCLSafe(includes));
      splitAndInsertValueList("CFG_LIB", makeCommandCLSafe(libs));
      splitAndInsertValueList("CFG_OBJ", makeCommandCLSafe(cfgObjs));
      splitAndInsertValueList("COMMON_OBJ", makeCommandCLSafe(commonObjs));
      insert_line("OBJ=$(COMMON_OBJ) $(CFG_OBJ)");
      splitAndInsertValueList("ALL_OBJ", makeCommandCLSafe(fullObjectList));
      if (dep_libs != "") {
         splitAndInsertValueList("DEP_LIB", makeCommandCLSafe(dep_libs));
      }

      // only add these if there are non-linkable objects
      if (hasNLObjects) {
         splitAndInsertValueList("CFG_OBJ_NL", makeCommandCLSafe(nlCfgObjs));
         splitAndInsertValueList("COMMON_OBJ_NL", makeCommandCLSafe(nlCommonObjs));
         insert_line("OBJ_NL=$(COMMON_OBJ_NL) $(CFG_OBJ_NL)");
      }

      // get the commands and modify them for use in the makefile
      insert_line("");

      // add compile target from <Menu> container (this was parsed earlier)
      insert_line(compileToolLine);

      // find the link command
      linkTargetNode := _ProjectGet_TargetNode(projectHandle, "link", configName);
      if (linkTargetNode >= 0) {
         cmdLine   := _ProjectGet_TargetCmdLine(projectHandle, linkTargetNode);
         otherOpts := _ProjectGet_TargetOtherOptions(projectHandle, linkTargetNode);

         cmdLine = prepareCommand(projectName, makefileFormat, cmdLine, "link", "", otherOpts, replaceEnvVars);
         insert_line("LINK=" makeCommandCLSafe(cmdLine));
      }

      // add rules from <Rules> container (these were parsed earlier)
      for (r := 0; r < compileToolArray._length(); r++) {
         ruleName := compileToolArray[r].variableName;

         // if this is the default COMPILE rule, skip it because it was already added
         if (strieq(ruleName, "COMPILE")) continue;

         // if this is the same name as the previous rule, skip it
         if (r > 0 && strieq(ruleName, compileToolArray[r - 1].variableName)) continue;

         insert_line(compileToolArray[r].variableName "=" makeCommandCLSafe(compileToolArray[r].cmdLine));
      }

      // determine which dependency set to use.  'build' is the default if not specified
      buildTargetNode := _ProjectGet_TargetNode(projectHandle, "build", configName);
      dependsRef := _ProjectGet_TargetDependsRef(projectHandle, buildTargetNode);
      if (dependsRef == "") {
         dependsRef = "build";
      }

      // get list of dependency nodes for this configuration
      int dependencyNodeArray[] = null;
      _ProjectGet_DependencyProjectNodesForRef(projectHandle, configName, dependsRef, dependencyNodeArray);
      hasDependencies := (dependencyNodeArray._length() > 0);

      //for (d := 0; d < dependencyNodeArray._length(); d++) {
      //   say("dep(" d "): " _xmlcfg_get_attribute(projectHandle, dependencyNodeArray[d], "Project") \
      //       "  -  " _xmlcfg_get_attribute(projectHandle, dependencyNodeArray[d], "Config"));
      //}

      // add pattern rules
      insert_line("");
      if (!sourcedirHash._isempty()) {
         insert_line("# Pattern rules");

         foreach ( auto compileTool in compileToolInputHash ) {

            // if this extension has ignore set to true, skip it
            if (compileTool.ignore) {
               continue;
            }

            foreach (auto sourceDir => . in sourcedirHash) {
               //say("generate_makefile_type H"__LINE__": n="sourceDir);
               // make sure fileseps are proper
               fixedSourceDir := fixFileSeps(sourceDir, makefileFormat);
               switch(makefileFormat) {
                  case MAKEFILE_FORMAT_GNUMAKE:
                     insert_line("$(OUTDIR)" getFileSep(makefileFormat) "%" compileTool.outputExt " : " fixedSourceDir "%" compileTool.inputExt);
                     break;

                  case MAKEFILE_FORMAT_NMAKE:
                     insert_line("{" fixedSourceDir "}" compileTool.inputExt "{$(OUTDIR)}" compileTool.outputExt " :");
                     break;
               }
               insert_line("\t$(" compileTool.variableName ")");
               insert_line("");

            }

            // check to see if the input to this rule couldve come from another rule
            // NOTE: this is done by checking compileToolOutputHash to see if the input
            //       ext to this rule can be generated by another rule
            COMPILE_TOOL_INFO* chainedToolInfoPtr = compileToolOutputHash._indexin(compileTool.inputExt);
            if (chainedToolInfoPtr) {
               // input to this rule might be chained so must add pattern
               //    $(OUTDIR)/%.outputext : $(OUTDIR)/%.inputext
               // to handle output from previous compiles that is in outdir
               switch(makefileFormat) {
                  case MAKEFILE_FORMAT_GNUMAKE:
                     insert_line("$(OUTDIR)" getFileSep(makefileFormat) "%" compileTool.outputExt " : $(OUTDIR)" getFileSep(makefileFormat) "%" compileTool.inputExt);
                     break;

                  case MAKEFILE_FORMAT_NMAKE:
                     insert_line("{$(OUTDIR)}" compileTool.inputExt "{$(OUTDIR)}" compileTool.outputExt " :");
                     break;
               }
               insert_line("\t$(" compileTool.variableName ")");
               insert_line("");
            }
         }
      }

      // check for pre and post build commands
      preBuildCmds  := _ProjectGet_PreBuildCommandsList(projectHandle, configName);
      postBuildCmds := _ProjectGet_PostBuildCommandsList(projectHandle, configName);

      // add the compiling rules
      insert_line("# Build rules");

      // add standard 'all' rule
      allRule := "all:";
      if (preBuildCmds != "") {
         allRule :+= " prebuildcmds";
      }
      allRule :+= " $(OUTFILE)";
      insert_line(allRule);
      insert_line("");

      // add pre build commands
      if (preBuildCmds != "") {
         insert_line("prebuildcmds:");
         insertCommandList(projectName, preBuildCmds, makefileFormat, "prebuild",
                           strieq(_ProjectGet_StopOnPreBuildError(projectHandle, configName), "1"));
         insert_line("");
      }

      // add output file rule (modifying the rule as appropriate if dependencies are present)
      depsString := "";
      if (hasDependencies) {
         depsString :+= " deps";
      }
      if (hasNLObjects) {
         depsString :+= " $(OBJ_NL)";
      }
      if (dep_libs != "") {
         depsString :+= " $(DEP_LIB)";
      }
      insert_line("$(OUTFILE): $(OUTDIR)" depsString " $(OBJ)");

      //insert_line("\t@echo \"Building config: $(CFG)\"");
      insert_line("\t$(LINK)");

      // add post build commands under the link command so that they will only be
      // run if a link is required
      if (postBuildCmds != "") {
         insertCommandList(projectName, postBuildCmds, makefileFormat, "postbuild",
                           strieq(_ProjectGet_StopOnPostBuildError(projectHandle, configName), "1"));
      }

      // add outdir rule
      insert_line("");
      insert_line("$(OUTDIR):");
      switch(makefileFormat) {
         case MAKEFILE_FORMAT_GNUMAKE:
            insert_line("\t$(MKDIR) -p \"$(OUTDIR)\"");
            break;

         case MAKEFILE_FORMAT_NMAKE:
            insert_line("\tif not exist \"$(OUTDIR)" getFileSep(makefileFormat) "$(NULL)\" $(MKDIR) \"$(OUTDIR)\"");
            break;
      }

      // if there are dependencies, setup a rule to build them
      if (hasDependencies) {
         insert_line("");
         insert_line("# Build dependencies");
         insert_line("deps:");

         // each dep command should be of the form (cd ../sub1/sub2;$(MAKE) -f blah.mak CFG=$(CFG))
         // NOTE: these commands are within parens to force them to be shelled on UNIX, therefore
         //       eliminating the need to change back to the current dir at the end of the build
         foreach (auto dependencyNode in dependencyNodeArray) {
            if (dependencyNode < 0) continue;

            dependencyProject := _xmlcfg_get_attribute(projectHandle, dependencyNode, "Project");
            dependencyConfig  := _xmlcfg_get_attribute(projectHandle, dependencyNode, "Config", "$(CFG)");
            if (dependencyProject == "") continue;
            dependencyProject = fixFileSeps(dependencyProject, makefileFormat);
            //say("dep: " dependencyProject "  depConfig: " dependencyConfig);

            // get the directory where the project lives as well as the makefile for the project
            dependencyDir := _strip_filename(dependencyProject, "N");
            if (dependencyDir == "") {
               dependencyDir = ".";
            }
            //say("depDir: " dependencyDir);

            // resolve symlinks if on UNIX
            if (_isUnix() && def_resolve_dependency_symlinks) {
               // absolute the directory to the project
               dependencyDir = _AbsoluteToProject(dependencyDir);

               // try to resolve symlinks in the project path
               resolvedProject := absolute(_project_name, null, true);
               if (resolvedProject != "") {
                  dependencyDir = _RelativeToProject(dependencyDir, resolvedProject);
               }
               if (dependencyDir == "") {
                  dependencyDir = ".";
               }
               //say("resolvedDepDir: " dependencyDir);
            }

            // get the dependency makefile name from the dependency project
            absoluteDependency := _AbsoluteToProject(dependencyProject, projectName);
            dependencyHandle := _ProjectHandle(absoluteDependency);
            if (dependencyHandle < 0) continue;
            dependencyMakefile := _ProjectGet_BuildMakeFile(dependencyHandle);

            // make sure that dependencyMakefile is valid
            if (dependencyMakefile == "") {
               dependencyMakefile = _strip_filename(dependencyProject, "PE") MAKEFILE_EXTENSION;
            } else {
               dependencyMakefile = _parse_project_command(dependencyMakefile, '', absoluteDependency,"");
               dependencyMakefile = _RelativeToProject(dependencyMakefile, absoluteDependency);
            }

            // add commands to change to this directory and build this dependency
            switch(makefileFormat) {
               case MAKEFILE_FORMAT_GNUMAKE:
                  insert_line("\t@(cd " dependencyDir ";$(MAKE) -f " dependencyMakefile " CFG=" dependencyConfig ")");
                  break;

               case MAKEFILE_FORMAT_NMAKE:
                  dependencyDrive := "";
                  if (substr(dependencyDir, 2, 1) == ":") {
                     // the dependency dir is an absolute filename which means it is most likely on
                     // a different drive than the current project, so add the drive: to the command
                     dependencyDrive = substr(dependencyDir, 1, 2);

                     // add the & so the drive change command can be added into the string of commands
                     // to be executed
                     dependencyDrive :+= " & ";
                  }

                  //say("depDir: \"" dependencyDir "\" cwd=\"" getcwd() "\" drv=\"" dependencyDrive "\"");
                  insert_line("\t@(" dependencyDrive "cd " dependencyDir " & $(MAKE) -f " dependencyMakefile " CFG=" dependencyConfig ")");
                  break;
            }
         }
      }

      // add rebuild rule
      insert_line("");
      insert_line("# Rebuild this project");
      switch(makefileFormat) {
         case MAKEFILE_FORMAT_GNUMAKE:
            // calling make recursively is the only way to insure ordering of clean and all
            insert_line("rebuild: cleanall");
            insert_line("\t@$(MAKE) -f \"$(strip $(MAKEFILE_LIST))\" $(MAKEFLAGS) all");
            break;
         case MAKEFILE_FORMAT_NMAKE:
            insert_line("rebuild: cleanall all");
            break;
      }

      // add cleaning rules
      insert_line("");
      insert_line("# Clean this project");
      insert_line("clean:");
      switch(makefileFormat) {
         case MAKEFILE_FORMAT_GNUMAKE:
            insert_line("\t$(RM) -f $(OUTFILE)");
            insert_line("\t$(RM) -f $(OBJ)");
            if (hasNLObjects) {
               insert_line("\t$(RM) -f $(OBJ_NL)");
            }
            break;

         case MAKEFILE_FORMAT_NMAKE:
            insert_line("\t$(RM) /q $(OUTFILE)");
            insert_line("\t$(RM) /q $(OBJ)");
            if (hasNLObjects) {
               insert_line("\t$(RM) /q $(OBJ_NL)");
            }
            break;
      }

      insert_line("");
      insert_line("# Clean this project and all dependencies");
      insert_line("cleanall: clean");
      if (hasDependencies) {
         // each dep command should be of the form (cd ../sub1/sub2;$(MAKE) -f blah.mak clean CFG=$(CFG))
         // NOTE: these commands are within parens to force them to be shelled, therefore
         //       eliminating the need to change back to the current dir at the end of the build
         foreach (auto dependencyNode in dependencyNodeArray) {
            if (dependencyNode < 0) continue;

            dependencyProject := _xmlcfg_get_attribute(projectHandle, dependencyNode, "Project");
            dependencyConfig  := _xmlcfg_get_attribute(projectHandle, dependencyNode, "Config", "$(CFG)");
            if (dependencyProject == "") continue;
            dependencyProject = fixFileSeps(dependencyProject, makefileFormat);

            // get the directory where the project lives as well as the makefile for the project
            dependencyDir := _strip_filename(dependencyProject, "N");
            if (dependencyDir == "") {
               dependencyDir = ".";
            }

            // resolve symlinks if on UNIX
            if (_isUnix() && def_resolve_dependency_symlinks) {
               // absolute the directory to the project
               dependencyDir = _AbsoluteToProject(dependencyDir);

               // try to resolve symlinks in the project path
               resolvedProject := absolute(_project_name, null, true);
               if (resolvedProject != "") {
                  dependencyDir = _RelativeToProject(dependencyDir, resolvedProject);
               }
               if (dependencyDir == "") {
                  dependencyDir = ".";
               }
            }

            // get the dependency makefile name from the dependency project
            absoluteDependency := _AbsoluteToProject(dependencyProject, projectName);
            dependencyHandle := _ProjectHandle(absoluteDependency);
            if (dependencyHandle < 0) continue;
            dependencyMakefile := _ProjectGet_BuildMakeFile(dependencyHandle);

            // make sure that dependencyMakefile is valid
            if (dependencyMakefile == "") {
               dependencyMakefile = _strip_filename(dependencyProject, "PE") MAKEFILE_EXTENSION;
            } else {
               dependencyMakefile = _parse_project_command(dependencyMakefile, '', absoluteDependency,"");
               dependencyMakefile = _RelativeToProject(dependencyMakefile, absoluteDependency);
            }

            // add commands to change to this directory and clean it
            switch(makefileFormat) {
               case MAKEFILE_FORMAT_GNUMAKE:
                  insert_line("\t@(cd " dependencyDir ";$(MAKE) -f " dependencyMakefile " cleanall CFG=" dependencyConfig ")");
                  break;

               case MAKEFILE_FORMAT_NMAKE:
                  dependencyDrive := "";
                  if (substr(dependencyDir, 2, 1) == ":") {
                     // the dependency dir is an absolute filename which means it is most likely on
                     // a different drive than the current project, so add the drive: to the command
                     dependencyDrive = substr(dependencyDir, 1, 2);

                     // add the & so the drive change command can be added into the string of commands
                     // to be executed
                     dependencyDrive :+= " & ";
                  }

                  insert_line("\t@(" dependencyDrive "cd " dependencyDir " & $(MAKE) -f " dependencyMakefile " cleanall CFG=" dependencyConfig ")");
                  break;
            }
         }
      }

      // close conditional
      if (configList._length() > 1) {
         switch(makefileFormat) {
            case MAKEFILE_FORMAT_GNUMAKE:
               insert_line("endif");
               break;

            case MAKEFILE_FORMAT_NMAKE:
               insert_line("!endif");
               break;
         }
      }
   }

   // generate #include dependencies (configurations do not matter here)
   include_index := find_index("vsc_list_includes", PROC_TYPE);
   if (def_projmake_makedepend && index_callable(include_index)) {
      insert_line("");
      insert_line("#");
      insert_line("# include dependencies:");
      insert_line("#");
      projectDir  := _strip_filename(projectName, 'NE');
      makefileDir := _strip_filename(makefileName, 'NE');
      _str dependenciesForSourceFiles:[][];
      _str dependenciesForHeaderFiles:[];
      bool been_there_done_that:[];
      foreach (auto sourcefile in sourcefileArray) {
         if (been_there_done_that._indexin(_file_case(sourcefile))) {
            continue;
         }
         _str sourceFileIncludes[] = null;
         absSourceFile := absolute(sourcefile, projectDir);
         if (been_there_done_that._indexin(_file_case(absSourceFile))) {
            continue;
         }
         been_there_done_that:[_file_case(sourcefile)] = true;
         been_there_done_that:[_file_case(absSourceFile)] = true;
         if (file_exists(absSourceFile)) {
            status = call_index(absSourceFile, sourceFileIncludes, include_index);
         }

         fileDir := _strip_filename(absSourceFile, 'NE');
         _str includeDependencies[];
         foreach (auto includeFile in sourceFileIncludes) {
            // check if the header is relative to the actual source file
            if (file_exists(fileDir:+includeFile)) {
               absIncludeFile := absolute(fileDir:+includeFile);
               relIncludeFile := relative(absIncludeFile, makefileDir);
               relIncludeFile = fixFileSeps(relIncludeFile, makefileFormat);
               includeDependencies :+= relIncludeFile;
            } else {
               // check the include path
               foreach (auto includeDir in absIncludeDirsArray) {
                  if (file_exists(includeDir:+includeFile)) {
                     absIncludeFile := absolute(includeDir:+includeFile);
                     relIncludeFile := relative(absIncludeFile, makefileDir);
                     relIncludeFile = fixFileSeps(relIncludeFile, makefileFormat);
                     includeDependencies :+= relIncludeFile;
                  }
               }
            }

            wildcardExtension := ";*":+_get_extension(sourcefile)";";
            relSourceFile := relative(absSourceFile, makefileDir);
            relSourceFile = fixFileSeps(relSourceFile, makefileFormat);
            dependenciesForSourceFiles:[_file_case(relSourceFile)] = includeDependencies;
         }
      }

      been_there_done_that._makeempty();
      foreach (sourcefile in sourcefileArray) {
         extension := _get_extension(sourcefile);
         wildcardExtension := ";*.":+extension";";
         if (pos(wildcardExtension, HEADER_EXTENSION_LIST)) {
            continue;
         }
         if (been_there_done_that._indexin(_file_case(sourcefile))) {
            continue;
         }
         absSourceFile := absolute(sourcefile, projectDir);
         if (been_there_done_that._indexin(_file_case(absSourceFile))) {
            continue;
         }
         been_there_done_that:[_file_case(sourcefile)] = true;
         been_there_done_that:[_file_case(absSourceFile)] = true;

         //
         outputExt := ".o";
         if (compileToolInputHash._indexin(extension)) {
            outputExt =  compileToolInputHash:[extension].outputExt;
         } else if ( makefileFormat == MAKEFILE_FORMAT_NMAKE) {
            outputExt = ".obj";
         }

         // if we found any dependencies for this source file, then add it
         bool foundHeaderFiles:[];
         relSourceFile := relative(absSourceFile, makefileDir);
         relSourceFile = fixFileSeps(relSourceFile, makefileFormat);
         relObjectFile := _strip_filename(relSourceFile, 'PE'):+outputExt;
         includeDependencies := getRecursiveDependenciesForSourceFile(relSourceFile,dependenciesForSourceFiles,dependenciesForHeaderFiles,foundHeaderFiles);
         insert_line("$(OUTDIR)":+getFileSep(makefileFormat):+relObjectFile:+": ":+relSourceFile:+" ":+includeDependencies);
      }

   }

   // restore original active config
   project_config_set_active(_maybe_quote_filename(activeConfig), projectName, true);

   // save the makefile
   status = _save_file(build_save_options(p_buf_name) " -E");

   // clean up the temp view
   p_window_id = origViewID;
   _delete_temp_view(tempViewID);

   // open the makefile
   if (openAfterGen) {
      edit(_maybe_quote_filename(makefileName));
   }

   // restore the original view since the edit command will trash it
   p_window_id = origViewID;

   // warn that paths with spaces were encountered if this is a GNU makefile
   if (warnAboutPaths && !quiet) {
      switch(makefileFormat) {
         case MAKEFILE_FORMAT_GNUMAKE:
            _message_box("Some paths or configuration names in this makefile contain spaces which may cause problems during a build.");
            break;

         case MAKEFILE_FORMAT_NMAKE:
         default:
            break;
      }
   }

   return status;
}

/**
 * Prepare a command for use in a makefile.  This will replace
 * all %variables with its counterpart in the makefile.
 *
 * @param command  Command to be prepared
 *
 * @return The prepared command
 */
static _str prepareCommand(_str projectName, int makefileFormat, _str command, _str which,
                           _str compileExt, _str otherOpts, bool replaceEnvVars,_str outputExt="")
{
   _str preparedCmd = command;

   // replace all environment variables %(varname)
   if (replaceEnvVars) {
      preparedCmd = _parse_env_vars(preparedCmd);
   } else {
      preparedCmd = reformatEnvVars(preparedCmd);
   }

   // replace %variables that will have corresponding variables in the
   // makefile.  order of the replacement is important.  the replacements
   // may be different for compile and link commands.
   //    compile:
   //       %bd -> $(OUTDIR) FILESEP
   //       %ir -> $(INC)
   //       %i  -> $(INC)
   //       %f  -> $<
   //       %n  -> $*
   //    link:
   //       %bd -> $(OUTDIR) FILESEP
   //       %ir -> $(INC)
   //       %i  -> $(INC)
   //       %f  -> $(OBJ)
   //       %n  ->
   //    outdir:
   //       %bd *MUST* pass thru to be determined properly
   //say("prepare(" which "): " preparedCmd);
   switch(which) {
      case "compile":
         //preparedCmd = stranslate(preparedCmd, "$*", "%bd%n", "I");
         preparedCmd = stranslate(preparedCmd, "$(OUTDIR)" getFileSep(makefileFormat), "%bd", "I");
         preparedCmd = stranslate(preparedCmd, "$(CFG_INC)", "%ir", "I");
         preparedCmd = stranslate(preparedCmd, "$(CFG_INC)", "%i", "I");
         preparedCmd = stranslate(preparedCmd, "$(CFG_LIB)", "%libs", "I");
         preparedCmd = stranslate(preparedCmd, "$(ALL_OBJ)", "%objs", "I");
         preparedCmd = stranslate(preparedCmd, "$<", "%f", "I");
         preparedCmd = stranslate(preparedCmd, "$(*F)", "%n", "I");
         preparedCmd = stranslate(preparedCmd, "$(*D)", "%p", "I");
         preparedCmd = stranslate(preparedCmd, otherOpts, "%~other", "I");

         // special cases
         preparedCmd = stranslate(preparedCmd, "$<", "@?\"?%[Ll][Ff]\"?", "U"); // [@]["]%lf["]
         preparedCmd = stranslate(preparedCmd, '$(OUTFILE)', '%[Oo](?![npe])', "L"); // %o but not %on, %op, or %oe
         break;

      case "link":
         preparedCmd = stranslate(preparedCmd, "$(OUTDIR)" getFileSep(makefileFormat), "%bd", "I");
         preparedCmd = stranslate(preparedCmd, "$(CFG_INC)", "%ir", "I");
         preparedCmd = stranslate(preparedCmd, "$(CFG_INC)", "%i", "I");
         preparedCmd = stranslate(preparedCmd, "$(CFG_LIB)", "%libs", "I");
         preparedCmd = stranslate(preparedCmd, "$(ALL_OBJ)", "%objs", "I");
         preparedCmd = stranslate(preparedCmd, "$(OBJ)", "%f", "I");
         preparedCmd = stranslate(preparedCmd, otherOpts, "%~other", "I");

         // special cases
         preparedCmd = stranslate(preparedCmd, "$(OBJ)", "@?\"?%[Ll][Ff]\"?", "U"); // [@]["]%lf["]
         preparedCmd = stranslate(preparedCmd, '$(OUTFILE)', '%[Oo](?![npe])', "L"); // %o but not %on, %op, or %oe
         break;

      case "outdir":
      case "includes":
      case "libs":
         // this is here to force %bd, %i, %ir, %libs to be passed thru to _parse_project_command
         // and be resolved.  these are called when actually setting $(OUTDIR) $(OUTFILE)
         // $(CFG_INC) $(CFG_LIB)
         break;

      default:
         preparedCmd = stranslate(preparedCmd, "$(OUTDIR)" getFileSep(makefileFormat), "%bd", "I");
         preparedCmd = stranslate(preparedCmd, "$(CFG_INC)", "%ir", "I");
         preparedCmd = stranslate(preparedCmd, "$(CFG_INC)", "%i", "I");
         preparedCmd = stranslate(preparedCmd, "$(CFG_LIB)", "%libs", "I");
         preparedCmd = stranslate(preparedCmd, "$(ALL_OBJ)", "%objs", "I");

         // special cases
         preparedCmd = stranslate(preparedCmd, '$(OUTFILE)', '%[Oo](?![npe])', "L"); // %o but not %on, %op, or %oe
         break;
   }

   // run parse_project_command to ensure there are no more %variables left
   preparedCmd = _parse_project_command(preparedCmd, compileExt, projectName, "", "", "", "", null, null, 0, '', outputExt);

   // convert all platform fileseps to the proper type expected by the make program
   //preparedCmd = fixFileSeps(preparedCmd, makefileFormat);

   //say("prepared: " preparedCmd);
   return preparedCmd;
}

/**
 * Change all envvars from %(ENVNAME) to $(ENVNAME) syntax
 *
 * @param command
 *
 * @return
 */
static _str reformatEnvVars(_str command)
{
   _str cmd = command;

   offset := 1;
   for (;;) {
      offset = pos("%(\\(.+\\))", cmd, offset, "U");
      if (offset == 0) break;

      // replace the entry
      cmd = substr(cmd, 1, offset - 1) "$" substr(cmd, pos("S1"), pos("1")) :+ substr(cmd, offset + pos(""));
   }

   return cmd;
}

/**
 * Build a list of all objects used in the specified configuration.
 * If config is not specified, the objects common to all configs are
 * returned.
 *
 * @param projectInfo
 * @param config
 *
 * @return List of objects
 */
static int getObjectList(int projectHandle, 
                         int makefileFormat, 
                         bool (&sourcedirHash):[],
                         _str (&sourcefileArray)[],
                         COMPILE_TOOL_INFO (&compileToolHash):[], 
                         _str configName,
                         _str& linkObjectList, 
                         _str& noLinkObjectList,
                         bool& pathsContainedSpaces, 
                         bool returnCommon = false)
{
   status := 0;
   linkObjectList = "";
   noLinkObjectList = "";
   projectName := _xmlcfg_get_filename(projectHandle);
   typeless objectList[] = null;

   // if common files requested, build array of all files with no config attribute
   // or an empty config attribute
   if (returnCommon) {
      status = _xmlcfg_find_simple_array(projectHandle, "/Project/Files//F[not(@C)]", objectList);
      if (status) return status;
      status = _xmlcfg_find_simple_array(projectHandle, "/Project/Files//F[@C='']", objectList,
                                TREE_ROOT_INDEX, VSXMLCFG_FIND_APPEND);
      if (status) return status;
   } else {
      status = _xmlcfg_find_simple_array(projectHandle, "/Project/Files//F[contains(@C,'\"" configName "\"','I')]", objectList);
      if (status) return status;
   }

   // walk the list of files, building the object name
   foreach ( auto fileNode in objectList ) {
      line := _xmlcfg_get_attribute(projectHandle, fileNode, "N");
      line = fixFileSeps(line, makefileFormat);

      // translate the line in case the filename contained any placeholders
      // NOTE: only environment variables are likely here
      line = prepareCommand(projectName, makefileFormat, line, "filename", "", "", false);

      extension := _get_extension(line, true);
      wildcardExtension := ";*" extension ";";
      filename := _strip_filename(line, "PE");
      relativePath := relative(_strip_filename(line, "N"), _strip_filename(projectName, "N"));

      // is the a C/C++ header file?  We want it in the source file list then
      if (pos(wildcardExtension, HEADER_EXTENSION_LIST)) {
         sourcefileArray :+= line;
      } else if (pos(wildcardExtension, SOURCE_EXTENSION_LIST)) {
         sourcefileArray :+= line;
      }

      // look for a compile rule that applies to the source file
      COMPILE_TOOL_INFO toolInfo;
      toolInfo.cmdLine = "";
      toolInfo.variableName = "";
      toolInfo.inputExt = extension;
      toolInfo.outputExt = "";
      toolInfo.linkObject = true;
      toolInfo.chainedOutputExt = "";
      toolInfo.chainedLinkObject = true;
      toolInfo.ignore = false;

      COMPILE_TOOL_INFO* storedToolInfoPtr = compileToolHash._indexin(extension);
      if (storedToolInfoPtr) {
         // copy the information from the pointer
         toolInfo = *storedToolInfoPtr;

         // check for ignored type
         if (toolInfo.ignore) {
            continue;
         }
      } else {
         // not found so check to see if objects with this extension are linkable
         copts := "";
         outputExt := "";
         linkObject := true;
         compileRuleTargetNode := 0;

         // NOTE: this case is probably not used anymore, but it is being left for
         //       safety.  since compile rules are now parsed and entered into the
         //       compileToolHash before this function gets called, the if statement
         //       above should never fail when dealing with a file that will be
         //       compiled using a rule.  this leaves only files that will be compiled
         //       using the default rule to fall thru to this case, which will always
         //       cause this getExtSpecificCompileInfo() call to fail
         if (getExtSpecificCompileInfo(extension, projectHandle, configName, "", outputExt, compileRuleTargetNode, linkObject, false) == 0) {
            // remove the wildcard
            _maybe_strip(outputExt, '*', stripFromFront:true);

            // store the tool info in the hash table
            toolInfo.outputExt = outputExt;
            toolInfo.linkObject = linkObject;
            if (toolInfo.variableName == "") {
               // no variable name defined, so use the default
               toolInfo.variableName = "COMPILE";
            }
            compileToolHash:[extension] = toolInfo;

         } else {
            // if there is no extension specific compile tool, 
            // check to see if this file has a standard source extension
            if (pos(wildcardExtension, SOURCE_EXTENSION_LIST)) {
               // if this point is reached, the default compile command will be used for this
               // file, so check it for output extension
               compileRuleTargetNode=0;
               getExtSpecificCompileInfo(extension, projectHandle, configName, "", outputExt, compileRuleTargetNode, linkObject, true);

               // remove the wildcard
               _maybe_strip(outputExt, '*', stripFromFront:true);

               // if there is no output extension, use the default
               if (outputExt == "") {
                  switch(makefileFormat) {
                     case MAKEFILE_FORMAT_GNUMAKE:
                        outputExt = ".o";
                        break;

                     case MAKEFILE_FORMAT_NMAKE:
                        outputExt = ".obj";
                        break;
                  }
               }

               // store the tool info in the hash table
               toolInfo.outputExt = outputExt;
               toolInfo.linkObject = linkObject;
               if (toolInfo.variableName == "") {
                  // no variable name defined, so use the default
                  toolInfo.variableName = "COMPILE";
               }
               compileToolHash:[extension] = toolInfo;

            } else {
               // not a source file so store its extension in the table as ignored type
               toolInfo.outputExt = extension;
               toolInfo.ignore = true;
               compileToolHash:[extension] = toolInfo;
               continue;
            }
         }
      }

      // iterate until a compile rule is found that does not generate an extension
      // that is then chained into another rule
      //
      // NOTE: this is necessary because for make to properly chain rules, the
      //       object name needs to have the absolute final extension that it
      //       would have after all rules have been applied
      if (toolInfo.chainedOutputExt == "") {
         toolInfo.chainedOutputExt = toolInfo.outputExt;
         toolInfo.chainedLinkObject = toolInfo.linkObject;
      }
      for (;;) {
         chainedOutputExt := "";
         chainedLinkObject := true;
         chainedCompileRuleTargetNode := 0;
         if (getExtSpecificCompileInfo(toolInfo.chainedOutputExt, projectHandle, configName, "", chainedOutputExt, chainedCompileRuleTargetNode, chainedLinkObject, false) == 0) {
            // remove the wildcard
            _maybe_strip(chainedOutputExt, '*', stripFromFront:true);

            // make sure the rule is not chaining itself recursively
            if (strieq(toolInfo.chainedOutputExt, chainedOutputExt)) break;

            toolInfo.chainedOutputExt = chainedOutputExt;
            toolInfo.chainedLinkObject = chainedLinkObject;
            continue;
         }

         break;
      }

      // generate the object name for the file and add it to the appropriate object list
      // based on whether it is linkable or not
      filename = "$(OUTDIR)" getFileSep(makefileFormat) filename toolInfo.chainedOutputExt;
      if (toolInfo.chainedLinkObject) {
         // add it to the link object list
         if (linkObjectList == "") {
            linkObjectList = filename;
         } else {
            linkObjectList :+= " " filename;
         }
      } else {
         // add it to the nolink object list
         if (noLinkObjectList == "") {
            noLinkObjectList = filename;
         } else {
            noLinkObjectList :+= " " filename;
         }
      }

      // save the relative path for building compile rules
      sourcedirHash:[relativePath] = true;

      // check for spaces
      if (pos(" ", relativePath) > 0) {
         pathsContainedSpaces = true;
      }
   }

   return status;
}

/**
 * Enter the value into the current view, splitting the list up
 * so that no value begins after column 70.  The values are
 * space delimited.
 *
 * <br>NOTE: A value will not be split across multiple lines so it
 *       may extend past column 70.
 *
 * @param name
 * @param valueList
 */
static void splitAndInsertValueList(_str name, _str valueList)
{
   line :=  name "=";
   firstIteration := true;
   _str value = parseNextValue(valueList);
   while(value != "") {
      // if the line is over 70 chars (70 instead of 75 to allow room for expanded tab), insert
      // it with a line-continuation character
      if (length(line) + length(value) >= 70 && !firstIteration) {
         insert_line(line "\\");
         line = "\t";
      }

      // we need to monitor whether it is the first iteration or not to avoid outputting
      // NAME=\ on the first line if the first value is very long.  it should output
      // NAME=VALUE1 no matter how long the first value is
      firstIteration = false;

      // add the value to the line
      line :+= value " ";

      // get next value
      value = parseNextValue(valueList);
   }

   // add the last line if there is anything there
   if (line != "") {
      insert_line(line);
   }
}

/**
 * Parse a list of values and return the sub-list which are actual 
 * files that exist on disk. 
 *  
 * @param valueList
 */
static _str getExistingFilesFromList(_str valueList)
{
   existingFiles := "";
   value := parseNextValue(valueList);
   while (value != "") {
      // add the value to the line
      value = _maybe_unquote_filename(value);
      if (is_object_file(value) || file_exists(value)) {
         existingFiles :+= value " ";
      }
      // get next value
      value = parseNextValue(valueList);
   }
   // return the list of files that exist on disk
   return existingFiles;
}

/**
 * Get filesep for the specified type of makefile
 *
 * @param makefileFormat
 *
 * @return Filesep for specified type of makefile
 */
static _str getFileSep(int makefileFormat)
{
   switch(makefileFormat) {
      case MAKEFILE_FORMAT_GNUMAKE:
         return MAKEFILE_FILESEP_GNUMAKE;

      case MAKEFILE_FORMAT_NMAKE:
         return MAKEFILE_FILESEP_NMAKE;
   }

   // default to just returning the platform specific filesep
   return FILESEP;
}

/**
 * Translate fileseps in the given line to the appropriate
 * ones for the specified platform
 *
 * @param line   Line to translate
 * @param makefileFormat
 *
 * @return Translated line
 */
static _str fixFileSeps(_str line, int makefileFormat)
{
   line = stranslate(line, getFileSep(makefileFormat), FILESEP);
   line = stranslate(line, getFileSep(makefileFormat), FILESEP2);
   return line;
}

/**
 * Return the first value in the line.  Quoted parameters are
 * supported.  This is very similar to parse_file.  The difference
 * is this supports quoted values that have other text prefixing
 * them.  One common example of this occurs when dealing with
 * compilers:
 *
 * -I"C:\Program Files\Subdir1" -I"C:\Program Files\Subdir2"
 *
 * @param line
 *
 * @return
 */
static _str parseNextValue(_str& line)
{
   option := "";
   line = strip(line, "B");
   i := 1;
   for (i = 1; i <= length(line); i++) {
      ch := substr(line, i, 1);
      if (ch == " ") break;

      // check for quoted parameter
      if (ch == "\"") {
         endQuote := pos(ch, line, i + 1);

         // if no endquote found, assume rest of line is quoted
         if (endQuote == 0) {
            endQuote = length(line);
         }

         option :+= substr(line, i, endQuote - i + 1);

         // move index past quoted value
         i = endQuote;
      } else {
         option :+= ch;
      }
   }

   // remove the option from the line
   line = strip(substr(line, i), "B");

   return option;
}

/**
 * Do a path search for 'gmake'.  Default to 'make' if not found.
 *
 * @return
 */
_str _findGNUMake()
{
   _str makeProgram = path_search("gmake");
   if (makeProgram != "") {
      return "gmake";
   }

   return "make";
}

/**
 * Parse and insert the commands from the ASCII 1 delimited list
 * into the current view
 *
 * @param projectName
 *               Project name
 * @param commandList
 *               ASCII 1 delimited list of commands
 * @param makefileFormat
 * @param which  Which set of commands is being processed (ex: prebuild, postbuild)
 * @param stopOnError
 *               Determines whether the commands are prefixed with a hyphen '-' to
 *               tell make to ignore their return code
 *
 * @return 0 on success, <0 otherwise
 */
static int insertCommandList(_str projectName, _str commandList, int makefileFormat, _str which,
                             bool stopOnError)
{
   // make sure the command list ends with the delimiter
   // NOTE: this is done to make parsing easier by removing the border case
   //       that the last command presents
   _maybe_append(commandList, "\1");

   for (;;) {
      command := "";
      parse commandList with command "\1" commandList;
      if (command == "") break;

      // parse the command
      _str parsedCommand = prepareCommand(projectName, makefileFormat, command, which, "", "", false);

      // add the command to the makefile
      if (command != "") {
         if (stopOnError) {
            insert_line("\t" makeCommandCLSafe(parsedCommand));
         } else {
            insert_line("\t-" makeCommandCLSafe(parsedCommand));
         }
      }
   }

   return 0;
}

/**
 * Returns 'true' if the given file is an object file or library.
 *  
 * @param filename            name of file to check 
 * @param includeSharedLibs   include shared libraries?
 */
static bool is_object_file(_str filename, bool includeSharedLibs=false)
{
   switch (lowcase(_get_extension(filename))) {
   case "o":
   case "obj":
   case "a":
   case "lib":
      return true;
   case "dll":
   case "so":
   case "dylib":
      return includeSharedLibs;
   default:
      return false;
   }
}

/**
 * Finds any object or library files that were added to the project file list and append
 * them to the library list.
 * 
 * @param libs the list of libraries to pass link
 * @param projectHandle the handle to the project file
 * @param configName the name of the active configuration
 * @param makefileFormat
 */
static void append_object_files(_str& libs, int projectHandle, _str configName, int makefileFormat)
{
   typeless objectList[] = null;
   status := _xmlcfg_find_simple_array(projectHandle, "/Project/Files//F", objectList);
   if (status) return;

   for (count:=0; count<objectList._length(); ++count) {
      filename := _xmlcfg_get_attribute(projectHandle, objectList[count], "N");
      filename = fixFileSeps(filename, makefileFormat);
      if (is_object_file(filename)) {
         if (libs == "") {
            libs = filename;
         } else {
            libs :+= " " _maybe_quote_filename(filename);
         }
      }
   }
}
