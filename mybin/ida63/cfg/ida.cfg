//  IDA configuration file

//
//  PLEASE READ THIS NOTICE CAREFULLY
//  ---------------------------------
//
//      Configuration file is read 2 times.
//      First pass is performed as soon as IDA is loaded
//      Second pass is performed when IDA determines the processor type
//
//      All processor specific tuning is located at the second part of this file.
//
//      Please note that some parameters occur several times in the file:
//        each occurence for different processor.
//
//      User-specific tuning can be made in idauser.cfg file
//                      (see end of this file)
//
//      You may temporarily change a configuration variable by using
//      command line switches: -d and -D
//      The -d switch is processed at the first  configuration pass.
//      The -D switch is processed at the second configuration pass.
//      Example:
//                ida -dVPAGESIZE=0x4000 -c newfile
//
//      C-like preprocessor directives are allowed.
//      You can use C-like constants in this file.
//

//=========================================================================
//                      F I R S T   P A S S
//=========================================================================
//
//      First pass.
//      Define file extension table, memory sizes, screen mode
//      and OS specific parameters.
//
//-------------------------------------------------------------------------
#ifdef ____             // first pass of config starts here
//
//      Default processor configuration table
//      -------------------------------------
//
//      The default processor will be used if the processor type is
//      not specified in the command line.
//      Feel free to customize this table.
//
DEFAULT_PROCESSOR = {
/* Extension    Processor */
  "com" :       ""                      // IDA will try the specified
  "exe" :       ""                      // extensions if no extension is
  "dll" :       ""                      // given.
  "drv" :       ""
  "sys" :       ""
  "bin" :       ""                      // Empty processor means the default processor
  "ovl" :       ""
  "ovr" :       ""
  "ov?" :       ""
  "nlm" :       ""
  "lan" :       ""
  "dsk" :       ""
  "obj" :       ""
  "prc" :       "68000"                 // PalmPilot programs
  "axf" :       "arm"
  "h68" :       "68000"                 // MC68000 for *.H68 files
  "i51" :       "8051"                  // i8051   for *.I51 files
  "sav" :       "pdp11"                 // PDP-11  for *.SAV files
  "rom" :       "z80"                   // Z80     for *.ROM files
  "cla*":       "java"
  "s19":        "6811"
  "epoc":       "arm"
  "o":          ""
  "*":          ""                      // Default processor
}

WORKDIR                 = ""            // Work direcrtory. IDA will create
                                        // temporary database files there.
                                        // Set to a directory on a separate disk
                                        // to improve open/close performance
                                        // of huge databases.

// Should plugins be automatically launched usng the information provided
// in the idb file? Setting to YES may render the IDA installation
// vulnerable to malicious idb files.

AUTORUN_IDB_PLUGINS = NO

// Plugins to automatically launch when opening an existing idb file.
// Currently we autorun the 'windbg' plugin to display Windows Crash Dump files.
AUTORUN_PLUGINS =
{
/* FileType        Plugin and argument */
#ifdef __NT__
  "windmp" :       "windbg_user:-2"
#endif
}

//
//      Memory configuration parameters
//      -------------------------------
// NOTES:
//
//      1. DATABASE_MEMORY determines how much memory will be allocated
//         for names, strings, xrefs, functions, etc. If it is == 0 then
//         IDA uses the following alrogithm:
//
//              DATABASE_MEMORY = new_file
//                              ? input_file_size * 4
//                              : old_btree_size/2
//         IDA never allocates more than 128MB in this case.
//
//      2. page sizes (VPAGESIZE and NPAGESIZE) must be powers of 2.
//
//      3. if VPAGES == 0 then 32bit IDA reserves memory by the following
//         alrogithm:
//
//              VMEM = new_file
//                              ? input_file_size*4
//                              : allocated_addressing_space;
//
//              VPAGES = VMEM / VPAGESIZE
//
//      4. Here is the total amount of memory allocated when IDA starts:
//
//           TOTAL = DATABASE_MEMORY + VPAGESIZE*VPAGES + NPAGESIZE*NPAGES
//


DATABASE_MEMORY         = 0             // Size of btree buffer in bytes.
VPAGESIZE               = 8192          // Virtual memory page size
                                        // (effective for new bases only)
                                        // 8192 => 128MB addressing space is the limit
VPAGES                  = 0             // Size of virtual memory window
                                        // (in pages)
NPAGESIZE               = 8192          // Name pointers page size
                                        // (effective for new bases only)
NPAGES                  = 32            // how big will be the memory buffer?
                                        // (each name uses 4 bytes)
                                        // The default settings allow to keep
                                        // in memory 2^16 names. The remaining
                                        // names will be swapped to the disk.

#else                   // first pass ends here


//=========================================================================
//
//                      S E C O N D   P A S S
//
//=========================================================================
//      Second pass starts here.
//      At the second pass IDA defines a macro "__<processor>__"
//      For example, if the user specified 'z80' processor,
//      then __Z80__ will be defined.
//      (note that the processor name is converted to uppercase)
//      Also, a processor module file name is used to create a macro
//      "__<idpname>__". For example, IBM PC loader defines "__PC__" symbol.
//      These macros can be used for processor specific tuning, for example:
//
//      #ifdef __Z80__
//        MAX_NAMES_LENGTH = 8
//      #endif
//
//-------------------------------------------------------------------------
//
//      General parameteres for all processors
//      (processor specific parameters are below)
//
//-------------------------------------------------------------------------

PACK_DATABASE           = 1             // 0 - don't pack at all
                                        // 1 - pack database (store)
                                        // 2 - pack database (deflate)
CREATE_BACKUPS          = NO            // Create database backups

CHECK_MANUAL_ARGS       = YES           // Check equality of manual operands
                                        // entered by Alt-F1

// Program to visualize graphs

#ifdef __NT__
// program to run after generating the graph. The filename is added at the end
GRAPH_VISUALIZER        = "qwingraph.exe -remove -timelimit 10"
// format of graph files to generate. Possible values: "GDL" and "DOT"
GRAPH_FORMAT            = "GDL"
// GRAPH_VISUALIZER        = "C:\\PROGRA~2\\GRAPHV~1.3\\BIN\\dotty.exe"
// GRAPH_FORMAT            = "DOT"
#else
#ifdef __LINUX__
GRAPH_VISUALIZER        = "qwingraph -remove -timelimit 10"
GRAPH_FORMAT            = "GDL"
//GRAPH_VISUALIZER        = "/usr/bin/dotty"
//GRAPH_FORMAT            = "DOT"
#else # __MAC__
GRAPH_VISUALIZER        = "qwingraph -remove -timelimit 10"
GRAPH_FORMAT            = "GDL"
#endif
#endif

//-------------------------------------------------------------------------
//
//      Analysis parameters
//
//-------------------------------------------------------------------------

ENABLE_ANALYSIS         = YES   // Background analysis is enabled

SHOW_INDICATOR          = YES   // Show background analysis indicator

#define AF_FIXUP        0x0001  // Create offsets and segments using fixup info
#define AF_MARKCODE     0x0002  // Mark typical code sequences as code
#define AF_UNK          0x0004  // Delete instructions with no xrefs
#define AF_CODE         0x0008  // Trace execution flow
#define AF_PROC         0x0010  // Create functions if call is present
#define AF_USED         0x0020  // Analyze and create all xrefs
#define AF_FLIRT        0x0040  // Use flirt signatures
#define AF_PROCPTR      0x0080  // Create function if data xref data->code32 exists
#define AF_JFUNC        0x0100  // Rename jump functions as j_...
#define AF_NULLSUB      0x0200  // Rename empty functions as nullsub_...
#define AF_LVAR         0x0400  // Create stack variables
#define AF_TRACE        0x0800  // Trace stack pointer
#define AF_ASCII        0x1000  // Create ascii string if data xref exists
#define AF_IMMOFF       0x2000  // Convert 32bit instruction operand to offset
#define AF_DREFOFF      0x4000  // Create offset if data xref to seg32 exists
#define AF_FINAL        0x8000  // Final pass of analysis
                                // See also ANALYSIS2, bit AF2_DODATA

ANALYSIS        = 0xFFFF        // This value is combination of the bits defined
                                // above

#define AF2_JUMPTBL     0x0001  // Locate and create jump tables
#define AF2_DODATA      0x0002  // Coagulate data segs in the final pass
#define AF2_HFLIRT      0x0004  // Automatically hide library functions
#define AF2_STKARG      0x0008  // Propagate stack argument information
#define AF2_REGARG      0x0010  // Propagate register argument information
#define AF2_CHKUNI      0x0020  // Check for unicode strings
#define AF2_SIGCMT      0x0040  // Append a signature name comment for recognized anonymous library functions
#define AF2_SIGMLT      0x0080  // Allow recognition of several copies of the same function
#define AF2_FTAIL       0x0100  // Create function tails
#define AF2_DATOFF      0x0200  // Automatically convert data to offsets
#define AF2_ANORET      0x0400  // Perform 'no-return' analysis
#define AF2_VERSP       0x0800  // Perform full stack pointer analysis
#define AF2_DOCODE      0x1000  // Coagulate code segs at the final pass
#define AF2_TRFUNC      0x2000  // Truncate functions upon code deletion

ANALYSIS2       = 0x33FD        // This value is combination of some bits defined
                                // above

//-------------------------------------------------------------------------
//
//      Text representation
//
//-------------------------------------------------------------------------

OPCODE_BYTES            = 0   // don't display instruction/data bytes
                              // The 'default' configuration in the registry may
                              // override this value
INDENTION               = 16  // Indention of instructions
                              // The 'default' configuration in the registry may
                              // override this value
COMMENTS_INDENTION      = 40  // Indention of short comments
MAX_TAIL                = 16  // Tail depth (used to gather xref info)
MAX_XREF_LENGTH         = 80  // Maximal length of line with cross-references
MAX_DATALINE_LENGTH     = 70  // Data directives (db,dw, etc):
                              //   max length of argument string
SHOW_AUTOCOMMENTS       = NO  // Display comments for every instruction
                              // Advanced users will turn this off
                              // Please note that there is another definition
                              // for IBM PC below
SHOW_BAD_INSTRUCTIONS   = NO  // Don't bother about instruction lengthes
SHOW_BASIC_BLOCKS       = NO  // Generate an empty line at the end of a basic block
SHOW_BORDERS            = YES // Borders between data/code
SHOW_EMPTYLINES         = YES // Generate empty line to make disassembly more readable
SHOW_LINEPREFIXES       = YES // Show line prefixes (like 1000:0000)
SHOW_VARIABLE_MARKS     = NO  // Show asterisks in the line prefix for addresses marked as variable
SHOW_SEGMENTS           = YES // Show segments in addresses
USE_SEGMENT_NAMES       = YES // Show segment names instead of numbers
SHOW_REPEATABLE_COMMENTS= YES // Show repeatable comments (disabling this increases IDA speed)
SHOW_SP                 = NO  // Show stack pointer at the start of lines
                              // The 'default' configuration in the registry may
                              // override this value
SHOW_SUSPICIOUS         = NO  // Show <void> marks (the red/orange color is bright enough)
SHOW_XREFS              = 2   // Show 2 cross-references (the rest is accessible by Ctrl-X)
SHOW_XREF_FUNC          = YES // Show function offsets in xrefs
SHOW_XREF_TYPES         = YES // Show xref type marks
SHOW_XREF_VALUES        = YES // If not, xrefs are displayed as "..."
SHOW_SEGXREFS           = YES // Show segment part of addresses in cross-references
SHOW_SOURCE_LINNUM      = YES // Show source line numbers
SHOW_ASSUMES            = YES // Generate 'assume' directives
SHOW_ORIGINS            = YES // Generate 'org' directives
USE_TABULATION          = YES // Use '\t' in output files

DEL_CODE_COMMENTS       = YES // Delete a comment attached to an instruction
                              // when the instruction is deleted
MAX_ITEM_LINES          = 5000 // Maximum number of lines for one item (one instruction or data)

//-------------------------------------------------------------------------
//      Colors
//-------------------------------------------------------------------------
#ifdef __GUI__
//PROLOG_COLOR = 0xE0E0E0            // grey
//EPILOG_COLOR = 0xE0FFE0            // light green
//SWITCH_COLOR = 0xE0E0FF            // pink
#endif

//-------------------------------------------------------------------------
//
//      Floating point numbers
//
//-------------------------------------------------------------------------
FPNUM_DIGITS            = 0   // If non-zero, specifies the number of digits printed
                              // after the decimal point. The printed number may be
                              // truncated if necessary.
                              // If FPNUM_DIGITS is non-zero, FPNUM_LENGTH must be non-zero too

FPNUM_LENGTH            = 6   // If FP_DIGITS is non-zero:
                              //   specifies the desired length of output string.
                              //   IDA will print the number in regular (non-scientific)
                              //   notation if possible.
                              // else
                              //   controls the notation used to print the number:
                              //   if the abs(number exponent) <= FPNUM_LENGTH
                              //     print in regular notation
                              //   else
                              //     print in scientific notation

// Example: to display numbers in reasonable range (0.00001..10000.0) nicely
//      FPNUM_DIGITS=0
//      FPNUM_LENGTH=5
// Too big and too small numbers will be printed using the scientific notation

// Example: to display numbers nicely formatted with constant width (8) and
//          constant decimal point position(3):
//      FPNUM_DIGITS=3
//      FPNUM_LENGTH=8
// IDA will print numbers in regular notation if possible.
// Attention, this setting will truncate all values to 3 digits after the decimal point

// Example: print numbers in scientific notation
//      FPNUM_DIGITS=0
//      FPNUM_LENGTH=0

// Example: forbidden combination:
//      FPNUM_DIGITS=5
//      FPNUM_LENGTH=0

//-------------------------------------------------------------------------
//
//      Text representation in the graph mode
//
//-------------------------------------------------------------------------
GRAPH_COMMENTS_INDENTION    = 24        // Indention of short comments
GRAPH_INDENTION             = 0         // Indention of instructions
GRAPH_MARGIN                = 40        // Max node width
GRAPH_SHOW_LINEPREFIXES     = NO        // Show line prefixes (like 1000:0000)
GRAPH_SHOW_XREFS            = 0         // Show no xrefs (use node title button for them)
GRAPH_OPCODE_BYTES          = 0         // don't display instruction/data bytes

//-------------------------------------------------------------------------
//
//      ASCII strings & names
//
//-------------------------------------------------------------------------

ASCII_GENNAMES          = YES           // Generate names when making
                                        // an ASCII string
ASCII_TYPE_AUTO         = YES           // Should IDA mark generated ascii names
                                        // as 'autogenerated'?
                                        // Autogenerated names will be deleted
                                        // when the ascii string is deleted
                                        // Also, they are displayed with the
                                        // same color as dummy names.
ASCII_LINEBREAK         = '\n'          // This char forces IDA
                                        // to start a new line
ASCII_PREFIX            = "a"           // This prefix is used when a new
                                        // name is generated

#define ASCII_STYLE_C           0x00000000// Character-terminated ASCII string
#define ASCII_STYLE_PASCAL      0x00000001// Pascal-style ASCII string (length byte)
#define ASCII_STYLE_LEN2        0x00000002// Pascal-style, length has 2 bytes
#define ASCII_STYLE_UNICODE     0x00000003// Unicode string
#define ASCII_STYLE_LEN4        0x00000004// Pascal-style, length has 4 bytes
#define ASCII_STYLE_ULEN2       0x00000005// Pascal-style Unicode, length is 2 bytes
#define ASCII_STYLE_ULEN4       0x00000006// Pascal-style Unicode, length is 4 bytes
ASCII_STYLE             = ASCII_STYLE_C // Default is C-style

ASCII_SERIAL            = NO            // Serial names are disabled
ASCII_SERNUM            = 0             // Number to start serial names
ASCII_ZEROES            = 0             // Number of leading zeroes in
                                        // serial names
ASCII_COMMENT           = YES           // Generate auto comment for
                                        // ascii references. This option will
                                        // display the beginning of ascii string
                                        // at the instruction which refers
                                        // to the string
ASCII_SAVECASE          = NO            // Preserve case of ascii strings for identifiers

        // type of generated names: (dummy names)
#define NM_REL_OFF      0
#define NM_PTR_OFF      1
#define NM_NAM_OFF      2
#define NM_REL_EA       3
#define NM_PTR_EA       4
#define NM_NAM_EA       5
#define NM_EA           6
#define NM_EA4          7
#define NM_EA8          8
#define NM_SHORT        9
#define NM_SERIAL       10
DUMMY_NAMES_TYPE        = NM_EA

MAX_NAMES_LENGTH        = 15            // Maximal length of new names
                                        // (you may specify values up to 511)
        //
        // NOTE: As far as I know some assemblers can't handle such
        // a long names. For example, Table Driven Assembler
        // supports names' length up to 13.
        //      BE CAREFUL!

// Types of names that must be included into the list of names
// (this list usually appears by pressing Ctrl-L)
//      normal    1
//      public    2
//      auto      4
//      weak      8

LIST_NAMES              = 0x07  // default: include normal, public, auto

LOCAL_NAME_PREFIX       = "@@"          // If a new name has this prefix
                                        // it will be converted to a local name

//-------------------------------------------------------------------------

//      Representation of demangled names
//      There are two predefined forms of demangled names: short and long forms.
//      Form of a demangled names is determined by combination of bits.
//      Each bit inhibits or permits some part of the demangled name.

                                    // Pointer modifiers:
#define MNG_DEFNEAR      0x00000000 //   inhibit near, display everything else
#define MNG_DEFNEARANY   0x00000001 //   inhibit near/__ptr64, display everything else
#define MNG_DEFFAR       0x00000002 //   inhibit far, display everything else
#define MNG_NOPTRTYP16   0x00000003 //   inhibit everything (disables vc7-extensions)
#define MNG_DEFHUGE      0x00000004 //   inhibit huge, display everything else
#define MNG_DEFPTR64     0x00000005 //   inhibit __pt64, display everything else
                                    //   ATT: in 64bit must be + MNG_NOTYPE|MNG_NOCALLC
#define MNG_DEFNONE      0x00000006 //   display all pointer modifiers
#define MNG_NOPTRTYP     0x00000007 //   inhibit all pointer modifiers

#define MNG_NODEFINIT    0x00000008 // Inhibit everything except the main name
                                    // This flag is not recommended
                                    // for __fastcall/__stdcall GCC3 names
                                    // because there is a high probablity of
                                    // incorrect demangling. Use it only when
                                    // you are sure that the input is a
                                    // cygwin/mingw function name
#define MNG_NOUNDERSCORE 0x00000010 // Inhibit underscores in __ccall, __pascal... +
#define MNG_NOTYPE       0x00000020 // Inhibit callc&based
#define MNG_NORETTYPE    0x00000040 // Inhibit return type of functions
#define MNG_NOBASEDT     0x00000080 // Inhibit base types
                                    //   NOTE: also inhibits "__linkproc__"
#define MNG_NOCALLC      0x00000100 // Inhibit __pascal/__ccall/etc
#define MNG_NOPOSTFC     0x00000200 // Inhibit postfix const
#define MNG_NOSCTYP      0x00000400 // Inhibit public/private/protected
#define MNG_NOTHROW      0x00000800 // Inhibit throw description
#define MNG_NOSTVIR      0x00001000 // Inhibit "static" & "virtual"
#define MNG_NOECSU       0x00002000 // Inhibit class/struct/union/enum
#define MNG_NOCSVOL      0x00004000 // Inhibit const/volatile/restrict
                                    //   NOTE: also inhibits "__unaligned"
#define MNG_NOCLOSUR     0x00008000 // Inhibit __closure for borland
#define MNG_NOUNALG      0x00010000 // Inhibit __unaligned (see NOCSVOL)
#define MNG_NOMANAGE     0x00020000 // Inhibit __pin/__box/__gc for ms(.net)
#define MNG_SHORT_S      0x00100000 // signed (int) is displayed as s(int)
#define MNG_SHORT_U      0x00200000 // unsigned (int) is displayed as u(int)
#define MNG_ZPT_SPACE    0x00400000 // Display space after comma in the arglist
#define MNG_DROP_IMP     0x00800000 // Inhibit __declspec(dllimport)
#define MNG_IGN_ANYWAY   0x02000000 // Ingore '_nn' at the end of name
#define MNG_IGN_JMP      0x04000000 // Ingore 'j_'  at the beginning of name
#define MNG_MOVE_JMP     0x08000000 // Move 'j_' prefix to the demangled name
                                    // If both MNG_IGN_JMP and MNG_MOVE_JMP
                                    // are set then move the prefix only if
                                    // the name was not truncated

ShortNameForm   =       0x0EA3BE67      // short form of demangled names
LongNameForm    =       0x06400007      // long  form of demangled names

#define DEMNAM_CMNT  0                  // comments
#define DEMNAM_NAME  1                  // regular names
#define DEMNAM_NONE  2                  // don't display

DemangleNames   = DEMNAM_CMNT           // Show demangled names as comments

//-------------------------------------------------------------------------
//
//      Character translations and allowed character lists
//
//-------------------------------------------------------------------------

// translation when ASCII string name is built using its contents
// (now it is tuned for 866 codepage)
// the order and number of the string constants is important!
// (XLAT tables always consist of 16 strings each 16 characters!!!)
XlatAsciiName =
/*00..0F*/ "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F"
/*10..1F*/ "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F"
/*20..3F*/ " !\"# %&'()*+,-_/"
           "0123456789:;<=>?"
/*40..5F*/ "@ABCDEFGHIJKLMNO"
           "PQRSTUVWXYZ[\\]^_"
/*60..7F*/ "`abcdefghijklmno"
           "pqrstuvwxyz{|}~"
/*80..9F*/ "ABVGDEJZIIKLMNOP"
           "RSTUFXCCSS I AUQ"
/*A0..BF*/ "abvgdejziiklmnop"
           "∞±≤≥¥µ∂∑∏π∫ªºΩæø"
/*C0..DF*/ "¿¡¬√ƒ≈∆«»… ÀÃÕŒœ"
           "–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ"
/*E0..FF*/ "rstufxccss i auq"
           "ÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ";

// the following characters are allowed in ASCII strings, i.e.
// in order to find end of a string IDA looks for a character
// which doesn't belong to this array:
// (cp866 version)
AsciiStringChars =
        "\r\n\a\v\b\t\x1B"
        " !\"#$%&'()*+,-./0123456789:;<=>?"
        "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"
        "`abcdefghijklmnopqrstuvwxyz{|}~"
        "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü"
        "†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø"
        "¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ"
        "‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔ";

// (full version)
//AsciiStringChars =
//      "\r\n\a\v\b\t\x1B"
//      " !\"#$%&'()*+,-./0123456789:;<=>?"
//      "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_"
//      "`abcdefghijklmnopqrstuvwxyz{|}~"
//      "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü"
//      "†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø"
//      "¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ"
//      "‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ";

// the following characters are allowed in user-defined names:

NameChars =
        "$?@"           // asm specific character
        "_0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";


// the following characters are allowed in mangled names.
// they will be substituted with the SubstChar during output if names
// are output in a mangled form.

MangleChars = "$:?([.)]"        // watcom
              "@$%?"            // microsoft
              "@$%&";           // borland
SubstChar   = '_'

//-------------------------------------------------------------------------
//      Built-in C parser parameters
//-------------------------------------------------------------------------

// The current settings are for the VC++

// List of include directories separated by ';'
// This list must end by a semicolon (outside the quotes)
C_HEADER_PATH           = "/Program Files/Microsoft Visual Studio/VC98/include";

// List of predefined macros separated by ';'
// This list must end by a semicolon (outside the quotes)
C_PREDEFINED_MACROS     = "_cdecl=__cdecl;"
                          "_pascal=__pascal;"
                          "_huge=__huge;"
                          "_near=__near;"
                          "_far=__far;"
                          "__inline=;"
                          "_inline=;"
                          "inline=;"
                          "CM_WINNT;"
                          "MPR50;"
                          "_INTEGRAL_MAX_BITS=64;"
                          "_MSC_VER=1400;"
                          "_CHAR_UNSIGNED=1;"
                          "_M_IX86=300;"
                          "__MT__=1;"
                          "__TLS__=1;"
                          "_Windows=1;"
                          "__WIN32__=1;"
                          "_WIN32_WINNT=0x0500;"
                          "WINVER=0x0500;"
                          "_WIN32=1;"
                          "OLEDBVER=0x0250;"
                          "SECURITY_WIN32;"
                          "WIN32_SUPPORT;"
                          "DBNTWIN32;"
                          "W32SUT_32;";


//-------------------------------------------------------------------------
//      Processor specific parameters
//-------------------------------------------------------------------------
#ifdef __PC__                           // INTEL 80x86 PROCESSORS

//
// Location of Microsoft Debugging Engine Library (dbgeng.dll)
// This value is used by both the windmp (dump file loader) and the windbg
// debugger module. Please also refer to dbg_windbg.cfg
// (note: make sure there is a semicolon at the end)

//DBGTOOLS = "C:\\Program Files\\Debugging Tools for Windows (x86)\\";

USE_FPP                 = YES           // Floating Point Processor
                                        // instructions are enabled

// IBM PC specific analyzer options

PC_ANALYZE_PUSH         = YES           // Convert immediate operand of "push" to offset
                                        //
                                        //      In sequence
                                        //
                                        //              push    seg
                                        //              push    num
                                        //
                                        //      IDA will try to convert <num> to offset.
                                        //
PC_ANALYZE_NOP          = NO            // Convert db 90h after "jmp" to "nop"
                                        // Now it is better to turn off this option
                                        // because the final pass of the analysis will
                                        // convert 90h to nops more intelligently.
                                        //
                                        //      Sequence
                                        //
                                        //              jmp     short label
                                        //              db      90h
                                        //
                                        //      will be converted to
                                        //
                                        //              jmp     short label
                                        //              nop
                                        //
PC_ANALYZE_MOVOFF       = YES           // Convert immediate operand of "mov reg,..." to offset
                                        //
                                        //      In sequence
                                        //
                                        //              mov reg,    num
                                        //              mov segreg, immseg
                                        //
                                        //      where
                                        //        reg    - any general register
                                        //        num    - a number
                                        //        segreg - any segment register
                                        //        immseg - any form of operand representing a segment paragraph
                                        //
                                        //      <num> will be converted to an offset
                                        //
PC_ANALYZE_MOVOFF2      = YES           // Convert immediate operand of "mov memory,..." to offset
                                        //
                                        //      In sequence
                                        //
                                        //              mov x1, num
                                        //              mov x2, seg
                                        //
                                        //      where
                                        //              x1,x2 - any references to memory
                                        //
                                        //      <num> will be converted to an offset
                                        //
PC_ANALYZE_ZEROINS      = NO            // Disassemble zero opcode instructions
                                        //
                                        //      These instructions include:
                                        //
                                        //              00 00   add [bx+si], al
                                        //              00 00   add [eax], al
                                        //
                                        //      Usually this options is disabled
                                        //
PC_ANALYZE_BRTTI        = YES           // Advanced analysis of Borland's RTTI
                                        //
                                        //      This option allows ida to test and create RTTI structures.
                                        //      The analisys is triggered by renaming a location.
                                        //      If the new name can be demangled as Borland's RTTI descriptor name
                                        //      then the analisys is performed.
                                        //
PC_ANALYZE_UNKRTTI      = YES           // Check 'unknown_libname' for Borland's RTTI
                                        //
                                        //      This option allows IDA to test locations named as unknown_libname
                                        //      for RTTI structures. This option is meaningful only if the advanced
                                        //      analysis of RTTI is allowed.
                                        //
PC_ANALYZE_EXPFUNC      = YES           // Advanced analisys of catch/finally block
                                        //
                                        //      This option allows ida to check catch/finally exception blocks
                                        //
PC_ANALYZE_DIFBASE      = NO            // Allow references with different segment bases
                                        //
                                        //      This option allows IDA to display a reference to a symbol even if
                                        //      the reference value is not equal to the symbol value. For example,
                                        //      to refer to symbol \"x\" at 0000:0100 with expression 0010:0000
                                        //
PC_ANALYZE_NOPREF       = NO            // Don't display redundant instruction prefixes
                                        //
                                        //      This option makes the disassembly more readable by hiding the
                                        //      superfluous instruction prefixes which are not used in the
                                        //      instruction
                                        //
PC_ANALYZE_VXD          = YES           // Interpret int 20 as VxDcall
                                        //
                                        //      This option turns on interpretation of int 20h
                                        //      as a VxDcall/jump for 32-bit files
                                        //
PC_ANALYZE_FPEMU        = YES           // Enable FPU emulation instructions
                                        //
                                        //      This option turns on interpretation of int 3?h
                                        //      instructions as FPU emulation instructions
                                        //
PC_ANALYZE_SHOWRIP      = NO            // Explicit RIP-addressing
                                        //
                                        //      If this option is turned on, then RIP addressing is
                                        //      always represented with the RIP register
                                        //
                                        //              mov rax, [rip+1234]
                                        //
                                        //      Otherwise RIP addressing is replaced by the corresponding
                                        //      memory reference (when possible)
                                        //      This option is valid only for the 64-bit mode.
                                        //

PC_ANALYZE_NOSEH        = NO            // Disable SEH/EH analysis
                                        //      This option disables detection of Structured Exception (SEH)
                                        //      and C++ Exception (EH) handlers.

PE_MAKE_IDATA           = YES           // Create imports segment for PE files
PE_LOAD_RESOURCES       = NO            // Load resources for PE files
PE_CREATE_FLAT_GROUP    = NO            // Create FLAT group for PE files


// The following translation is used to display the contents of an ASCII
// string.

// (trivial translation - no changes)
XlatAsciiOutput =
/*00..0F*/ "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F"
/*10..1F*/ "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F"
/*20..2F*/ "\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f"
/*30..3F*/ "\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
/*40..5F*/ "\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f"
/*50..5F*/ "\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
/*60..6F*/ "\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f"
/*70..7F*/ "\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
/*80..8F*/ "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8A\x8B\x8C\x8D\x8E\x8F"
/*90..9F*/ "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9A\x9B\x9C\x9D\x9E\x9F"
/*A0..AF*/ "\xA0\xA1\xA2\xA3\xA4\xA5\xA6\xA7\xA8\xA9\xAA\xAB\xAC\xAD\xAE\xAF"
/*B0..BF*/ "\xB0\xB1\xB2\xB3\xB4\xB5\xB6\xB7\xB8\xB9\xBA\xBB\xBC\xBD\xBE\xBF"
/*C0..CF*/ "\xC0\xC1\xC2\xC3\xC4\xC5\xC6\xC7\xC8\xC9\xCA\xCB\xCC\xCD\xCE\xCF"
/*D0..DF*/ "\xD0\xD1\xD2\xD3\xD4\xD5\xD6\xD7\xD8\xD9\xDA\xDB\xDC\xDD\xDE\xDF"
/*E0..EF*/ "\xE0\xE1\xE2\xE3\xE4\xE5\xE6\xE7\xE8\xE9\xEA\xEB\xEC\xED\xEE\xEF"
/*F0..FF*/ "\xF0\xF1\xF2\xF3\xF4\xF5\xF6\xF7\xF8\xF9\xFA\xFB\xFC\xFD\xFE\xFF";

// translation table for win1251 encoding
// XlatAsciiOutput =
// /*00..0F*/ "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
// /*10..1F*/ "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
// /*20..2F*/ "\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f"
// /*30..3F*/ "\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
// /*40..5F*/ "\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f"
// /*50..5F*/ "\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
// /*60..6F*/ "\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f"
// /*70..7F*/ "\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
// /*80..8F*/ "\x3f\x3f\x27\x3f\x22\x3a\xc5\xd8\x3f\x25\x3f\x3c\x3f\x3f\x3f\x3f"
// /*90..9F*/ "\x3f\x27\x27\x22\x22\x07\x2d\x2d\x3f\x54\x3f\x3e\x3f\x3f\x3f\x3f"
// /*A0..AF*/ "\xff\xf6\xf7\x3f\xfd\x3f\xb3\x15\xf0\x63\xf2\x3c\xbf\x2d\x52\xf4"
// /*B0..BF*/ "\xf8\x2b\x49\x69\x3f\xe7\x14\xfa\xf1\xfc\xf3\x3e\x3f\x3f\x3f\xf5"
// /*C0..CF*/ "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
// /*D0..DF*/ "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
// /*E0..EF*/ "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf"
// /*F0..FF*/ "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef";

SHOW_AUTOCOMMENTS       = NO // Don't display comments for every instruction

ANALYSIS2       = 0x3FFD        // Enable 'noret' analysis
                                // Enable SP analysis

#endif // __PC__
//-------------------------------------------------------------------------
#ifdef __JAVA__
SHOW_BORDERS            = NO            // Borders between data/code
SHOW_LINEPREFIXES       = NO            // No Show line prefixes (1000:0000)
SHOW_SEGXREFS           = NO            // No Show segment part of addresses
                                        // in cross-references
SHOW_BAD_INSTRUCTIONS   = YES           // Show variable names in aload_0
                                        // store_1 and similar instructions
DUMMY_NAMES_TYPE        = NM_SHORT      // See 'dummy names' for explanations
MAX_DATALINE_LENGTH     = 77            // Data directives (db,dw, etc):
                                        //   max length of argument string
SHOW_XREFS              = 1             // Show 1 cross-reference
COMMENTS_INDENTION      = 47            // Indention for on-line comments
//
// Translation table for characters in interval 0x00-0xFF.
// This table not used in IDA - see java-language description of character
// encoding for 'JavaCharacter', and comment to 'AsciiStringChars' below.
//
//XlatAsciiName = "";
//
// Table of characters which are allowed in class, field, and method names.
// This table is created dynamically by the java module.
// Java supports any unicode LetterOrDigit character as 'name'-character,
// but IDA curently does not support the unicode output. Theoretically it is
// possible to enable any character in the current codepage as 'namechar' but
// there will be a problem with IDA databases. A old database will look wrong
// if opened on a computer with a different codepage. For this reason
// only english letter, digits, '$' and '_' are allowed in the names.
// (see java langspec).
//
NameChars = "";
//
// Table of characters which are allowed in ASCII strings, i.e. in
// CONSTANT_String arguments, Source File Name, SourceDebugExtension, etc.
// This table not used by the java module - currently IDA accepts only
// characters < 0x7F (english characters) and encoded unicode character
// for the CURRENT locale (cidition: the locale is NOT mbcs, which means
// that japanese, thai, etc will not work)
//
AsciiStringChars = "";
//

JAVA_MULTILINE_DEBUG	=	YES	// Force a new line at every LF
					// in the '.debug' directive

JAVA_HIDE_STACKMAP	=	NO	// Hide '.stack' verification areas

JAVA_AUTO_STRING	=	NO	// Make 'prompt' string after every
					// LR in quoted strings

JAVA_ASMFILE_CONVERT	=	YES	// Create jasmin-compatible
                                        // asm-file and change
					// the encoding from OEM to ANSI
                                        // (jasmin expects ANSI encoding)

JAVA_ENABLE_ENCODING	=	YES     // Convert unicode characters in
                                        // strings constants to ascii
                                        // characters (for the current
 					// locale).

JAVA_NOPATH_ATTRIBUTE	=	NO	// If 'YES', filename in '.attribute'
					// directives is specified without path.

// options for loader

JAVA_UNKATTR_REQUEST	=	YES	// If the loaded file contains 'unknown
                                        // attributes' and the 'manual load' is off
                                        // then IDA will ask your permission to
                                        // store the attributes to an external
                                        // file

JAVA_UNKATTR_WARNING	=	YES	// Include information of 'unknown
					// attributes' (if they were not saved
					// into external files) in the problem
                                        // list

JAVA_STARTASM_LIST	=	NO	// Display mode for new java files:
                                        // YES: listing mode
                                        // NO: jasmin mode

#endif // __JAVA__

//-------------------------------------------------------------------------

#ifdef __ARM__

ANALYSIS        = 0x9FFF        // Disable AF_IMMOFF, AF_DREFOFF
ANALYSIS2       = 0x35FD        // Enable 'noret' analysis, disable AF2_DATOFF

NameChars =
        ".$"
        "_0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

ARM_SIMPLIFY     = YES          // Simplify instructions and replace them
                                // by pseudo-instructions

ARM_NO_PTR_DEREF = NO           // Disable using of =label notation
                                // This notation makes disassembly cleaner

ARM_USE_MACROS   = YES          // Use macro-instructions like MOVL

ARM_NO_ARM_THUMB_SWITCH = NO    // No automatic ARM-THUMB switch

ARM_DISABLE_BL_JUMPS    = NO    // Disable detection of BL instructions used for long jumps (not calls) in Thumb mode

ARM_DEFAULT_ARCHITECTURE = "ARMv6"; // Default architecture when not set by the loader. For details see documentation.

// ARM_DEFAULT_ARCHITECTURE = "ARMv7-A";

#endif // __ARM__

//-------------------------------------------------------------------------
#ifdef __TMS320C6__
INDENTION       = 8             // Indention of instructions
NameChars =
        "$_0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";
ANALYSIS        = 0xBFFF        // All except AF_DREFOFF
#endif // __TMS320C6__

//-------------------------------------------------------------------------
#ifdef __TMS320C54__

TMS320C54_IO   =  YES		    // Use I/O definitions from the configuration
								// file in macro instructions.

TMS320C54_MMR  =  YES			// Replace addresses by an equivalent memory
								// mapped register.

TMS320C54_DSEG =  0x10000		// Default data segment address

#endif // __TMS320C54__

//-------------------------------------------------------------------------
#ifdef __PPC__          // PowerPC processor

NameChars =
        "_0123456789."
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";
                        // preserve the following characters in
                        // names (AIX assembler has .rename directive)
MangleChars = "!@#$%^&*()+-=[]\\{}|;':,/<>?`~ ";

ANALYSIS        = 0xFF7F        // Don't create function if data xref data->code32 exists
                                // (AIX XCOFF has many references from data
                                //  segment to strings in the code segment)
ANALYSIS2       = 0x37FD        // Enable 'noret' analysis

DUMMY_NAMES_TYPE = NM_EA

MAX_DATALINE_LENGTH     = 250           // this stupid AIX assembler can't digest
                                        // a string without a trailing zero
                                        // and we are forced to display
                                        // everything on one line

LOOKBACK         = 160          // Look back up to 160 instructions to find
                                // LIS instruction

PPC_LISOFF       = YES          // Agressively convert lis/addi pairs
                                // to offsets (only if they refer to a valid
                                // address)

PPC_CREATE_SUBI  = NO           // If enabled, IDA will replace addi
                                // instructions with negative values by
                                // subi pseudo-instructions

// extra instructions to decode
// NB! AltiVec is mutually exclusive with SPE

#define ISA_ALTIVEC     0x0001  // AltiVec SIMD instructions
#define ISA_SPE         0x0002  // SPE (Signal Processing Engine) instructions
#define ISA_VLE         0x0004  // VLE (variable-length encoding) instructions

PPC_ISA_SUPPORT       = 0x0001  // This value is combination of the bits above

#endif  // __PPC__

//-------------------------------------------------------------------------
#ifdef __80196__                // Intel 80196 processor

DUMMY_NAMES_TYPE = NM_SHORT

#endif  // __80196__

//-------------------------------------------------------------------------
#ifdef __I51__                  // Intel 8051, 80251 processors

DUMMY_NAMES_TYPE = NM_SHORT

#endif  // __I51__

//-------------------------------------------------------------------------
#ifdef __PDP11__                  // Digital PDP-11 processor

// Use character translation?

PDP_XLAT_ASCII = NO

// The following translation is used to display the contents of an ASCII
// string if PDP_XLAT_ASCII is set.

// This table is tuned for the Russian character set:
// (XLAT tables always consist of 16 strings each 16 characters!!!)

XlatAsciiOutput =

    "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0A\x0B\x0C\x0D\x0E\x0F"
    "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1A\x1B\x1C\x1D\x1E\x1F"
    "\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2A\x2B\x2C\x2D\x2E\x2F"
    "\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3A\x3B\x3C\x3D\x3E\x3F"
    "\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4A\x4B\x4C\x4D\x4E\x4F"
    "\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5A\x5B\x5C\x5D\x5E\x5F"
    "\x9E\x80\x81\x96\x84\x85\x94\x83\x95\x88\x89\x8A\x8B\x8C\x8D\x8E"
    "\x8F\x9F\x90\x91\x92\x93\x86\x82\x9C\x9B\x87\x98\x9D\x99\x97\177"
    "\200\201\202\203\204\205\206\207\210\211\212\213\214\215\216\217"
    "\220\221\222\223\224\225\226\227\230\231\232\233\234\235\236\237"
    "\240\241\242\243\244\245\246\247\250\251\252\253\254\255\256\257"
    "\260\261\262\263\264\265\266\267\270\271\272\273\274\275\276\277"
    "\140\141\142\143\144\145\146\147\150\151\152\153\154\155\156\157"
    "\160\161\162\163\164\165\166\167\170\171\172\173\174\175\176\x9A"
    "\xEE\xA0\xA1\xE6\xA4\xA5\xE4\xA3\xE5\xA8\xA9\xAA\xAB\xAC\xAD\xAE"
    "\xAF\xEF\xE0\xE1\xE2\xE3\xA6\xA2\xEC\xEB\xA7\xE8\xED\xE9\xE7\xEA";

NameChars = "0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz_";

#endif  // __PDP11__

//-------------------------------------------------------------------------
#ifdef __SH3__                  // Hitachi SH3 processor

ANALYSIS        = 0xFF7F        // Don't create function if data xref data->code32 exists
                                // (PE execs have many Unicode strings in the code segment)

DUMMY_NAMES_TYPE = NM_EA

SH3_INLINE_IMMVALS = YES        // Put the immediates loaded from the literal pool into the instruction itself

#endif  // __SH3__

//-------------------------------------------------------------------------
#ifdef __MIPS__                 // MIPS processor

DUMMY_NAMES_TYPE = NM_EA

MIPS_MNEMONIC    = YES          // Use mnemonic register names
MIPS_SIMPLIFY    = YES          // Simplify instructions and replace them
                                // by pseudo-instructions
MIPS_STRICT      = NO           // Strictly adhere to instruction specifications
MIPS_MACRO       = YES          // Use macros
MIPS_MACRO_RESPECT_XREFS = YES  // When looking back for the "lui" instruction,
                                // stop when an xrefed instruction is found
MIPS_MACRO_HIDDEN_R1 = YES      // Allow hidden modification of $1 in macros

LOOKBACK         = 16           // Look back up to 16 instructions to find
                                // LUI instruction

#endif  // __MIPS__

//-------------------------------------------------------------------------
#ifdef __PIC__                  // PIC processor

DUMMY_NAMES_TYPE = NM_NAM_OFF
PIC_MACRO        = YES          // Use macros

#endif  // __PIC__

//-------------------------------------------------------------------------
#ifdef __SPARC__                // SPARC processor

DUMMY_NAMES_TYPE = NM_EA

SPARC_SIMPLIFY   = YES          // Simplify instructions and replace them
                                // by pseudo-instructions
SPARC_STRICT     = NO           // Strictly adhere to instruction specifications
SPARC_MACRO      = YES          // Use macros
SPARC_V8         = NO           // V8 architecture disassembly

LOOKBACK         = 16           // Look back up to 16 instructions to find
                                // SETHI instruction
SHOW_BAD_INSTRUCTIONS   = YES   // Display impdep1 & impdep2 as bytes

#endif  // __SPARC__

//-------------------------------------------------------------------------
#ifdef __ALPHA__                // DEC Alpha processor

DUMMY_NAMES_TYPE = NM_EA

ALPHA_SIMPLIFY   = YES          // Simplify instructions and replace them
                                // by pseudo-instructions
ALPHA_STRICT     = NO           // Strictly adhere to instruction specifications
ALPHA_MACRO      = YES          // Use macros
ALPHA_MNEMONIC   = NO           // Use mnemonic register names

LOOKBACK         = 16           // Look back up to 16 instructions to find
                                // SETHI instruction

#endif  // __ALPHA__

//-------------------------------------------------------------------------
#ifdef __HPPA__                 // HP PA-RISC processor

DUMMY_NAMES_TYPE = NM_EA

HPPA_SIMPLIFY    = YES          // Simplify instructions and replace them
                                // by pseudo-instructions
HPPA_MNEMONIC    = NO           // Use mnemonic register names
HPPA_PSW_W       = NO           // Consider programs as 64bit?

LOOKBACK         = 16           // Look back up to 16 instructions to find
                                // ADDIL/LDIL instructions

NameChars =
        "_0123456789."
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

SHOW_BASIC_BLOCKS       = YES   // Generate an empty line at the end of basic blocks

#endif  // __HPPA__

//-------------------------------------------------------------------------
#ifdef __DSP56K__               // Motorola 56000 (5600x) processor

DUMMY_NAMES_TYPE        = NM_SHORT

PACK_DATABASE           = 2     // deflate

#endif  // __DSP56K__

//-------------------------------------------------------------------------
#ifdef __IA64__                 // Intel Itanium IA64

DUMMY_NAMES_TYPE = NM_EA

NameChars =
        "_0123456789."
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

LOOKBACK         = 16           // Look back up to 16 instructions to find
                                // memory reference addresses
#endif  // __IA64__

//-------------------------------------------------------------------------
#ifdef __CLI__                  // Microsoft.Net Common Language Infrastructure

NameChars =
      "!#$%&'()*+,-./0123456789:;<=>?"
      "@ABCDEFGHIJKLMNOPQRSTUVWXYZ[]^_"
      "`abcdefghijklmnopqrstuvwxyz{|}~"
      "ÄÅÇÉÑÖÜáàâäãåçéèêëíìîïñóòôöõúùûü"
      "†°¢£§•¶ß®©™´¨≠ÆØ∞±≤≥¥µ∂∑∏π∫ªºΩæø"
      "¿¡¬√ƒ≈∆«»… ÀÃÕŒœ–—“”‘’÷◊ÿŸ⁄€‹›ﬁﬂ"
      "‡·‚„‰ÂÊÁËÈÍÎÏÌÓÔÒÚÛÙıˆ˜¯˘˙˚¸˝˛ˇ";

SHOW_BORDERS            = NO
SHOW_SEGMENT_BORDERS    = NO

INDENTION               = 4   // Indention of instructions
COMMENTS_INDENTION      = 40  // Indention of short comments
SHOW_LINEPREFIXES       = NO  // Show line prefixes (like 1000:0000)

// translation table for win1251 encoding
// XlatAsciiOutput =
// /*00..0F*/ "\x00\x01\x02\x03\x04\x05\x06\x07\x08\x09\x0a\x0b\x0c\x0d\x0e\x0f"
// /*10..1F*/ "\x10\x11\x12\x13\x14\x15\x16\x17\x18\x19\x1a\x1b\x1c\x1d\x1e\x1f"
// /*20..2F*/ "\x20\x21\x22\x23\x24\x25\x26\x27\x28\x29\x2a\x2b\x2c\x2d\x2e\x2f"
// /*30..3F*/ "\x30\x31\x32\x33\x34\x35\x36\x37\x38\x39\x3a\x3b\x3c\x3d\x3e\x3f"
// /*40..5F*/ "\x40\x41\x42\x43\x44\x45\x46\x47\x48\x49\x4a\x4b\x4c\x4d\x4e\x4f"
// /*50..5F*/ "\x50\x51\x52\x53\x54\x55\x56\x57\x58\x59\x5a\x5b\x5c\x5d\x5e\x5f"
// /*60..6F*/ "\x60\x61\x62\x63\x64\x65\x66\x67\x68\x69\x6a\x6b\x6c\x6d\x6e\x6f"
// /*70..7F*/ "\x70\x71\x72\x73\x74\x75\x76\x77\x78\x79\x7a\x7b\x7c\x7d\x7e\x7f"
// /*80..8F*/ "\x3f\x3f\x27\x3f\x22\x3a\xc5\xd8\x3f\x25\x3f\x3c\x3f\x3f\x3f\x3f"
// /*90..9F*/ "\x3f\x27\x27\x22\x22\x07\x2d\x2d\x3f\x54\x3f\x3e\x3f\x3f\x3f\x3f"
// /*A0..AF*/ "\xff\xf6\xf7\x3f\xfd\x3f\xb3\x15\xf0\x63\xf2\x3c\xbf\x2d\x52\xf4"
// /*B0..BF*/ "\xf8\x2b\x49\x69\x3f\xe7\x14\xfa\xf1\xfc\xf3\x3e\x3f\x3f\x3f\xf5"
// /*C0..CF*/ "\x80\x81\x82\x83\x84\x85\x86\x87\x88\x89\x8a\x8b\x8c\x8d\x8e\x8f"
// /*D0..DF*/ "\x90\x91\x92\x93\x94\x95\x96\x97\x98\x99\x9a\x9b\x9c\x9d\x9e\x9f"
// /*E0..EF*/ "\xa0\xa1\xa2\xa3\xa4\xa5\xa6\xa7\xa8\xa9\xaa\xab\xac\xad\xae\xaf"
// /*F0..FF*/ "\xe0\xe1\xe2\xe3\xe4\xe5\xe6\xe7\xe8\xe9\xea\xeb\xec\xed\xee\xef";

#endif  // __CLI__

//-------------------------------------------------------------------------
#ifdef __MC68__                 // MC68K, 68xxx, 68000

ANALYSIS2       = 0x37FD        // Enable 'noret' analysis

MC68K_UNSIGNED_OPS      = YES   // Immediate operands are unsigned by default

#endif // __MC68__

//-------------------------------------------------------------------------
#ifdef __MC6812__               // MC6812

TRIBYTE_ORDER           = 312   // Order of bytes for 3-byte data items
                                // Allowed values are permutations of 1,2,3
                                // 1 denotes the first byte, and so on.

#endif // __MC68__

//-------------------------------------------------------------------------
#ifdef __H8__                   // H8

NameChars =
        "$?" // no '@' character
        "_0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

#endif  // __H8__

//-------------------------------------------------------------------------
#ifdef __H8500__                // H8/500

NameChars =
        "$?" // no '@' character
        "_0123456789"
        "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
        "abcdefghijklmnopqrstuvwxyz";

H8500_MIXED_SIZE        = YES

#endif  // __H8500__

//-------------------------------------------------------------------------
#ifdef __I960__                 // Intel 960

I960_STRICT             = YES

#endif  // __H8500__

//-------------------------------------------------------------------------
#ifdef __TRIMEDIA__             // TriMedia

TRIMEDIA_PSEUDO         = NO    // Don't use pseudo instructions since
                                // the assembler doesn't understand them

TRIMEDIA_GUARD0         = NO    // Allow R0 as the guard
                                // If this option is on, IDA will disassemble instructions
                                // with R0 as the guard\

TRIMEDIA_ONENOP         = YES   // Display NOP cycle one 1 line
                                // If this option is on, IDA will display a cycle with all
                                // NOP operations on one line

//ANALYSIS                = 0x9FFF

#endif  // __TRIMEDIA__

//-------------------------------------------------------------------------
#ifdef __F2MC__                 // Fujitsu F2MC

F2MC_MACRO              = YES   // Use macro instructions

#endif  // __F2MC__

//-------------------------------------------------------------------------
#ifdef __TMS32054__             // Texas Instruments TMS320C54

TMS320C54_IO            = YES   // Use I/O definitions
TMS320C54_MMR           = YES   // Detect memory mapped registers

#endif  // __TMS32054__

//-------------------------------------------------------------------------
#ifdef __TMS32055__             // Texas Instruments TMS320C55

TMS320C55_IO            = YES   // Use I/O definitions
TMS320C55_MMR           = YES   // Detect memory mapped registers

#endif  // __TMS32055__

#endif // ____  second pass ends here
//-------------------------------------------------------------------------
//      User specific parameters
//-------------------------------------------------------------------------
//
//  If you don't want to modify IDA.CFG file then you can create a file called
//  IDAUSER.CFG and place additional parameters there.
//
//  The IDAUSER.CFG file must be placed in the IDA/CFG directory.
//
//  It will be called 2 times: in the first and second pass.
//  You can check the pass using
//      #ifdef ____
//        then it is the first pass
//      #else
//        it is the second pass
//      #endif
//
//  Some parameters must be defined in the first pass, some in the second.
//  See examples in this file.
//
#softinclude    <idauser.cfg>   // user defined macros can be
                                // defined in the 'idauser.cfg' file
                                // other parameters can be defined there too.
