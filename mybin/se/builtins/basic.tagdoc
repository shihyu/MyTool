// This documentation taken from online documentation for
// Visual Basic .NET &copy; 1998 Microsoft Corporation. All rights reserved.


/**
 * Returns the absolute value of a Decimal number.
 * @param value     A number in the range MinValue = value = MaxValue.
 * @return     A Decimal, x, such that 0 = x = MaxValue.
 *
 */
function Decimal Abs(Byval value As Decimal);



/**
 * Returns the absolute value of a double-precision floating-point number.
 *
 * <P>
 * If value is equal to NegativeInfinity or PositiveInfinity,
 * the return value is PositiveInfinity. If value is equal to NaN, the return value is NaN.
 * @param value     A number in the range MinValue < value = MaxValue.
 * @return    A double-precision floating-point number, x, such that 0 = x = MaxValue.
 *
 */
function Double Abs( Byval value As Double );

/**
 * Returns the absolute value of a 16-bit signed integer.
 *
 * @param value    A number in the range MinValue < value = MaxValue.
 * @return x    A 16-bit signed integer, x, such that 0 = x = MaxValue.
 * @exception OverflowException     value equals MinValue
 *
 */
function Short Abs( Byval value As Short );

/**
 * Returns the absolute value of a 32-bit signed integer
 *
 * @param value A number in the range MinValue < value = MaxValue
 * @return x    A 32-bit signed integer, x, such that 0 = x = MaxValue
 *
 */
function Integer Abs( Byval value As Integer );

/**
 * Returns the absolute value of a 64-bit signed integer
 *
 * @param value      A number in the range MinValue < value = MaxValue
 * @return x    A 64-bit signed integer, x, such that 0 = x = MaxValue
 *
 */
function Long Abs( Byval value As Long );


/**
 * Returns the absolute value of an 8-bit signed integer.
 *
 * @param value    A number in the range MinValue < value = MaxValue
 * @return x    An 8-bit signed integer, x, such that 0 = x = MaxValue
 *
 */
function SByte Abs( Byval value As SByte );


/**
 * Returns the absolute value of a single-precision floating-point number.
 *
 * @param value   A number in the range MinValue < value = MaxValue
 * @return x    A single-precision floating-point number, x, such that 0 = x = MaxValue
 *
 */
function Single Abs( Byval value As Single );


/**
 * Activates an application window
 *
 * <P>
 * The AppActivate function changes the focus to the named application or window,
 * but does not affect whether it is maximized or minimized. Focus moves >from
 * the activated application window when the user takes some action to change
 * the focus or close the window. Use the Shell function to start an application
 * and set the window style.
 * <P>
 * You can use AppActivate only with processes that own windows. Most console
 * applications do not own windows, which means that they do not appear in the
 * list of processes that AppActivate searches. When running from a console
 * application, the system creates a separate process to run the application
 * and returns the output to the console process. Consequently, when the
 * current Process ID is requested, you get the created process's Process ID
 * rather than the console application's Process ID.
 * <P>
 * At run time the AppActivate function activates any running application
 * whose title matches Title or whose Process ID matches ProcessID. If there is
 * no exact match, it activates any application whose title string begins with
 * Title. If there is more than one application named by Title, the AppActivate
 * function activates one at random.
 *
 *
 * @param Title    String expression specifying the title in the title bar of the application window you want to activate. You can use the task ID returned by the Shell function.
 * @param ProcessID     Integer specifying the Win32 Process ID number assigned to this process
 *
 * @exception ArgumentException    ProcessID is not found.
 *
 * @example
 * This example illustrates various uses of the AppActivate function to activate
 * an application window. The Shell procedures assume the applications are in the
 * paths specified.
 *
 * <pre>
 * Dim notepadID As Integer
 * ' Activate a running notepad process.
 *  AppActivate("Untitled - Notepad")
 * ' AppActivate can also use the return value of the Shell function.
 * ' Shell runs a new instance of notepad.
 * notepadID = Shell("C:\WINNT\NOTEPAD.EXE", AppWinStyle.MinimizedNoFocus)
 * ' Activate the new instance of notepad.
 * AppActivate(notepadID)
 * </pre>
 *
 * @see  Shell Shell Function
 */
procedure AppActivate( Byval Title As String );

/**
 * Activates an application window
 *
 * <P>
 * The AppActivate function changes the focus to the named application or window,
 * but does not affect whether it is maximized or minimized. Focus moves >from
 * the activated application window when the user takes some action to change
 * the focus or close the window. Use the Shell function to start an application
 * and set the window style.
 * <P>
 * You can use AppActivate only with processes that own windows. Most console
 * applications do not own windows, which means that they do not appear in the
 * list of processes that AppActivate searches. When running from a console
 * application, the system creates a separate process to run the application
 * and returns the output to the console process. Consequently, when the
 * current Process ID is requested, you get the created process's Process ID
 * rather than the console application's Process ID.
 * <P>
 * At run time the AppActivate function activates any running application
 * whose title matches Title or whose Process ID matches ProcessID. If there is
 * no exact match, it activates any application whose title string begins with
 * Title. If there is more than one application named by Title, the AppActivate
 * function activates one at random.
 *
 * @param Title    String expression specifying the title in the title bar of the application window you want to activate. You can use the task ID returned by the Shell function.
 * @param ProcessID     Integer specifying the Win32 Process ID number assigned to this process
 *
 * @exception ArgumentException    ProcessID is not found.
 *
 *
 * @example
 * This example illustrates various uses of the AppActivate function to activate
 * an application window. The Shell procedures assume the applications are in the
 * paths specified.
 *
 * <PRE>
 * Dim notepadID As Integer
 * ' Activate a running notepad process.
 *  AppActivate("Untitled - Notepad")
 * ' AppActivate can also use the return value of the Shell function.
 * ' Shell runs a new instance of notepad.
 * notepadID = Shell("C:\WINNT\NOTEPAD.EXE", AppWinStyle.MinimizedNoFocus)
 * ' Activate the new instance of notepad.
 * AppActivate(notepadID)
 * </PRE>
 *
 * @see Shell Shell Function
 */
procedure AppActivate( Byval ProcessID As Integer );


/**
 * Returns an Integer value representing the character code corresponding to a character
 * <P>
 * <b>Remarks</b>
 * <P>
 * Asc returns the code point, or character code, for the input character. This can
 * be 0 through 255 for single-byte character set (SBCS) values and -32768 through
 * 32767 for double-byte character set (DBCS) values. The returned value depends on
 * the code page for the current thread, which is contained in the ANSICodePage
 * property of the TextInfo class. TextInfo.ANSICodePage can be obtained by specifying
 * System.Globalization.CultureInfo.CurrentCulture.TextInfo.ANSICodePage.
 * <P>
 * AscW returns the Unicode code point for the input character. This can be 0 through
 * 65535. The returned value is independent of the culture and code page settings for
 * the current thread.
 *
 * @param String Required. Any valid Char or String expression. If String is a
 * String expression, only the first character of the string is used for input.
 * If String is Nothing or contains no characters, an ArgumentException error occurs.
 *
 * @exception ArgumentException String is not specified or is zero length.
 *
 * @example
 * This example uses the Asc function to return Integer character codes corresponding to the first letter in each string.
 * <PRE>
 * Dim MyInt As Integer
 * MyInt = Asc("A")   ' MyInt is set to 65.
 * MyInt = Asc("a")   ' MyInt is set to 97.
 * MyInt = Asc("Apple")   ' MyInt is set to 65.
 * </PRE>
 *
 * @see Chr Chr Function
 * @see ChrW  ChrW Function
 */
function Integer Asc(Byval String As Char);

/**
 * Returns an Integer value representing the character code corresponding to a character
 * <P>
 * <b>Remarks</b>
 * <P>
 * Asc returns the code point, or character code, for the input character. This can
 * be 0 through 255 for single-byte character set (SBCS) values and -32768 through
 * 32767 for double-byte character set (DBCS) values. The returned value depends on
 * the code page for the current thread, which is contained in the ANSICodePage
 * property of the TextInfo class. TextInfo.ANSICodePage can be obtained by specifying
 * System.Globalization.CultureInfo.CurrentCulture.TextInfo.ANSICodePage.
 * <P>
 * AscW returns the Unicode code point for the input character. This can be 0 through
 * 65535. The returned value is independent of the culture and code page settings for
 * the current thread.
 *
 * @param String Required. Any valid Char or String expression. If String is a
 * String expression, only the first character of the string is used for input.
 * If String is Nothing or contains no characters, an ArgumentException error occurs.
 *
 * @exception ArgumentException String is not specified or is zero length.
 *
 * @example
 * This example uses the Asc function to return Integer character codes corresponding to the first letter in each string.
 * <PRE>
 * Dim MyInt As Integer
 * MyInt = Asc("A")   ' MyInt is set to 65.
 * MyInt = Asc("a")   ' MyInt is set to 97.
 * MyInt = Asc("Apple")   ' MyInt is set to 65.
 * </PRE>
 *
 * @see Chr   Chr Function
 * @see ChrW  ChrW Function
 */
function Integer AscW(Byval String As Char);

/**
 * Returns an Integer value representing the character code corresponding to a character
 * <P>
 * <b>Remarks</b>
 * <P>
 * Asc returns the code point, or character code, for the input character. This can
 * be 0 through 255 for single-byte character set (SBCS) values and -32768 through
 * 32767 for double-byte character set (DBCS) values. The returned value depends on
 * the code page for the current thread, which is contained in the ANSICodePage
 * property of the TextInfo class. TextInfo.ANSICodePage can be obtained by specifying
 * System.Globalization.CultureInfo.CurrentCulture.TextInfo.ANSICodePage.
 * <P>
 * AscW returns the Unicode code point for the input character. This can be 0 through
 * 65535. The returned value is independent of the culture and code page settings for
 * the current thread.
 *
 * @param String Required. Any valid Char or String expression. If String is a
 * String expression, only the first character of the string is used for input.
 * If String is Nothing or contains no characters, an ArgumentException error occurs.
 *
 * @exception ArgumentException String is not specified or is zero length.
 *
 * @example
 * This example uses the Asc function to return Integer character codes corresponding to the first letter in each string.
 * <PRE>
 * Dim MyInt As Integer
 * MyInt = Asc("A")   ' MyInt is set to 65.
 * MyInt = Asc("a")   ' MyInt is set to 97.
 * MyInt = Asc("Apple")   ' MyInt is set to 65.
 * </PRE>
 *
 * @see Chr  Chr Function
 * @see ChrW ChrW Function
 */
function Integer Asc(Byval String As String);

/**
 * Returns an Integer value representing the character code corresponding to a character
 * <P>
 * <b>Remarks</b>
 * <P>
 * Asc returns the code point, or character code, for the input character. This can
 * be 0 through 255 for single-byte character set (SBCS) values and -32768 through
 * 32767 for double-byte character set (DBCS) values. The returned value depends on
 * the code page for the current thread, which is contained in the ANSICodePage
 * property of the TextInfo class. TextInfo.ANSICodePage can be obtained by specifying
 * System.Globalization.CultureInfo.CurrentCulture.TextInfo.ANSICodePage.
 * <P>
 * AscW returns the Unicode code point for the input character. This can be 0 through
 * 65535. The returned value is independent of the culture and code page settings for
 * the current thread.
 *
 * @param String Required. Any valid Char or String expression. If String is a
 * String expression, only the first character of the string is used for input.
 * If String is Nothing or contains no characters, an ArgumentException error occurs.
 *
 * @exception ArgumentException String is not specified or is zero length.
 *
 * @example
 * This example uses the Asc function to return Integer character codes corresponding to the first letter in each string.
 * <PRE>
 * Dim MyInt As Integer
 * MyInt = Asc("A")   ' MyInt is set to 65.
 * MyInt = Asc("a")   ' MyInt is set to 97.
 * MyInt = Asc("Apple")   ' MyInt is set to 65.
 * </PRE>
 *
 * @see Chr Chr Function
 * @see ChrW ChrW Function
 */
function Integer AscW(Byval String As String);

/**
 * Returns the angle whose tangent is the specified number.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 *
 * A positive return value represents a counterclockwise angle from the x-axis;
 * a negative return value represents a clockwise angle.
 * Multiply the return value by 180/p to convert from radians to degrees.
 *
 * @param d    A number representing a tangent.
 * @return q   An angle, q, measured in radians, such that -p/2 = q = p/2.
 * <P>
 *-or-
 * NaN if d equals NaN, -p/2 rounded to double precision (-1.5707963267949) if d
 * equals NegativeInfinity, or p/2 rounded to double precision (1.5707963267949)
 * if d equals PositiveInfinity.
 *
 */
function Double Atan( Byval d As Double );


/**
 * Returns the angle whose tangent is the quotient of two specified numbers.
 *
 * An angle, q, measured in radians, such that -p < q = p, and tan(q) = y/ x,
 * where (x, y) is a point in the Cartesian plane. Observe the following:
 *
 * <UL>
 * <LI>For (x, y) in quadrant 1, 0 < q < p/2.
 * <LI>For (x, y) in quadrant 2, p/2 < q = p.
 * <LI>For (x, y) in quadrant 3, -p < q < -p/2.
 * <LI>For (x, y) in quadrant 4, -p/2 < q < 0.
 * </UL>
 * <P>
 * The return value is the angle in the Cartesian plane formed by the x-axis,
 * and a vector starting from the origin, (0,0), and terminating at the point, (x,y).
 *
 * @param x   The x coordinate of a point.
 * @param y   The y coordinate of a point.
 *
 */
function Double Atan2( Byval y As Double, Byval x As Double );


/**
 * Sounds a tone through the computer's speaker.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 *
 * The pitch and duration of the beep depend on your hardware and system software,
 * and therefore vary among computers.
 *
 * @example
 * This example uses the Beep function to sound a long, uninterrupted tone through
 * the computer's speaker.
 *
 * <PRE>
 * Dim I As Integer
 * For I = 1 To 100   ' Loop 100 times.
 *  Beep   ' Sound a tone.
 * Next I
 * </PRE>
 *
 */
procedure Beep();


/**
 * Executes a method on an object, or sets or returns a property on an object.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 *
 * The CallByName function is used to get or set a property, or to invoke a method, at
 * run time, using a string to specify the name of the property or method.
 *
 * @param Object   Required. Object. A pointer to the object exposing the property or method.
 * @param ProcName  Required. String. A string expression containing the name of the property or method on the object.
 * @param UseCallType   Required. An enumeration member of type Microsoft.VisualBasic.CallType representing the type of procedure being called. The value of CallType can be Method, Get, or Set.
 * @param ParamArrayArgs()   Optional. ParamArray. A parameter array containing the arguments to be passed to the property or method being called.
 *
 * @exception ArgumentException  Invalid UseCallType value; must be Method, Get, or Set.
 *
 * @example
 * In the following example, the first line uses CallByName to set the Text property of a text box, the second line retrieves the value of the Text property, and the third line invokes the Move method to move the text box.
 *
 * <PRE>
 * Imports Microsoft.VisualBasic.CallType
 *' Imports statements must be at the top of a module.
 *...
 * Sub TestCallByName1()
 *'  Set a property.
 *  CallByName(TextBox1, "Text", CallType.Set, "New Text")
 *'  Retrieve the value of a property.
 *  MsgBox(CallByName(TextBox1, "Text", CallType.Get))
 *'  Call a method.
 *  CallByName(TextBox1, "Hide", CallType.Method)
 * End Sub
 * </PRE>
 *
 * @example
 * The next example uses the CallByName function to invoke the Add and Item methods of
 * a collection object.
 *
 * <PRE>
 * Public Sub TestCallByName2()
 * Dim col As New Collection()
 * '  Store the string "Item One" in a collection by
 * '  calling the Add method.
 * CallByName(col, "Add", CallType.Method, "Item One")
 * '  Retrieve the first entry from the collection using the
 * '  Item property and display it using MsgBox().
 * MsgBox(CallByName(col, "Item", CallType.Get, 1))
 * End Sub
 * </PRE>
 *
 */
function Object CallByName( Byval Object As System.Object, Byval ProcName As String, Byval UseCallType As CallType, Byval ParamArrayArgs() As Object );



/**
 * These functions are compiled inline, meaning the conversion code is part of the
 * code that evaluates the expression. Execution is faster because there is no call
 * to a procedure to accomplish the conversion. Each function coerces an expression
 * to a specific data type.
 *
 * <P>
 * <B>Remarks</B>
 * If the expression passed to the function is outside the range of the data type to
 * which it is being converted, an error occurs.
 * <P>
 * In general, you can use the data type conversion functions to force the result of
 * some operation to a particular data type rather than the default data type. For
 * example, use CDec to force decimal arithmetic in cases where single-precision,
 * double-precision, or integer arithmetic normally would occur.
 * <P>
 * When the fractional part is exactly 0.5, CInt and CLng always round it to the
 * nearest even number. For example, 0.5 rounds to 0 and 1.5 rounds to 2. CInt and
 * CLng differ from the Fix and Int functions, which truncate, rather than round,
 * the fractional part of a number. Also, Fix and Int always return a value of the
 * same type as is passed in.
 * <P>
 * Use the IsDate function to determine if a value can be converted to a date and
 * time. CDate recognizes date literals and time literals as well as numbers that
 * fall within the range of acceptable dates.
 * <P>
 * CDate recognizes date formats according to the locale setting of your system.
 * You must provide the day, month, and year in the correct order for your locale,
 * or the date may not be interpreted correctly. A long date format is not recognized
 * if it contains a day-of-the-week string, such as "Wednesday".
 * <P>
 * The Date data type always contains both date and time information. For purposes
 * of type conversion, Visual Basic .NET considers 1/1/1 (January 1 of the year 1)
 * to be a neutral value for the date, and 00:00:00 (midnight) to be a neutral
 * value for the time. If you convert a Date value to a string, CStr does not include
 * neutral values in the resulting string. For example, if you convert #January 1, 0001
 * 9:30:00# to a string, the result is "9:30:00 AM"; the date information is suppressed.
 * However, the date information is still present in the original Date value and can be
 * recovered with functions such as DatePart.
 * <P>
 * The CType function takes a second argument, typename, and coerces expression to
 * typename, where typename can be any data type, structure, class, or interface.
 * For more information, see CType Function.
 *
 * @param expression Required. Any String expression or numeric expression.
 *
 * @return Any valid String or numeric expression.
 *
 * @example
 * <b>CBool Example</b>
 * This example uses the CBool function to convert expressions to Boolean values.
 * If an expression evaluates to a nonzero value, CBool returns True; otherwise,
 * it returns False.
 *
 * <PRE>
 * Dim A, B, C As Integer
 * Dim Check As Boolean
 * A = 5
 * B = 5
 * Check = CBool(A = B)   ' Check is set to True.
 *' ...
 * C = 0
 * Check = CBool(C)   ' Check is set to False.
 * </PRE>
 *
 *
 * @see CType CType Function
 * @see Asc   Asc Function
 * @see AscW  AscW Function
 * @see Chr   Chr Function
 * @see ChrW  ChrW Function
 * @see Format  Format Function
 * @see Hex     Hex Function
 * @see Oct     Oct Function
 * @see Str     Str Function
 * @see Val     Val Function
 * @see DatePart  DatePart Function
 */
function Boolean CBool(expression);

/**
 * These functions are compiled inline, meaning the conversion code is part of the
 * code that evaluates the expression. Execution is faster because there is no call
 * to a procedure to accomplish the conversion. Each function coerces an expression
 * to a specific data type.
 *
 *
 * <B>Remarks</B>
 * If the expression passed to the function is outside the range of the data type to
 * which it is being converted, an error occurs.
 * <P>
 * In general, you can use the data type conversion functions to force the result of
 * some operation to a particular data type rather than the default data type. For
 * example, use CDec to force decimal arithmetic in cases where single-precision,
 * double-precision, or integer arithmetic normally would occur.
 * <P>
 * When the fractional part is exactly 0.5, CInt and CLng always round it to the
 * nearest even number. For example, 0.5 rounds to 0 and 1.5 rounds to 2. CInt and
 * CLng differ from the Fix and Int functions, which truncate, rather than round,
 * the fractional part of a number. Also, Fix and Int always return a value of the
 * same type as is passed in.
 * <P>
 * Use the IsDate function to determine if a value can be converted to a date and
 * time. CDate recognizes date literals and time literals as well as numbers that
 * fall within the range of acceptable dates.
 * <P>
 * CDate recognizes date formats according to the locale setting of your system.
 * You must provide the day, month, and year in the correct order for your locale,
 * or the date may not be interpreted correctly. A long date format is not recognized
 * if it contains a day-of-the-week string, such as "Wednesday".
 * <P>
 * The Date data type always contains both date and time information. For purposes
 * of type conversion, Visual Basic .NET considers 1/1/1 (January 1 of the year 1)
 * to be a neutral value for the date, and 00:00:00 (midnight) to be a neutral
 * value for the time. If you convert a Date value to a string, CStr does not include
 * neutral values in the resulting string. For example, if you convert #January 1, 0001
 * 9:30:00# to a string, the result is "9:30:00 AM"; the date information is suppressed.
 * However, the date information is still present in the original Date value and can be
 * recovered with functions such as DatePart.
 * <P>
 * The CType function takes a second argument, typename, and coerces expression to
 * typename, where typename can be any data type, structure, class, or interface.
 * For more information, see CType Function.
 *
 * @param expression Required. Any String expression or numeric expression.
 *
 * @return 0 through 255; fractions are rounded.
 *
 * @example
 * <b>CByte Example</b>
 * This example uses the CByte function to convert an expression to a Byte.
 *
 * <PRE>
 * Dim MyDouble As Double
 * Dim MyByte As Byte
 * MyDouble = 125.5678
 * MyByte = CByte(MyDouble)   ' MyByte is set to 126.
 * </PRE>
 *
 * @see CType CType Function
 * @see Asc   Asc Function
 * @see AscW  AscW Function
 * @see Chr   Chr Function
 * @see ChrW  ChrW Function
 * @see Format Format Function
 * @see Hex    Hex Function
 * @see Oct    Oct Function
 * @see Str    Str Function
 * @see Val    Val Function
 * @see DatePart DatePart Function
 */
function Byte CByte(expression);

/**
 * These functions are compiled inline, meaning the conversion code is part of the
 * code that evaluates the expression. Execution is faster because there is no call
 * to a procedure to accomplish the conversion. Each function coerces an expression
 * to a specific data type.
 *
 * <B>Remarks</B>
 * If the expression passed to the function is outside the range of the data type to
 * which it is being converted, an error occurs.
 * <P>
 * In general, you can use the data type conversion functions to force the result of
 * some operation to a particular data type rather than the default data type. For
 * example, use CDec to force decimal arithmetic in cases where single-precision,
 * double-precision, or integer arithmetic normally would occur.
 * <P>
 * When the fractional part is exactly 0.5, CInt and CLng always round it to the
 * nearest even number. For example, 0.5 rounds to 0 and 1.5 rounds to 2. CInt and
 * CLng differ from the Fix and Int functions, which truncate, rather than round,
 * the fractional part of a number. Also, Fix and Int always return a value of the
 * same type as is passed in.
 * <P>
 * Use the IsDate function to determine if a value can be converted to a date and
 * time. CDate recognizes date literals and time literals as well as numbers that
 * fall within the range of acceptable dates.
 * <P>
 * CDate recognizes date formats according to the locale setting of your system.
 * You must provide the day, month, and year in the correct order for your locale,
 * or the date may not be interpreted correctly. A long date format is not recognized
 * if it contains a day-of-the-week string, such as "Wednesday".
 * <P>
 * The Date data type always contains both date and time information. For purposes
 * of type conversion, Visual Basic .NET considers 1/1/1 (January 1 of the year 1)
 * to be a neutral value for the date, and 00:00:00 (midnight) to be a neutral
 * value for the time. If you convert a Date value to a string, CStr does not include
 * neutral values in the resulting string. For example, if you convert #January 1, 0001
 * 9:30:00# to a string, the result is "9:30:00 AM"; the date information is suppressed.
 * However, the date information is still present in the original Date value and can be
 * recovered with functions such as DatePart.
 * <P>
 * The CType function takes a second argument, typename, and coerces expression to
 * typename, where typename can be any data type, structure, class, or interface.
 * For more information, see CType Function.
 *
 * @param expression Required. Any String expression or numeric expression.
 *
 * @return 0 through 255; fractions are rounded.
 *
 * @example
 * <b>CChar Example</b>
 * This example uses the CChar function to convert a the first character of a
 * String expression to a Char type.
 *
 * <PRE>
 * Dim MyString As String
 * Dim MyChar As Char
 * MyString = "BCD"   ' CChar converts only first character of string.
 * MyChar = CChar(MyString)   ' MyChar is set to "B".
 * </PRE>
 *
 * The input argument to CChar must be of data type String. You cannot use CChar to convert a number to a character, because CChar cannot accept a numeric data type. This example obtains a number representing a code point (character code) and converts it to the corresponding character. It uses InputBox to obtain the string of digits, CInt to convert the string to type Integer, and ChrW to convert the number to type Char.
 *
 * <PRE>
 * Dim MyDigits As String   ' Input string of digits to be converted.
 * Dim CodePoint As Integer   ' Number to be represented as a character.
 * Dim MyChar As Char
 * MyDigits = InputBox("Enter code point of character:")
 * CodePoint = CInt(MyDigits)   ' Convert entire string to Integer.
 * MyChar = ChrW(CodePoint)   ' MyChar is set to Char value of code point.
 * </PRE>
 *
 * @see CType CType Function
 * @see Asc   Asc Function
 * @see AscW  AscW Function
 * @see Chr   Chr Function
 * @see ChrW  ChrW Function
 * @see Format Format Function
 * @see Hex    Hex Function
 * @see Oct    Oct Function
 * @see Str    Str Function
 * @see Val    Val Function
 * @see DatePart DatePart Function
 */
function Char CChar(expression);

/**
 * These functions are compiled inline, meaning the conversion code is part of the
 * code that evaluates the expression. Execution is faster because there is no call
 * to a procedure to accomplish the conversion. Each function coerces an expression
 * to a specific data type.
 *
 * <P>
 * <B>Remarks</B>
 * <P>
 * If the expression passed to the function is outside the range of the data type to
 * which it is being converted, an error occurs.
 * <P>
 * In general, you can use the data type conversion functions to force the result of
 * some operation to a particular data type rather than the default data type. For
 * example, use CDec to force decimal arithmetic in cases where single-precision,
 * double-precision, or integer arithmetic normally would occur.
 * <P>
 * When the fractional part is exactly 0.5, CInt and CLng always round it to the
 * nearest even number. For example, 0.5 rounds to 0 and 1.5 rounds to 2. CInt and
 * CLng differ from the Fix and Int functions, which truncate, rather than round,
 * the fractional part of a number. Also, Fix and Int always return a value of the
 * same type as is passed in.
 * <P>
 * Use the IsDate function to determine if a value can be converted to a date and
 * time. CDate recognizes date literals and time literals as well as numbers that
 * fall within the range of acceptable dates.
 * <P>
 * CDate recognizes date formats according to the locale setting of your system.
 * You must provide the day, month, and year in the correct order for your locale,
 * or the date may not be interpreted correctly. A long date format is not recognized
 * if it contains a day-of-the-week string, such as "Wednesday".
 * <P>
 * The Date data type always contains both date and time information. For purposes
 * of type conversion, Visual Basic .NET considers 1/1/1 (January 1 of the year 1)
 * to be a neutral value for the date, and 00:00:00 (midnight) to be a neutral
 * value for the time. If you convert a Date value to a string, CStr does not include
 * neutral values in the resulting string. For example, if you convert #January 1, 0001
 * 9:30:00# to a string, the result is "9:30:00 AM"; the date information is suppressed.
 * However, the date information is still present in the original Date value and can be
 * recovered with functions such as DatePart.
 * <P>
 * The CType function takes a second argument, typename, and coerces expression to
 * typename, where typename can be any data type, structure, class, or interface.
 * For more information, see CType Function.
 *
 * @param expression Required. Any String expression or numeric expression.
 *
 * @return Any valid representation of a date and time.
 *
 * @example
 * <B>CDate Example</B>
 * This example uses the CDate function to convert strings to Date values.
 * In general, hard-coding dates and times as strings (as shown in this example)
 * is not recommended. Use date literals and time literals, such as #Feb 12, 1969#
 * and #4:45:23 PM#, instead.
 *
 * <PRE>
 * Dim MyDateString, MyTimeString As String
 * Dim MyDate, MyTime As Date
 * MyDateString = "February 12, 1969"
 * MyTimeString = "4:35:47 PM"
 *' ...
 * MyDate = CDate(MyDateString)   ' Convert to Date data type.
 * MyTime = CDate(MyTimeString)   ' Convert to Date data type.
 * </PRE>
 *
 * @see CType CType Function
 * @see Asc   Asc Function
 * @see AscW  AscW Function
 * @see Chr   Chr Function
 * @see ChrW  ChrW Function
 * @see Format Format Function
 * @see Hex    Hex Function
 * @see Oct    Oct Function
 * @see Str    Str Function
 * @see Val    Val Function
 * @see DatePart DatePart Function
 */
function Date CDate(expression);

/**
 * These functions are compiled inline, meaning the conversion code is part of the
 * code that evaluates the expression. Execution is faster because there is no call
 * to a procedure to accomplish the conversion. Each function coerces an expression
 * to a specific data type.
 *
 * <P>
 * <B>Remarks</B>
 * <P>
 *
 * If the expression passed to the function is outside the range of the data type to
 * which it is being converted, an error occurs.
 * <P>
 * In general, you can use the data type conversion functions to force the result of
 * some operation to a particular data type rather than the default data type. For
 * example, use CDec to force decimal arithmetic in cases where single-precision,
 * double-precision, or integer arithmetic normally would occur.
 * <P>
 * When the fractional part is exactly 0.5, CInt and CLng always round it to the
 * nearest even number. For example, 0.5 rounds to 0 and 1.5 rounds to 2. CInt and
 * CLng differ from the Fix and Int functions, which truncate, rather than round,
 * the fractional part of a number. Also, Fix and Int always return a value of the
 * same type as is passed in.
 * <P>
 * Use the IsDate function to determine if a value can be converted to a date and
 * time. CDate recognizes date literals and time literals as well as numbers that
 * fall within the range of acceptable dates.
 * <P>
 * CDate recognizes date formats according to the locale setting of your system.
 * You must provide the day, month, and year in the correct order for your locale,
 * or the date may not be interpreted correctly. A long date format is not recognized
 * if it contains a day-of-the-week string, such as "Wednesday".
 * <P>
 * The Date data type always contains both date and time information. For purposes
 * of type conversion, Visual Basic .NET considers 1/1/1 (January 1 of the year 1)
 * to be a neutral value for the date, and 00:00:00 (midnight) to be a neutral
 * value for the time. If you convert a Date value to a string, CStr does not include
 * neutral values in the resulting string. For example, if you convert #January 1, 0001
 * 9:30:00# to a string, the result is "9:30:00 AM"; the date information is suppressed.
 * However, the date information is still present in the original Date value and can be
 * recovered with functions such as DatePart.
 * <P>
 * The CType function takes a second argument, typename, and coerces expression to
 * typename, where typename can be any data type, structure, class, or interface.
 * For more information, see CType Function.
 *
 * @param expression Required. Any String expression or numeric expression.
 *
 * @return -1.79769313486231E+308 through -4.94065645841247E-324
 *                     for negative values; 4.94065645841247E-324 through
 *                     1.79769313486231E+308 for positive values.
 *
 * @example
 * <b>CDbl Example</b>
 * This example uses the CDbl function to convert an expression to Double.
 *
 * <PRE>
 * Dim MyDec As Decimal
 * Dim MyDouble As Double
 * MyDec = 234.456784D    ' Literal type character D makes MyDec a Decimal.
 * MyDouble = CDbl(MyDec * 8.2D * 0.01D)   ' Convert result to a Double.
 * </PRE>
 *
 * @see CType CType Function
 * @see Asc   Asc Function
 * @see AscW  AscW Function
 * @see Chr   Chr Function
 * @see ChrW  ChrW Function
 * @see Format Format Function
 * @see Hex    Hex Function
 * @see Oct    Oct Function
 * @see Str    Str Function
 * @see Val    Val Function
 * @see DatePart DatePart Function
 */
function Double CDbl(expression);

/**
 * These functions are compiled inline, meaning the conversion code is part of the
 * code that evaluates the expression. Execution is faster because there is no call
 * to a procedure to accomplish the conversion. Each function coerces an expression
 * to a specific data type.
 *
 * <P>
 * <B>Remarks</B>
 * <P>
 *
 * If the expression passed to the function is outside the range of the data type to
 * which it is being converted, an error occurs.
 * <P>
 * In general, you can use the data type conversion functions to force the result of
 * some operation to a particular data type rather than the default data type. For
 * example, use CDec to force decimal arithmetic in cases where single-precision,
 * double-precision, or integer arithmetic normally would occur.
 * <P>
 * When the fractional part is exactly 0.5, CInt and CLng always round it to the
 * nearest even number. For example, 0.5 rounds to 0 and 1.5 rounds to 2. CInt and
 * CLng differ from the Fix and Int functions, which truncate, rather than round,
 * the fractional part of a number. Also, Fix and Int always return a value of the
 * same type as is passed in.
 * <P>
 * Use the IsDate function to determine if a value can be converted to a date and
 * time. CDate recognizes date literals and time literals as well as numbers that
 * fall within the range of acceptable dates.
 * <P>
 * CDate recognizes date formats according to the locale setting of your system.
 * You must provide the day, month, and year in the correct order for your locale,
 * or the date may not be interpreted correctly. A long date format is not recognized
 * if it contains a day-of-the-week string, such as "Wednesday".
 * <P>
 * The Date data type always contains both date and time information. For purposes
 * of type conversion, Visual Basic .NET considers 1/1/1 (January 1 of the year 1)
 * to be a neutral value for the date, and 00:00:00 (midnight) to be a neutral
 * value for the time. If you convert a Date value to a string, CStr does not include
 * neutral values in the resulting string. For example, if you convert #January 1, 0001
 * 9:30:00# to a string, the result is "9:30:00 AM"; the date information is suppressed.
 * However, the date information is still present in the original Date value and can be
 * recovered with functions such as DatePart.
 * <P>
 * The CType function takes a second argument, typename, and coerces expression to
 * typename, where typename can be any data type, structure, class, or interface.
 * For more information, see CType Function.
 *
 * @param expression Required. Any String expression or numeric expression.
 *
 * @return +/-79,228,162,514,264,337,593,543,950,335 for
 *                                zero-scaled numbers, that is, numbers with no
 *                                decimal places. For numbers with 28 decimal places,
 *                                the range is +/-7.9228162514264337593543950335.
 *                                The smallest possible non-zero number is
 *                                0.0000000000000000000000000001.
 *
 * @example
 * <b>CDec Example</b>
 * This example uses the CDec function to convert a numeric value to Decimal.
 *
 * <PRE>
 * Dim MyDouble As Double
 * Dim MyDecimal As Decimal
 * MyDouble = 10000000.0587
 * MyDecimal = CDec(MyDouble)   ' Convert to Decimal.
 * </PRE>
 *
 * @see CType CType Function
 * @see Asc   Asc Function
 * @see AscW  AscW Function
 * @see Chr   Chr Function
 * @see ChrW  ChrW Function
 * @see Format Format Function
 * @see Hex    Hex Function
 * @see Oct    Oct Function
 * @see Str    Str Function
 * @see Val    Val Function
 * @see DatePart DatePart Function
 */
function Decimal CDec(expression);

/**
 * These functions are compiled inline, meaning the conversion code is part of the
 * code that evaluates the expression. Execution is faster because there is no call
 * to a procedure to accomplish the conversion. Each function coerces an expression
 * to a specific data type.
 *
 * <P>
 * <B>Remarks</B>
 * <P>
 *
 * If the expression passed to the function is outside the range of the data type to
 * which it is being converted, an error occurs.
 * <P>
 * In general, you can use the data type conversion functions to force the result of
 * some operation to a particular data type rather than the default data type. For
 * example, use CDec to force decimal arithmetic in cases where single-precision,
 * double-precision, or integer arithmetic normally would occur.
 * <P>
 * When the fractional part is exactly 0.5, CInt and CLng always round it to the
 * nearest even number. For example, 0.5 rounds to 0 and 1.5 rounds to 2. CInt and
 * CLng differ from the Fix and Int functions, which truncate, rather than round,
 * the fractional part of a number. Also, Fix and Int always return a value of the
 * same type as is passed in.
 * <P>
 * Use the IsDate function to determine if a value can be converted to a date and
 * time. CDate recognizes date literals and time literals as well as numbers that
 * fall within the range of acceptable dates.
 * <P>
 * CDate recognizes date formats according to the locale setting of your system.
 * You must provide the day, month, and year in the correct order for your locale,
 * or the date may not be interpreted correctly. A long date format is not recognized
 * if it contains a day-of-the-week string, such as "Wednesday".
 * <P>
 * The Date data type always contains both date and time information. For purposes
 * of type conversion, Visual Basic .NET considers 1/1/1 (January 1 of the year 1)
 * to be a neutral value for the date, and 00:00:00 (midnight) to be a neutral
 * value for the time. If you convert a Date value to a string, CStr does not include
 * neutral values in the resulting string. For example, if you convert #January 1, 0001
 * 9:30:00# to a string, the result is "9:30:00 AM"; the date information is suppressed.
 * However, the date information is still present in the original Date value and can be
 * recovered with functions such as DatePart.
 * <P>
 * The CType function takes a second argument, typename, and coerces expression to
 * typename, where typename can be any data type, structure, class, or interface.
 * For more information, see CType Function.
 *
 * @param expression Required. Any String expression or numeric expression.
 *
 * @return -2,147,483,648 through 2,147,483,647; fractions are rounded.
 *
 * @example
 * <b>CInt Example</b>
 * This example uses the CInt function to convert a value to Integer.
 *
 * <PRE>
 * Dim MyDouble As Double
 * Dim MyInt As Integer
 * MyDouble = 2345.5678
 * MyInt = CInt(MyDouble)   ' MyInt is set to 2346.
 * </PRE>
 *
 * @see CType CType Function
 * @see Asc   Asc Function
 * @see AscW  AscW Function
 * @see Chr   Chr Function
 * @see ChrW  ChrW Function
 * @see Format Format Function
 * @see Hex    Hex Function
 * @see Oct    Oct Function
 * @see Str    Str Function
 * @see Val    Val Function
 * @see DatePart DatePart Function
 */
function Integer CInt(expression);

/**
 * These functions are compiled inline, meaning the conversion code is part of the
 * code that evaluates the expression. Execution is faster because there is no call
 * to a procedure to accomplish the conversion. Each function coerces an expression
 * to a specific data type.
 *
 * <P>
 * <B>Remarks</B>
 * <P>
 *
 * If the expression passed to the function is outside the range of the data type to
 * which it is being converted, an error occurs.
 * <P>
 * In general, you can use the data type conversion functions to force the result of
 * some operation to a particular data type rather than the default data type. For
 * example, use CDec to force decimal arithmetic in cases where single-precision,
 * double-precision, or integer arithmetic normally would occur.
 * <P>
 * When the fractional part is exactly 0.5, CInt and CLng always round it to the
 * nearest even number. For example, 0.5 rounds to 0 and 1.5 rounds to 2. CInt and
 * CLng differ from the Fix and Int functions, which truncate, rather than round,
 * the fractional part of a number. Also, Fix and Int always return a value of the
 * same type as is passed in.
 * <P>
 * Use the IsDate function to determine if a value can be converted to a date and
 * time. CDate recognizes date literals and time literals as well as numbers that
 * fall within the range of acceptable dates.
 * <P>
 * CDate recognizes date formats according to the locale setting of your system.
 * You must provide the day, month, and year in the correct order for your locale,
 * or the date may not be interpreted correctly. A long date format is not recognized
 * if it contains a day-of-the-week string, such as "Wednesday".
 * <P>
 * The Date data type always contains both date and time information. For purposes
 * of type conversion, Visual Basic .NET considers 1/1/1 (January 1 of the year 1)
 * to be a neutral value for the date, and 00:00:00 (midnight) to be a neutral
 * value for the time. If you convert a Date value to a string, CStr does not include
 * neutral values in the resulting string. For example, if you convert #January 1, 0001
 * 9:30:00# to a string, the result is "9:30:00 AM"; the date information is suppressed.
 * However, the date information is still present in the original Date value and can be
 * recovered with functions such as DatePart.
 * <P>
 * The CType function takes a second argument, typename, and coerces expression to
 * typename, where typename can be any data type, structure, class, or interface.
 * For more information, see CType Function.
 *
 * @param expression Required. Any String expression or numeric expression.
 *
 * @return -9,223,372,036,854,775,808 through 9,223,372,036,854,775,807; fractions are rounded.
 *
 * @example
 * <b>CLng Example</b>
 * This example uses the CLng function to convert values to Long.
 *
 * <PRE>
 * Dim MyDbl1, MyDbl2 As Double
 * Dim MyLong1, MyLong2 As Long
 * MyDbl1 = 25427.45
 * MyDbl2 = 25427.55
 * MyLong1 = CLng(MyDbl1)   ' MyLong1 contains 25427.
 * MyLong2 = CLng(MyDbl2)   ' MyLong2 contains 25428.
 * </PRE>
 *
 * @see CType CType Function
 * @see Asc   Asc Function
 * @see AscW  AscW Function
 * @see Chr   Chr Function
 * @see ChrW  ChrW Function
 * @see Format Format Function
 * @see Hex    Hex Function
 * @see Oct    Oct Function
 * @see Str    Str Function
 * @see Val    Val Function
 * @see DatePart DatePart Function
 */
function Long CLng(expression);

/**
 * These functions are compiled inline, meaning the conversion code is part of the
 * code that evaluates the expression. Execution is faster because there is no call
 * to a procedure to accomplish the conversion. Each function coerces an expression
 * to a specific data type.
 *
 * <P>
 * <B>Remarks</B>
 * <P>
 * If the expression passed to the function is outside the range of the data type to
 * which it is being converted, an error occurs.
 * <P>
 * In general, you can use the data type conversion functions to force the result of
 * some operation to a particular data type rather than the default data type. For
 * example, use CDec to force decimal arithmetic in cases where single-precision,
 * double-precision, or integer arithmetic normally would occur.
 * <P>
 * When the fractional part is exactly 0.5, CInt and CLng always round it to the
 * nearest even number. For example, 0.5 rounds to 0 and 1.5 rounds to 2. CInt and
 * CLng differ from the Fix and Int functions, which truncate, rather than round,
 * the fractional part of a number. Also, Fix and Int always return a value of the
 * same type as is passed in.
 * <P>
 * Use the IsDate function to determine if a value can be converted to a date and
 * time. CDate recognizes date literals and time literals as well as numbers that
 * fall within the range of acceptable dates.
 * <P>
 * CDate recognizes date formats according to the locale setting of your system.
 * You must provide the day, month, and year in the correct order for your locale,
 * or the date may not be interpreted correctly. A long date format is not recognized
 * if it contains a day-of-the-week string, such as "Wednesday".
 * <P>
 * The Date data type always contains both date and time information. For purposes
 * of type conversion, Visual Basic .NET considers 1/1/1 (January 1 of the year 1)
 * to be a neutral value for the date, and 00:00:00 (midnight) to be a neutral
 * value for the time. If you convert a Date value to a string, CStr does not include
 * neutral values in the resulting string. For example, if you convert #January 1, 0001
 * 9:30:00# to a string, the result is "9:30:00 AM"; the date information is suppressed.
 * However, the date information is still present in the original Date value and can be
 * recovered with functions such as DatePart.
 * <P>
 * The CType function takes a second argument, typename, and coerces expression to
 * typename, where typename can be any data type, structure, class, or interface.
 * For more information, see CType Function.
 *
 * @param expression Required. Any String expression or numeric expression.
 *
 * @return Any valid expression.
 * @example
 * <b>CObj Example</b>
 * This example uses the CObj function to convert a numeric value to Object. The Object variable itself contains only a four-byte pointer, which points to the Double value assigned to it.
 *
 * <PRE>
 * Dim MyDouble As Double
 * Dim MyObject As Object
 * MyDouble = 2.7182818284
 * MyObject = CObj(MyDouble)   ' Double value is pointed to by MyObject.
 * </PRE>
 *
 * @see CType CType Function
 * @see Asc   Asc Function
 * @see AscW  AscW Function
 * @see Chr   Chr Function
 * @see ChrW  ChrW Function
 * @see Format Format Function
 * @see Hex    Hex Function
 * @see Oct    Oct Function
 * @see Str    Str Function
 * @see Val    Val Function
 * @see DatePart DatePart Function
 */
function Object CObj(expression);

/**
 * These functions are compiled inline, meaning the conversion code is part of the
 * code that evaluates the expression. Execution is faster because there is no call
 * to a procedure to accomplish the conversion. Each function coerces an expression
 * to a specific data type.
 *
 * <P>
 * <B>Remarks</B>
 * <P>
 *
 * If the expression passed to the function is outside the range of the data type to
 * which it is being converted, an error occurs.
 * <P>
 * In general, you can use the data type conversion functions to force the result of
 * some operation to a particular data type rather than the default data type. For
 * example, use CDec to force decimal arithmetic in cases where single-precision,
 * double-precision, or integer arithmetic normally would occur.
 * <P>
 * When the fractional part is exactly 0.5, CInt and CLng always round it to the
 * nearest even number. For example, 0.5 rounds to 0 and 1.5 rounds to 2. CInt and
 * CLng differ from the Fix and Int functions, which truncate, rather than round,
 * the fractional part of a number. Also, Fix and Int always return a value of the
 * same type as is passed in.
 * <P>
 * Use the IsDate function to determine if a value can be converted to a date and
 * time. CDate recognizes date literals and time literals as well as numbers that
 * fall within the range of acceptable dates.
 * <P>
 * CDate recognizes date formats according to the locale setting of your system.
 * You must provide the day, month, and year in the correct order for your locale,
 * or the date may not be interpreted correctly. A long date format is not recognized
 * if it contains a day-of-the-week string, such as "Wednesday".
 * <P>
 * The Date data type always contains both date and time information. For purposes
 * of type conversion, Visual Basic .NET considers 1/1/1 (January 1 of the year 1)
 * to be a neutral value for the date, and 00:00:00 (midnight) to be a neutral
 * value for the time. If you convert a Date value to a string, CStr does not include
 * neutral values in the resulting string. For example, if you convert #January 1, 0001
 * 9:30:00# to a string, the result is "9:30:00 AM"; the date information is suppressed.
 * However, the date information is still present in the original Date value and can be
 * recovered with functions such as DatePart.
 * <P>
 * The CType function takes a second argument, typename, and coerces expression to
 * typename, where typename can be any data type, structure, class, or interface.
 * For more information, see CType Function.
 *
 * @param expression Required. Any String expression or numeric expression.
 *
 * @return -32,768 through 32,767; fractions are rounded.
 *
 * @example
 * <b>CShort Example</b>
 * This example uses the CShort function to convert a numeric value to Short.
 *
 * <PRE>
 * Dim MyByte as Byte
 * Dim MyShort as Short
 * MyByte = 100
 * MyShort = CShort(MyByte)   ' Convert to Short.
 * </PRE>
 *
 * @see CType CType Function
 * @see Asc   Asc Function
 * @see AscW  AscW Function
 * @see Chr   Chr Function
 * @see ChrW  ChrW Function
 * @see Format Format Function
 * @see Hex    Hex Function
 * @see Oct    Oct Function
 * @see Str    Str Function
 * @see Val    Val Function
 * @see DatePart DatePart Function
 */
function Short CShort(expression);

/**
 * These functions are compiled inline, meaning the conversion code is part of the
 * code that evaluates the expression. Execution is faster because there is no call
 * to a procedure to accomplish the conversion. Each function coerces an expression
 * to a specific data type.
 *
 * <P>
 * <B>Remarks</B>
 * <P>
 *
 * If the expression passed to the function is outside the range of the data type to
 * which it is being converted, an error occurs.
 * <P>
 * In general, you can use the data type conversion functions to force the result of
 * some operation to a particular data type rather than the default data type. For
 * example, use CDec to force decimal arithmetic in cases where single-precision,
 * double-precision, or integer arithmetic normally would occur.
 * <P>
 * When the fractional part is exactly 0.5, CInt and CLng always round it to the
 * nearest even number. For example, 0.5 rounds to 0 and 1.5 rounds to 2. CInt and
 * CLng differ from the Fix and Int functions, which truncate, rather than round,
 * the fractional part of a number. Also, Fix and Int always return a value of the
 * same type as is passed in.
 * <P>
 * Use the IsDate function to determine if a value can be converted to a date and
 * time. CDate recognizes date literals and time literals as well as numbers that
 * fall within the range of acceptable dates.
 * <P>
 * CDate recognizes date formats according to the locale setting of your system.
 * You must provide the day, month, and year in the correct order for your locale,
 * or the date may not be interpreted correctly. A long date format is not recognized
 * if it contains a day-of-the-week string, such as "Wednesday".
 * <P>
 * The Date data type always contains both date and time information. For purposes
 * of type conversion, Visual Basic .NET considers 1/1/1 (January 1 of the year 1)
 * to be a neutral value for the date, and 00:00:00 (midnight) to be a neutral
 * value for the time. If you convert a Date value to a string, CStr does not include
 * neutral values in the resulting string. For example, if you convert #January 1, 0001
 * 9:30:00# to a string, the result is "9:30:00 AM"; the date information is suppressed.
 * However, the date information is still present in the original Date value and can be
 * recovered with functions such as DatePart.
 * <P>
 * The CType function takes a second argument, typename, and coerces expression to
 * typename, where typename can be any data type, structure, class, or interface.
 * For more information, see CType Function.
 *
 * @param expression Required. Any String expression or numeric expression.
 *
 * @return -3.402823E+38 through -1.401298E-45 for negative values; 1.401298E-45 through 3.402823E+38 for positive values.
 *
 * @example
 * <b>CSng Example</b>
 * This example uses the CSng function to convert values to Single.
 *
 * <PRE>
 * Dim MyDouble1, MyDouble2 As Double
 * Dim MySingle1, MySingle2 As Single
 * MyDouble1 = 75.3421105
 * MyDouble2 = 75.3421567
 * MySingle1 = CSng(MyDouble1)   ' MySingle1 is set to 75.34211.
 * MySingle2 = CSng(MyDouble2)   ' MySingle2 is set to 75.34216.
 * </PRE>
 *
 * @see CType CType Function
 * @see Asc   Asc Function
 * @see AscW  AscW Function
 * @see Chr   Chr Function
 * @see ChrW  ChrW Function
 * @see Format Format Function
 * @see Hex    Hex Function
 * @see Oct    Oct Function
 * @see Str    Str Function
 * @see Val    Val Function
 * @see DatePart DatePart Function
 */
function Single CSng(expression);

/**
 * These functions are compiled inline, meaning the conversion code is part of the
 * code that evaluates the expression. Execution is faster because there is no call
 * to a procedure to accomplish the conversion. Each function coerces an expression
 * to a specific data type.
 *
 * <P>
 * <B>Remarks</B>
 * <P>
 *
 * If the expression passed to the function is outside the range of the data type to
 * which it is being converted, an error occurs.
 * <P>
 * In general, you can use the data type conversion functions to force the result of
 * some operation to a particular data type rather than the default data type. For
 * example, use CDec to force decimal arithmetic in cases where single-precision,
 * double-precision, or integer arithmetic normally would occur.
 * <P>
 * When the fractional part is exactly 0.5, CInt and CLng always round it to the
 * nearest even number. For example, 0.5 rounds to 0 and 1.5 rounds to 2. CInt and
 * CLng differ from the Fix and Int functions, which truncate, rather than round,
 * the fractional part of a number. Also, Fix and Int always return a value of the
 * same type as is passed in.
 * <P>
 * Use the IsDate function to determine if a value can be converted to a date and
 * time. CDate recognizes date literals and time literals as well as numbers that
 * fall within the range of acceptable dates.
 * <P>
 * CDate recognizes date formats according to the locale setting of your system.
 * You must provide the day, month, and year in the correct order for your locale,
 * or the date may not be interpreted correctly. A long date format is not recognized
 * if it contains a day-of-the-week string, such as "Wednesday".
 * <P>
 * The Date data type always contains both date and time information. For purposes
 * of type conversion, Visual Basic .NET considers 1/1/1 (January 1 of the year 1)
 * to be a neutral value for the date, and 00:00:00 (midnight) to be a neutral
 * value for the time. If you convert a Date value to a string, CStr does not include
 * neutral values in the resulting string. For example, if you convert #January 1, 0001
 * 9:30:00# to a string, the result is "9:30:00 AM"; the date information is suppressed.
 * However, the date information is still present in the original Date value and can be
 * recovered with functions such as DatePart.
 * <P>
 * The CType function takes a second argument, typename, and coerces expression to
 * typename, where typename can be any data type, structure, class, or interface.
 * For more information, see CType Function.
 *
 * @param expression Required. Any String expression or numeric expression.
 *
 * @return Returns for CStr depend on the expression argument. See Returns for CStr.
 *
 * @example
 * <b>CStr Example</b>
 * This example uses the CStr function to convert a numeric value to String.
 *
 * <PRE>
 * Dim MyDouble As Double
 * Dim MyString As String
 * MyDouble = 437.324
 * MyString = CStr(MyDouble)   ' MyString is set to "437.324".
 * </PRE>
 *
 * This example uses the CStr function to convert Date values to String values.
 *
 * <PRE>
 * Dim MyDate As Date
 * Dim MyString As String
 * ' ...
 * MyDate = #February 12, 1969 00:00:00#   ' INVALID format.
 * ' Date literals must be in the format #m/d/yyyy# or they are invalid.
 * ' ...
 * MyDate = #2/12/69 00:00:00#   ' Time is midnight.
 * ' The neutral time value of 00:00:00 is suppressed in the conversion.
 * MyString = CStr(MyDate)   ' MyString is set to "2/12/1969".
 * ' ...
 * MyDate = #2/12/69 00:00:01#   ' Time is one second past midnight.
 * ' The time component becomes part of the converted value.
 * MyString = CStr(MyDate)   ' MyString is set to "2/12/1969 12:00:01 AM".
 * </PRE>
 *
 * @see CType CType Function
 * @see Asc   Asc Function
 * @see AscW  AscW Function
 * @see Chr   Chr Function
 * @see ChrW  ChrW Function
 * @see Format Format Function
 * @see Hex    Hex Function
 * @see Oct    Oct Function
 * @see Str    Str Function
 * @see Val    Val Function
 * @see DatePart DatePart Function
 */
function String CStr(expression);

/**
 * Changes the current directory or folder.
 *
 * <P>
 * The ChDir function changes the default directory, but not the default drive.
 * For example, if the default drive is C, the following statement changes the
 * default directory on drive D, but C remains the default drive:
 *
 * <PRE>
 * ChDir "D:\TMP"
 * </PRE>
 *
 * <P>
 * Making relative directory changes is accomplished using "..", as follows:
 *
 * <P>
 * ChDir ".." ' Moves up one directory.
 *
 * @param Path  Required. A String expression that identifies which directory or
 *             folder becomes the new default directory or folder. Path may include
 *             the drive. If no drive is specified, ChDir changes the default
 *             directory or folder on the current drive.
 *
 * @exception ArgumentException        Path is empty.
 * @exception FileNotFoundException    Invalid drive is specified, or drive is unavailable.
 *
 * @example
 * This example uses the ChDir function to change the current directory or folder.
 * <PRE>
 *' Change current directory or folder to "MYDIR".
 * ChDir("MYDIR")
 *
 *' Assume "C:" is the current drive. The following statement changes
 *' the default directory on drive "D:". "C:" remains the current drive.
 * ChDir("D:\WINDOWS\SYSTEM")
 * </PRE>
 *
 * @see ChDrive  ChDrive Function
 * @see CurDir   CurDir Function
 * @see Dir      Dir Function
 * @see MkDir    MkDir Function
 * @see RmDir    RmDir Function
 */
procedure ChDir(Byval Path As String);

/**
 * Changes the current drive.
 *
 * @param Drive   Required. String expression that specifies an existing drive. If
 *               you supply a zero-length string (""), the current drive doesn't
 *               change. If the Drive argument is a multiple-character string,
 *               ChDrive uses only the first letter.
 *
 * @exception IOException Invalid drive is specified, or drive is unavailable.
 *
 * @example
 * This example uses the ChDrive function to change the current drive.
 *
 * <PRE>
 * ChDrive("D")   ' Make "D" the current drive.
 * </PRE>
 *
 * @see ChDir Function
 * @see CurDir Function
 * @see MkDir Function
 * @see RmDir Function
 * @see IOException
 */
procedure ChDrive(Byval Drive As Char );

/**
 * Changes the current drive.
 *
 * @param Drive   Required. String expression that specifies an existing drive. If
 *               you supply a zero-length string (""), the current drive doesn't
 *               change. If the Drive argument is a multiple-character string,
 *               ChDrive uses only the first letter.
 *
 * @exception IOException Invalid drive is specified, or drive is unavailable.
 *
 * @example
 * This example uses the ChDrive function to change the current drive.
 *
 * <PRE>
 * ChDrive("D")   ' Make "D" the current drive.
 * </PRE>
 *
 * @see ChDir ChDir Function
 * @see CurDir CurDir Function
 * @see MkDir MkDir Function
 * @see RmDir RmDir Function
 */
procedure ChDrive(Byval Drive As String );

/**
 * Selects and returns a value from a list of arguments.
 *
 * @param  Index     Required. Double. Numeric expression that results in a value
 *                  between 1 and the number of elements passed in the Choice argument.
 * @param  Choice()  Required. Object parameter array. You can supply either a
 *                  single variable or an expression that evaluates to the Object
 *                  data type, to a list of Object variables or expressions separated
 *                  by commas, or to a single-dimensional array of Object elements.
 *
 * @exception  ArgumentException  Rank of Choice() <> 1.
 *
 * @example
 * This example uses the Choose function to display a name in response to an index
 * passed into the procedure in the Ind parameter.
 *
 * <PRE>
 * Function GetChoice(Ind As Integer) As String
 * GetChoice = CStr(Choose(Ind, "Speedy", "United", "Federal"))
 * End Function
 * </PRE>
 *
 * @see IIf IIf Function
 * @see Switch Switch Function
 */
function Object Choose( Byval Index As Double,  Byval ParamArray Choice() As Object );

/**
 * Returns the character associated with the specified character code.
 *
 * <P>
 * The asymmetric range accepted for CharCode compensates for the storage differences
 * between the Short and Integer data types. For example, &H8E01 is -29183 as a Short
 * but +36353 as an Integer. This also facilitates compatibility with Visual Basic 6.0.
 *
 * <P>
 * Chr uses the Encoding class in the System.Text namespace to determine if the current
 * thread is using a single-byte character set (SBCS) or a double-byte character set
 *(DBCS). It then takes CharCode as a code point in the appropriate set. The range can
 * be 0 through 255 for SBCS characters and -32768 through 65535 for DBCS characters.
 * The returned character depends on the code page for the current thread, which is
 * contained in the ANSICodePage property of the TextInfo class. TextInfo.ANSICodePage
 * can be obtained by specifying
 * System.Globalization.CultureInfo.CurrentCulture.TextInfo.ANSICodePage.
 *
 * <P>
 * ChrW takes CharCode as a Unicode code point. The range is independent of the culture
 * and code page settings for the current thread. Values from -32768 through -1 are
 * treated the same as values in the range +32768 through +65535.
 *
 * <P>
 * Numbers from 0 through 31 are the same as standard, nonprintable ASCII codes. For
 * example, Chr(10) returns a linefeed character.
 *
 * @param CharCode  Required. An Integer expression representing the code point, or
 *                 character code, for the character. If CharCode is outside the
 *                 range -32768 through 65535, an ArgumentException error occurs.
 *
 * @exception ArgumentException   CharCode < -32768 or > 65535.
 *
 * @example
 * This example uses the Chr function to return the character associated with the
 * specified character code.
 *
 * <PRE>
 * Dim MyChar As Char
 * MyChar = Chr(65)   ' Returns "A".
 * MyChar = Chr(97)   ' Returns "a".
 * MyChar = Chr(62)   ' Returns ">".
 * MyChar = Chr(37)   ' Returns "%".
 * </PRE>
 *
 * @see Asc Asc Function
 * @see AscW AscW Function
 * @see Str  Str Function
 */
function Char Chr(Byval CharCode As Integer);

/**
 * Returns the character associated with the specified character code.
 *
 * <P>
 * The asymmetric range accepted for CharCode compensates for the storage differences
 * between the Short and Integer data types. For example, &H8E01 is -29183 as a Short
 * but +36353 as an Integer. This also facilitates compatibility with Visual Basic 6.0.
 *
 * <P>
 * Chr uses the Encoding class in the System.Text namespace to determine if the current
 * thread is using a single-byte character set (SBCS) or a double-byte character set
 *(DBCS). It then takes CharCode as a code point in the appropriate set. The range can
 * be 0 through 255 for SBCS characters and -32768 through 65535 for DBCS characters.
 * The returned character depends on the code page for the current thread, which is
 * contained in the ANSICodePage property of the TextInfo class. TextInfo.ANSICodePage
 * can be obtained by specifying
 * System.Globalization.CultureInfo.CurrentCulture.TextInfo.ANSICodePage.
 *
 * <P>
 * ChrW takes CharCode as a Unicode code point. The range is independent of the culture
 * and code page settings for the current thread. Values from -32768 through -1 are
 * treated the same as values in the range +32768 through +65535.
 *
 * <P>
 * Numbers from 0 through 31 are the same as standard, nonprintable ASCII codes. For
 * example, Chr(10) returns a linefeed character.
 *
 * @param CharCode  Required. An Integer expression representing the code point, or
 *                 character code, for the character. If CharCode is outside the
 *                 range -32768 through 65535, an ArgumentException error occurs.
 *
 * @exception ArgumentException   CharCode < -32768 or > 65535.
 *
 * @example
 * This example uses the Chr function to return the character associated with the
 * specified character code.
 *
 * <PRE>
 * Dim MyChar As Char
 * MyChar = Chr(65)   ' Returns "A".
 * MyChar = Chr(97)   ' Returns "a".
 * MyChar = Chr(62)   ' Returns ">".
 * MyChar = Chr(37)   ' Returns "%".
 * </PRE>
 *
 * @see Asc Asc Function
 * @see AscW AscW Function
 * @see Str  Str Function
 */
function Char ChrW(Byval CharCode As Integer);

/**
 * Returns the argument portion of the command line used to launch Visual Basic
 * or an executable program developed with Visual Basic.
 *
 * For applications developed with Visual Basic and compiled to an .exe file,
 * the Command function returns any arguments that appear after the name of
 * the application on the command line, as in this example:
 *
 * MyApp cmdlineargs
 *
 * @example
 * This example uses the Command function to get the command-line arguments in a
 * function that returns them in an object containing an array.
 *
 * <PRE>
 * Function GetCommandLineArgs() As String()
 *' Declare variables.
 * Dim separators As String = " "
 * Dim commands As String = Microsoft.VisualBasic.Command()
 * Dim args() As String = commands.Split(separators.ToCharArray)Return args
 * End Function
 * </PRE>
 *
 */
function String Command();

/**
 * Returns the cosine of the specified angle.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 *
 * The angle, d, must be in radians. Multiply by p/180 to convert degrees to radians.
 *
 * @param  d   An angle, measured in radians.
 * @return The cosine of d.
 *
 */
function Double Cos( Byval d As Double );

/**
 * Creates and returns a reference to a COM object. CreateObject cannot be used to
 * create instances of classes in Visual Basic unless those classes are explicitly
 * exposed as COM components.
 * <P>
 * To create an instance of a COM component, assign the object returned by CreateObject
 * to an object variable:
 *
 * <PRE>
 * xlApp = CreateObject("Excel.Application")
 * </PRE>
 * <P>
 * The type of object variable you use to store the returned object can affect your
 * applications performance. Declaring an object variable with the As Object clause
 * creates a variable that can contain a reference to any type of object. However,
 * access to the object through that variable is late bound; that is, the binding
 * occurs when your program is run. There are a lot of reasons why you should avoid
 * late binding, including slower application performance. To create an object variable
 * that results in early binding, that is, binding when the program is compiled, add a
 * reference to the type library for your object from the COM tab of the Add Reference
 * dialog box on the Project menu and declare the object variable of the specific type
 * of your object. For example, you can declare and create the following Microsoft
 * Excel references:
 *
 * <PRE>
 * Dim xlApp As Excel.Application
 * Dim xlBook As Excel.Workbook
 * Dim xlSheet As Excel.WorkSheet
 * xlApp = CreateObject("Excel.Application")
 * </PRE>
 * <P>
 * The reference through an early-bound variable can give better performance, but can
 * only contain a reference to the class specified in the declaration.
 * <P>
 * Another issue is that COM objects use unmanaged code  code without the benefit of
 * the common language runtime. There is a fair degree of complexity involved in
 * mixing the managed code of Visual Basic .NET with unmanaged code from COM. When
 * you add a reference to a COM object, a search is made for a predefined
 * interoperability assembly for that library; if one is found then it is used. If
 * none is found you have the option of creating a local interoperability assembly
 * that contains local interoperability classes for each class in the COM library.
 *  <P>
 * You can create an object on a remote networked computer by passing the name of
 * the computer to the ServerName argument of CreateObject. That name is the same
 * as the Machine Name portion of a share name: for a share named "\\MyServer\Public,"
 * ServerName is "MyServer."
 * <P>
 * Note   Refer to COM documentation (see Microsoft Developer Network) for additional
 * information on making an application visible on a remote networked computer. You
 * may have to add a registry key for your application.
 * <P>
 * The following code returns the version number of an instance of Excel running on
 * a remote computer named MyServer:
 *
 * <PRE>
 * Dim xlApp As Object
 * ' Replace string "\\MyServer" with name of the remote computer.
 * xlApp = CreateObject("Excel.Application", "\\MyServer")
 * MsgBox(xlApp.Version)
 * </PRE>
 *  <P>
 * If the remote server name is incorrect, or if it is unavailable, a run-time error
 * occurs.
 * <P>
 * Note   Use CreateObject when there is no current instance of the object. If an
 * instance of the object is already running, a new instance is started, and an
 * object of the specified type is created. To use the current instance, or to start
 * the application and have it load a file, use the GetObject function. If an object
 * has registered itself as a single-instance object, only one instance of the object
 * is created, no matter how many times CreateObject is executed.
 *
 *
 * @param ProgId  Required. String. The program ID of the object to create.
 * @param ServerName  Optional. String. The name of the network server where the
 *                   object will be created. If ServerName is an empty string (""),
 *                   the local machine is used.
 *
 * @exception Exception              ProgId not found or not supplied.
 * @exception Exception              Server is unavailable
 * @exception FileNotFoundException  No object of the specified type exists.
 *
 * @example
 * This example uses the CreateObject function to set a reference (xlApp) to Microsoft
 * Excel. It uses the reference to access the Visible property of Microsoft Excel, and
 * then uses the Microsoft Excel Quit method to close it. Finally, the reference itself
 * is released.
 *
 * <PRE>
 * Sub TestExcel()
 *   Dim xlApp As Excel.Application
 *  Dim xlBook As Excel.Workbook
 *  Dim xlSheet As Excel.Worksheet
 *  xlApp = CType(CreateObject("Excel.Application"), Excel.Application)
 *  xlBook = CType(xlApp.Workbooks.Add, Excel.Workbook)
 *  xlSheet = CType(xlBook.Worksheets(1), Excel.Worksheet)
 *  ' Place some text in the second row of the sheet.
 *  xlSheet.Activate()
 *  xlSheet.Cells(2, 2) = "This is column B row 2"
 *  ' Show the sheet.
 *  xlSheet.Application.Visible = True
 *  ' Save the sheet to C:\test.xls directory.
 *  xlSheet.SaveAs("C:\Test.xls")
 *  ' Optionally, you can call xlApp.Quit to close the work sheet.
 * End Sub
 * </PRE>
 *
 * @see GetObject GetObject Function
 */
function Object CreateObject( Byval ProgId As String, Optional Byval ServerName As String = "" );

/**
 * Returns the result of explicitly converting an expression to
 * a specified data type, object, structure, class, or interface.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 *
 * CType is compiled inline, meaning the conversion code is part of the code that
 * evaluates the expression. Execution is faster because there is no call to a
 * procedure to accomplish the conversion.
 *
 * @param expression   Any valid expression. If the value of expression is outside
 *                    the range allowed by typename, an error occurs.
 *
 * @param typename     Any expression that is legal within an As clause in a Dim
 *                    statement, that is, the name of any data type, object, structure,
 *                    class, or interface.
 *
 * @example
 * This example uses the CType function to convert an expression to the specified
 * data type.
 *
 * <PRE>
 * Dim MyNumber As Long
 * Dim MyNewType As Single
 * MyNumber = 1000
 * MyNewType = CType(MyNumber,Single)   ' MyNewType is set to 1000.0.
 * </PRE>
 *
 */
function CType(expression, typename);

/**
 * Returns a string representing the current path.
 *
 * @param Drive   Optional. String expression that specifies an existing drive. If no
 *               drive is specified, or if Drive is a zero-length string (""),
 *               CurDir returns the path for the current drive.
 *
 * @exception IOException  Drive is not found.
 * @exception ArgumentException  Invalid Drive is specified.
 *
 * @example
 * This example uses the CurDir function to return the current path.
 *
 * <PRE>
 * ' Assume current path on C drive is "C:\WINDOWS\SYSTEM".
 * ' Assume current path on D drive is "D:\EXCEL".
 * ' Assume C is the current drive.
 * Dim MyPath As String
 * MyPath = CurDir()   ' Returns "C:\WINDOWS\SYSTEM".
 * MyPath = CurDir("C")   ' Returns "C:\WINDOWS\SYSTEM".
 * MyPath = CurDir("D")   ' Returns "D:\EXCEL".
 * </PRE>
 *
 * @see ChDir ChDir Function
 * @see ChDrive ChDrive Function
 * @see MkDir MkDir Function
 * @see RmDir RmDir Function
 */
function String CurDir([ Byval Drive As Char ]);

/**
 * Returns a Date value containing a date and time value to which a specified
 * time interval has been added.
 *
 * <P>
 * <B>Settings</b>
 * <P>
 * The Interval argument can have one of the following settings.
 * <P>
 *
 * <PRE>
 * Enumeration value     String  Unit of time interval to add
 * DateInterval.Day        d     Day; truncated to integral value
 * DateInterval.DayOfYear  y     Day; truncated to integral value
 * DateInterval.Hour       h     Hour; rounded to nearest millisecond
 * DateInterval.Minute     n     Minute; rounded to nearest millisecond
 * DateInterval.Month      m     Month; truncated to integral value
 * DateInterval.Quarter    q     Quarter; truncated to integral value
 * DateInterval.Second     s     Second; rounded to nearest millisecond
 * DateInterval.Weekday    w     Day; truncated to integral value
 * DateInterval.WeekOfYear ww    Week; truncated to integral value
 * DateInterval.Year       yyyy  Year; truncated to integral value
 * </PRE>
 *
 * <P>
 * You can use the DateAdd function to add or subtract a specified time
 * interval from a date. For example, you can calculate a date 30 days
 * from today or a time 45 minutes before now.
 * <P>
 * To add days to DateValue, you can use DateInterval.Day, DateInterval.DayOfYear,
 * or DateInterval.Weekday. These are treated as equivalent because DayOfYear and
 * Weekday are not meaningful time intervals.
 * <P>
 * The DateAdd function never returns an invalid date. If necessary, the day part
 * of the resulting date is adjusted downward to the last day of the resulting month
 * in the resulting year. The following example adds one month to January 31:
 * <P>
 * Dim NextMonth As Date = DateAdd(DateInterval.Month, 1, #1/31/1995#)
 * In this example, DateAdd returns #2/28/1995#, not #2/31/1995#. If DateValue is
 * #1/31/1996#, it returns #2/29/1996# because 1996 is a leap year.
 * <P>
 * If any argument has an invalid value, an ArgumentException error occurs. If the
 * calculated date is earlier than 00:00:00 on January 1 of the year 1, or later
 * than 23:59:59 on December 31, 9999, an ArgumentOutOfRangeException error occurs.
 * If the DateValue argument has a value that cannot be coerced to a valid Date value,
 * an InvalidCastException error occurs.
 * <P>
 * Note   DateAdd uses the current calendar setting from the CurrentCulture property
 * of the CultureInfo class in the System.Globalization namespace. The default
 * CurrentCulture values are determined by Control Panel settings.
 * <P>
 * Since every Date value is supported by a DateTime structure, its methods give you
 * additional options in adding time intervals. For example, you can add a fractional
 * number of days, rounded to the nearest millisecond, to a Date variable as follows:
 *
 * <PRE>
 * Dim NextTime As Date = Now        ' Current date and time.
 * NextTime = NextTime.AddDays(3.4)  ' Increment by 3 2/5 days.
 * </PRE>
 *
 *
 *
 * @param Interval   Required. DateInterval enumeration value or String expression
 *                  representing the time interval you want to add.
 *
 * @param Number     Required. Double. Floating-point expression representing the
 *                  number of intervals you want to add. Number can be positive
 *                  (to get date/time values in the future) or negative (to get
 *                  date/time values in the past). It can contain a fractional
 *                  part when Interval specifies hours, minutes, or seconds. For
 *                  other values of Interval, any fractional part of Number is ignored.
 *
 * @param DateValue  Required. Date. An expression representing the date and time
 *                  to which the interval is to be added. DateValue itself is not
 *                  changed in the calling program.
 *
 * @exception InvalidCastException  DateValue is not coercible to Date.
 * @exception ArgumentException     Interval is invalid.
 * @exception ArgumentOutOfRangeException  Calculated date is before 00:00:00 on
 *                                        January 1 of the year 1, or later than
 *                                        23:59:59 on December 31, 9999.
 *
 * @example
 * This example takes a date and, using the DateAdd function, displays a corresponding date a specified number of months in the future.
 *
 * <PRE>
 * Dim Msg, Number, StartDate As String   'Declare variables.
 * Dim Months As Double
 * Dim SecondDate As Date
 * Dim IntervalType As DateInterval
 * IntervalType = DateInterval.Month   ' Specifies months as interval.
 * StartDate = InputBox("Enter a date")
 * SecondDate = CDate(StartDate)
 * Number = InputBox("Enter number of months to add")
 * Months = Val(Number)
 * Msg = "New date: " & DateAdd(IntervalType, Months, SecondDate)
 * MsgBox (Msg)
 * </PRE>
 *
 * @see DateDiff  DateDiff Function
 * @see DatePart  DatePart Function
 * @see Day       Day Function
 * @see Format    Format Function
 * @see Weekday   Weekday Function
 * @see Year      Year Function
 */
function DateTime DateAdd(Byval Interval As DateInterval,
                          Byval Number As Double,
                          Byval DateValue As DateTime);

/**
 * Returns a Date value containing a date and time value to which a specified
 * time interval has been added.
 *
 * <P>
 * <B>Settings</b>
 * <P>
 * The Interval argument can have one of the following settings.
 *
 *
 * <PRE>
 * Enumeration value     String  Unit of time interval to add
 * DateInterval.Day        d     Day; truncated to integral value
 * DateInterval.DayOfYear  y     Day; truncated to integral value
 * DateInterval.Hour       h     Hour; rounded to nearest millisecond
 * DateInterval.Minute     n     Minute; rounded to nearest millisecond
 * DateInterval.Month      m     Month; truncated to integral value
 * DateInterval.Quarter    q     Quarter; truncated to integral value
 * DateInterval.Second     s     Second; rounded to nearest millisecond
 * DateInterval.Weekday    w     Day; truncated to integral value
 * DateInterval.WeekOfYear ww    Week; truncated to integral value
 * DateInterval.Year       yyyy  Year; truncated to integral value
 * </PRE>
 *
 * <P>
 * You can use the DateAdd function to add or subtract a specified time
 * interval from a date. For example, you can calculate a date 30 days
 * from today or a time 45 minutes before now.
 * <P>
 * To add days to DateValue, you can use DateInterval.Day, DateInterval.DayOfYear,
 * or DateInterval.Weekday. These are treated as equivalent because DayOfYear and
 * Weekday are not meaningful time intervals.
 * <P>
 * The DateAdd function never returns an invalid date. If necessary, the day part
 * of the resulting date is adjusted downward to the last day of the resulting month
 * in the resulting year. The following example adds one month to January 31:
 * <P>
 * Dim NextMonth As Date = DateAdd(DateInterval.Month, 1, #1/31/1995#)
 * In this example, DateAdd returns #2/28/1995#, not #2/31/1995#. If DateValue is
 * #1/31/1996#, it returns #2/29/1996# because 1996 is a leap year.
 * <P>
 * If any argument has an invalid value, an ArgumentException error occurs. If the
 * calculated date is earlier than 00:00:00 on January 1 of the year 1, or later
 * than 23:59:59 on December 31, 9999, an ArgumentOutOfRangeException error occurs.
 * If the DateValue argument has a value that cannot be coerced to a valid Date value,
 * an InvalidCastException error occurs.
 * <P>
 * Note   DateAdd uses the current calendar setting from the CurrentCulture property
 * of the CultureInfo class in the System.Globalization namespace. The default
 * CurrentCulture values are determined by Control Panel settings.
 * <P>
 * Since every Date value is supported by a DateTime structure, its methods give you
 * additional options in adding time intervals. For example, you can add a fractional
 * number of days, rounded to the nearest millisecond, to a Date variable as follows:
 * <PRE>
 * Dim NextTime As Date = Now        ' Current date and time.
 * NextTime = NextTime.AddDays(3.4)  ' Increment by 3 2/5 days.
 * </PRE>
 *
 *
 * @param Interval   Required. DateInterval enumeration value or String expression
 *                  representing the time interval you want to add.
 *
 * @param Number     Required. Double. Floating-point expression representing the
 *                  number of intervals you want to add. Number can be positive
 *                  (to get date/time values in the future) or negative (to get
 *                  date/time values in the past). It can contain a fractional
 *                  part when Interval specifies hours, minutes, or seconds. For
 *                  other values of Interval, any fractional part of Number is ignored.
 *
 * @param DateValue  Required. Date. An expression representing the date and time
 *                  to which the interval is to be added. DateValue itself is not
 *                  changed in the calling program.
 *
 * @exception InvalidCastException  DateValue is not coercible to Date.
 * @exception ArgumentException     Interval is invalid.
 * @exception ArgumentOutOfRangeException  Calculated date is before 00:00:00 on
 *                                        January 1 of the year 1, or later than
 *                                        23:59:59 on December 31, 9999.
 *
 *
 *
 * @example
 * This example takes a date and, using the DateAdd function, displays a corresponding date a specified number of months in the future.
 *
 * <PRE>
 * Dim Msg, Number, StartDate As String   'Declare variables.
 * Dim Months As Double
 * Dim SecondDate As Date
 * Dim IntervalType As DateInterval
 * IntervalType = DateInterval.Month   ' Specifies months as interval.
 * StartDate = InputBox("Enter a date")
 * SecondDate = CDate(StartDate)
 * Number = InputBox("Enter number of months to add")
 * Months = Val(Number)
 * Msg = "New date: " & DateAdd(IntervalType, Months, SecondDate)
 * MsgBox (Msg)
 * </PRE>
 *
 * @see DateDiff DateDiff Function
 * @see DatePart DatePart Function
 * @see Day      Day Function
 * @see Format   Format Function
 * @see Weekday  Weekday Function
 * @see Year     Year Function
 */
function DateTime DateAdd(Byval Interval As String,
                          Byval Number As Double,
                          Byval DateValue As Object);

/**
 * Returns a Long value specifying the number of time intervals between two Date values.
 *
 * <P>
 * <B>Settings</B>
 * <P>
 *
 * The Interval argument can have one of the following settings.
 *
 * <PRE>
 * Enumeration value        String  Unit of time difference
 * DateInterval.Day           d          Day
 * DateInterval.DayOfYear     y          Day
 * DateInterval.Hour          h          Hour
 * DateInterval.Minute        n          Minute
 * DateInterval.Month         m          Month
 * DateInterval.Quarter       q          Quarter
 * DateInterval.Second        s          Second
 * DateInterval.Weekday       w          Week
 * DateInterval.WeekOfYear    ww         Calendar week
 * DateInterval.Year         yyyy        Year
 * </PRE>
 *
 * <P>
 * The DayOfWeek argument can have one of the following settings.
 *
 * <PRE>
 * Enumeration value         Value  Description
 * FirstDayOfWeek.System       0       First day of week specified in system settings
 * FirstDayOfWeek.Sunday       1       Sunday (default)
 * FirstDayOfWeek.Monday       2       Monday (complies with ISO standard 8601, section 3.17)
 * FirstDayOfWeek.Tuesday      3       Tuesday
 * FirstDayOfWeek.Wednesday    4       Wednesday
 * FirstDayOfWeek.Thursday     5       Thursday
 * FirstDayOfWeek.Friday       6       Friday
 * FirstDayOfWeek.Saturday     7       Saturday
 * </PRE>
 *
 * <P>
 * The WeekOfYear argument can have one of the following settings.
 *
 * <pre>
 * Enumeration value            Value  Description
 * FirstWeekOfYear.System         0    First week of year specified in system settings
 * FirstWeekOfYear.Jan1           1    Week in which January 1 occurs (default)
 * FirstWeekOfYear.FirstFourDays  2    Week that has at least four days in the new year (complies with ISO standard 8601, section 3.17)
 * FirstWeekOfYear.FirstFullWeek  3    First full week in the new year
 * </pre>
 *
 * @exception ArgumentException   Invalid Interval.
 * @exception ArgumentException   Date or DayofWeek are out of range.
 * @exception InvalidCastException   Date1 or Date2 are invalid types.
 *
 * You can use the DateDiff function to determine how many specified time intervals
 * exist between two date/time values. For example, you might use DateDiff to calculate
 * the number of days between two dates, or the number of weeks between today and the
 * end of the year.
 *
 * If Interval is set to DateInterval.DayOfYear, it is treated the same as
 * DateInterval.Day, because DayOfYear is not a meaningful unit for a time interval.
 *
 * If Interval is set to DateInterval.WeekOfYear, the return value represents the
 * number of weeks between the first day of the week containing Date1 and the first
 * day of the week containing Date2. The following example shows how this produces
 * different results from DateInterval.Weekday.
 *
 * <PRE>
 * Dim DatTim1 As Date = #1/4/2001#   ' This is a Thursday.
 * Dim DatTim2 As Date = #1/9/2001#   ' This is the next Tuesday.
 * ' Assume Sunday is specified as first day of the week.
 * Dim WD As Long = DateDiff(DateInterval.Weekday, DatTim1, DatTim2)
 * Dim WY As Long = DateDiff(DateInterval.WeekOfYear, DatTim1, DatTim2)
 * </PRE>
 *
 * In the preceding example, DateDiff returns 0 to WD because the difference between
 * the two dates is less than seven days, but it returns 1 to WY because there is a
 * seven-day difference between the first days of the respective calendar weeks.
 *
 * If Interval is set to DateInterval.Year, the return value is calculated purely from
 * the year parts of Date1 and Date2.
 *
 * Because Date1 and Date2 are of the Date data type, they hold date and time values
 * accurate to 100-nanosecond ticks on the system timer. However, DateDiff always
 * returns the number of time intervals as a Long value.
 *
 * If Date1 represents a later date and time than Date2, DateDiff returns a negative number.
 *
 * If any argument has an invalid value, an ArgumentException error occurs. If either
 * the Date1 or Date2 argument has a value that cannot be coerced to a valid Date value,
 * an InvalidCastException error occurs.
 *
 * Note   When comparing December 31 to January 1 of the following year, DateDiff
 * returns 1 for DateInterval.Year, DateInterval.Quarter, or DateInterval.Month, even
 * though only one day has elapsed.
 *
 * Since every Date value is supported by a DateTime structure, its methods give you
 * additional options in finding time intervals. For example, you can use the Subtract
 * method in either of its overloaded forms. One of these subtracts a TimeSpan from a
 * Date variable to return another Date value; the other subtracts a Date value to return
 * a TimeSpan. You can time a process to find out how many milliseconds it takes, as
 * follows:
 *
 * <PRE>
 * Dim StartTime As Date = Now   ' Starting date/time.
 * ' Run the process that is to be timed.
 * Dim RunLength As System.TimeSpan = Now.Subtract(StartTime)
 * Dim Millisecs As Integer = RunLength.Milliseconds
 * </PRE>
 *
 *
 *
 * @param Interval    Required. DateInterval enumeration value or String expression
 *                   representing the time interval you want to use as the unit of
 *                   difference between Date1 and Date2.
 *
 * @param Date1       Required. Date. The two date/time values you want to use in the
 *                   calculation. The value of Date1 is subtracted from the value of
 *                   Date2 to produce the difference. Neither value is changed in the
 *                   calling program.
 *
 * @param Date2       Required. Date. The two date/time values you want to use in the
 *                   calculation. The value of Date1 is subtracted from the value of
 *                   Date2 to produce the difference. Neither value is changed in the
 *                   calling program.
 *
 * @param DayOfWeek   Optional. A value chosen from the FirstDayOfWeek enumeration that
 *                   specifies the first day of the week. If not specified,
 *                   FirstDayOfWeek.Sunday is used.
 *
 * @param WeekOfYear  Optional. A value chosen from the FirstWeekOfYear enumeration that
 *                   specifies the first week of the year. If not specified,
 *                   FirstWeekOfYear.Jan1 is used.
 *
 *
 * @example
 * This example uses the DateDiff function to display the number of days between a
 * given date and today.
 *
 * <PRE>
 * Dim FirstDate, Msg As String   ' Declare variables.
 * Dim SecondDate As Date
 * FirstDate = InputBox("Enter a date")
 * SecondDate = CDate(FirstDate)
 * Msg = "Days from today: " & DateDiff(DateInterval.Day, Now, SecondDate)
 * MsgBox (Msg)
 * </PRE>
 *
 * @see DateAdd DateAdd Function
 * @see DatePart DatePart Function
 * @see Day      Day Function
 * @see Format   Format Function
 * @see Weekday  Weekday Function
 * @see Year     Year Function
 */
function Long DateDiff(Byval Interval As DateInterval,
                       Byval Date1 As DateTime,
                       Byval Date2 As DateTime,
                       Optional Byval DayOfWeek As FirstDayOfWeek = FirstDayOfWeek.Sunday,
                       Optional Byval  WeekOfYear As FirstWeekOfYear = FirstWeekOfYear.Jan1);

/**
 * Returns a Long value specifying the number of time intervals between two Date values.
 *
 * <P>
 * <B>Settings</B>
 * <P>
 *
 * The Interval argument can have one of the following settings.
 *
 * <PRE>
 * Enumeration value        String  Unit of time difference
 * DateInterval.Day           d          Day
 * DateInterval.DayOfYear     y          Day
 * DateInterval.Hour          h          Hour
 * DateInterval.Minute        n          Minute
 * DateInterval.Month         m          Month
 * DateInterval.Quarter       q          Quarter
 * DateInterval.Second        s          Second
 * DateInterval.Weekday       w          Week
 * DateInterval.WeekOfYear    ww         Calendar week
 * DateInterval.Year         yyyy        Year
 * </PRE>
 *
 * <P>
 * The DayOfWeek argument can have one of the following settings.
 *
 * <PRE>
 * Enumeration value         Value  Description
 * FirstDayOfWeek.System       0       First day of week specified in system settings
 * FirstDayOfWeek.Sunday       1       Sunday (default)
 * FirstDayOfWeek.Monday       2       Monday (complies with ISO standard 8601, section 3.17)
 * FirstDayOfWeek.Tuesday      3       Tuesday
 * FirstDayOfWeek.Wednesday    4       Wednesday
 * FirstDayOfWeek.Thursday     5       Thursday
 * FirstDayOfWeek.Friday       6       Friday
 * FirstDayOfWeek.Saturday     7       Saturday
 * </PRE>
 *
 * <P>
 * The WeekOfYear argument can have one of the following settings.
 *
 * <pre>
 * Enumeration value            Value  Description
 * FirstWeekOfYear.System         0    First week of year specified in system settings
 * FirstWeekOfYear.Jan1           1    Week in which January 1 occurs (default)
 * FirstWeekOfYear.FirstFourDays  2    Week that has at least four days in the new year (complies with ISO standard 8601, section 3.17)
 * FirstWeekOfYear.FirstFullWeek  3    First full week in the new year
 * </pre>
 *
 * You can use the DateDiff function to determine how many specified time intervals
 * exist between two date/time values. For example, you might use DateDiff to calculate
 * the number of days between two dates, or the number of weeks between today and the
 * end of the year.
 *
 * If Interval is set to DateInterval.DayOfYear, it is treated the same as
 * DateInterval.Day, because DayOfYear is not a meaningful unit for a time interval.
 *
 * If Interval is set to DateInterval.WeekOfYear, the return value represents the
 * number of weeks between the first day of the week containing Date1 and the first
 * day of the week containing Date2. The following example shows how this produces
 * different results from DateInterval.Weekday.
 *
 * <PRE>
 * Dim DatTim1 As Date = #1/4/2001#   ' This is a Thursday.
 * Dim DatTim2 As Date = #1/9/2001#   ' This is the next Tuesday.
 * ' Assume Sunday is specified as first day of the week.
 * Dim WD As Long = DateDiff(DateInterval.Weekday, DatTim1, DatTim2)
 * Dim WY As Long = DateDiff(DateInterval.WeekOfYear, DatTim1, DatTim2)
 * </PRE>
 *
 * In the preceding example, DateDiff returns 0 to WD because the difference between
 * the two dates is less than seven days, but it returns 1 to WY because there is a
 * seven-day difference between the first days of the respective calendar weeks.
 *
 * If Interval is set to DateInterval.Year, the return value is calculated purely from
 * the year parts of Date1 and Date2.
 *
 * Because Date1 and Date2 are of the Date data type, they hold date and time values
 * accurate to 100-nanosecond ticks on the system timer. However, DateDiff always
 * returns the number of time intervals as a Long value.
 *
 * If Date1 represents a later date and time than Date2, DateDiff returns a negative number.
 *
 * If any argument has an invalid value, an ArgumentException error occurs. If either
 * the Date1 or Date2 argument has a value that cannot be coerced to a valid Date value,
 * an InvalidCastException error occurs.
 *
 * Note   When comparing December 31 to January 1 of the following year, DateDiff
 * returns 1 for DateInterval.Year, DateInterval.Quarter, or DateInterval.Month, even
 * though only one day has elapsed.
 *
 * Since every Date value is supported by a DateTime structure, its methods give you
 * additional options in finding time intervals. For example, you can use the Subtract
 * method in either of its overloaded forms. One of these subtracts a TimeSpan from a
 * Date variable to return another Date value; the other subtracts a Date value to return
 * a TimeSpan. You can time a process to find out how many milliseconds it takes, as
 * follows:
 *
 * <PRE>
 * Dim StartTime As Date = Now   ' Starting date/time.
 * ' Run the process that is to be timed.
 * Dim RunLength As System.TimeSpan = Now.Subtract(StartTime)
 * Dim Millisecs As Integer = RunLength.Milliseconds
 * </PRE>
 *
 *
 *
 * @param Interval    Required. DateInterval enumeration value or String expression
 *                   representing the time interval you want to use as the unit of
 *                   difference between Date1 and Date2.
 *
 * @param Date1
 * @param Date2       Required. Date. The two date/time values you want to use in the
 *                   calculation. The value of Date1 is subtracted from the value of
 *                   Date2 to produce the difference. Neither value is changed in the
 *                   calling program.
 *
 * @param DayOfWeek   Optional. A value chosen from the FirstDayOfWeek enumeration that
 *                   specifies the first day of the week. If not specified,
 *                   FirstDayOfWeek.Sunday is used.
 *
 * @param WeekOfYear  Optional. A value chosen from the FirstWeekOfYear enumeration that
 *                   specifies the first week of the year. If not specified,
 *                   FirstWeekOfYear.Jan1 is used.
 *
 *
 * @exception ArgumentException   Invalid Interval.
 * @exception ArgumentException   Date or DayofWeek are out of range.
 * @exception InvalidCastException   Date1 or Date2 are invalid types.
 *
 *
 *
 * @example
 * This example uses the DateDiff function to display the number of days between a
 * given date and today.
 *
 * <PRE>
 * Dim FirstDate, Msg As String   ' Declare variables.
 * Dim SecondDate As Date
 * FirstDate = InputBox("Enter a date")
 * SecondDate = CDate(FirstDate)
 * Msg = "Days from today: " & DateDiff(DateInterval.Day, Now, SecondDate)
 * MsgBox (Msg)
 * </PRE>
 *
 * @see DateAdd DateAdd Function
 * @see DatePart DatePart Function
 * @see Day      Day Function
 * @see Format   Format Function
 * @see Weekday  Weekday Function
 * @see Year     Year Function
 */
function Long DateDiff(Byval Interval As String,
                       Byval Date1 As Object,
                       Byval Date2 As Object,
                       Optional Byval DayOfWeek As FirstDayOfWeek = FirstDayOfWeek.Sunday,
                       Optional Byval WeekOfYear As FirstWeekOfYear = FirstWeekOfYear.Jan1);

/**
 * Returns an Integer value containing the specified component of a given Date value.
 *
 * <p>
 * <B>Settings</B>
 * <P>
 *
 * The Interval argument can have one of the following settings.
 *
 * <pre>
 * Enumeration value      String     Part of date/time value to return
 * DateInterval.Day         d          Day of month (1 through 31)
 * DateInterval.DayOfYear   y          Day of year (1 through 366)
 * DateInterval.Hour        h                   Hour
 * DateInterval.Minute      n                  Minute
 * DateInterval.Month       m                  Month
 * DateInterval.Quarter     q                 Quarter
 * DateInterval.Second      s                 Second
 * DateInterval.Weekday     w          Day of week (1 through 7)
 * DateInterval.WeekOfYear  ww        Week of year (1 through 53)
 * DateInterval.Year       yyyy                 Year
 *
 * The FirstDayOfWeekValue argument can have one of the following settings.
 *
 * Enumeration value       Value  Description
 * FirstDayOfWeek.System     0    First day of week specified in system settings
 * FirstDayOfWeek.Sunday     1    Sunday (default)
 * FirstDayOfWeek.Monday     2    Monday (complies with ISO standard 8601, section 3.17)
 * FirstDayOfWeek.Tuesday    3    Tuesday
 * FirstDayOfWeek.Wednesday  4    Wednesday
 * FirstDayOfWeek.Thursday   5    Thursday
 * FirstDayOfWeek.Friday     6    Friday
 * FirstDayOfWeek.Saturday   7    Saturday
 *
 * The FirstWeekOfYearValue argument can have one of the following settings.
 *
 * Enumeration value            Value  Description
 * FirstWeekOfYear.System         0    First week of year specified in system settings
 * FirstWeekOfYear.Jan1           1    Week in which January 1 occurs (default)
 * FirstWeekOfYear.FirstFourDays  2    Week that has at least four days in the new year (complies with ISO standard 8601, section 3.17)
 * FirstWeekOfYear.FirstFullWeek  3    First full week in new year
 * <pre>
 *
 * You can use the DatePart function to evaluate a date/time value and return a specific
 * component. For example, you might use DatePart to calculate the day of the week or
 * the current hour.
 *
 * If you choose DateInterval.Weekday for the Interval argument, the returned value is
 * consistent with the values of the FirstDayOfWeek enumeration. If you choose
 * DateInterval.WeekOfYear, DatePart uses the Calendar and CultureInfo classes of the
 * System.Globalization namespace to determine your current settings.
 *
 * The FirstDayOfWeekValue argument affects calculations that use the DateInterval.Weekday
 * and DateInterval.WeekOfYear Interval settings. The FirstWeekOfYearValue argument
 * affects calculations that specify DateInterval.WeekOfYear for Interval.
 *
 * If any argument has an invalid value, an ArgumentException error occurs. If the
 * DateValue argument has a value that cannot be coerced to a valid Date value, an
 * InvalidCastException error occurs.
 *
 * Since every Date value is supported by a DateTime structure, its methods give you
 * additional options in retrieving date/time parts. For example, you can obtain the
 * entire date value of a Date variable, with the time value set to midnight, as follows:
 *
 * Dim CurrDatTim As Date = Now   ' Current date and time.
 * Dim LastMidnight As Date = CurrDatTim.Date   ' At midnight.
 *
 *
 * @param Interval   Required. DateInterval enumeration value or String expression
 *                  representing the part of the date/time value you want to return.
 *
 * @param DateValue  Required. Date value that you want to evaluate.
 *
 * @param FirstDayOfWeekValue    Optional. A value chosen from the FirstDayOfWeek
 *                              enumeration that specifies the first day of the week.
 *                              If not specified, FirstDayOfWeek.Sunday is used.
 *
 * @param FirstWeekOfYearValue   Optional. A value chosen from the FirstWeekOfYear
 *                              enumeration that specifies the first week of the year.
 *                              If not specified, FirstWeekOfYear.Jan1 is used.
 *
 *
 *
 * @exception ArgumentException   Interval is invalid.
 * @exception InvalidCastException    DateValue is not coercible to Date.
 *
 *
 *
 * @example
 * This example takes a date and, using the DatePart function, displays the quarter of
 * the year in which it occurs.
 *
 * <PRE>
 * Dim FirstDate, Msg As String   'Declare variables.
 * Dim SecondDate As Date
 * FirstDate = InputBox("Enter a date:")
 * SecondDate = CDate(FirstDate)
 * Msg = "Quarter: " & DatePart(DateInterval.Quarter, SecondDate)
 * MsgBox (Msg)
 * </PRE>
 *
 * @see DateAdd DateAdd Function
 * @see DatePart DatePart Function
 * @see Day      Day Function
 * @see Format   Format Function
 * @see Weekday  Weekday Function
 * @see Year     Year Function
 */
function Integer DatePart(ByVal Interval As DateInterval,
                          ByVal DateValue As DateTime,
                          Optional ByVal FirstDayOfWeekValue As FirstDayOfWeek = VbSunday,
                          Optional ByVal FirstWeekOfYearValue As FirstWeekOfYear = VbFirstJan1);

/**
 * Returns an Integer value containing the specified component of a given Date value.
 *
 * <p>
 * <B>Settings</B>
 * <P>
 *
 * The Interval argument can have one of the following settings.
 *
 * <pre>
 * Enumeration value      String     Part of date/time value to return
 * DateInterval.Day         d          Day of month (1 through 31)
 * DateInterval.DayOfYear   y          Day of year (1 through 366)
 * DateInterval.Hour        h                   Hour
 * DateInterval.Minute      n                  Minute
 * DateInterval.Month       m                  Month
 * DateInterval.Quarter     q                 Quarter
 * DateInterval.Second      s                 Second
 * DateInterval.Weekday     w          Day of week (1 through 7)
 * DateInterval.WeekOfYear  ww        Week of year (1 through 53)
 * DateInterval.Year       yyyy                 Year
 *
 * The FirstDayOfWeekValue argument can have one of the following settings.
 *
 * Enumeration value       Value  Description
 * FirstDayOfWeek.System     0    First day of week specified in system settings
 * FirstDayOfWeek.Sunday     1    Sunday (default)
 * FirstDayOfWeek.Monday     2    Monday (complies with ISO standard 8601, section 3.17)
 * FirstDayOfWeek.Tuesday    3    Tuesday
 * FirstDayOfWeek.Wednesday  4    Wednesday
 * FirstDayOfWeek.Thursday   5    Thursday
 * FirstDayOfWeek.Friday     6    Friday
 * FirstDayOfWeek.Saturday   7    Saturday
 *
 * The FirstWeekOfYearValue argument can have one of the following settings.
 *
 * Enumeration value            Value  Description
 * FirstWeekOfYear.System         0    First week of year specified in system settings
 * FirstWeekOfYear.Jan1           1    Week in which January 1 occurs (default)
 * FirstWeekOfYear.FirstFourDays  2    Week that has at least four days in the new year (complies with ISO standard 8601, section 3.17)
 * FirstWeekOfYear.FirstFullWeek  3    First full week in new year
 * <pre>
 *
 * You can use the DatePart function to evaluate a date/time value and return a specific
 * component. For example, you might use DatePart to calculate the day of the week or
 * the current hour.
 *
 * If you choose DateInterval.Weekday for the Interval argument, the returned value is
 * consistent with the values of the FirstDayOfWeek enumeration. If you choose
 * DateInterval.WeekOfYear, DatePart uses the Calendar and CultureInfo classes of the
 * System.Globalization namespace to determine your current settings.
 *
 * The FirstDayOfWeekValue argument affects calculations that use the DateInterval.Weekday
 * and DateInterval.WeekOfYear Interval settings. The FirstWeekOfYearValue argument
 * affects calculations that specify DateInterval.WeekOfYear for Interval.
 *
 * If any argument has an invalid value, an ArgumentException error occurs. If the
 * DateValue argument has a value that cannot be coerced to a valid Date value, an
 * InvalidCastException error occurs.
 *
 * Since every Date value is supported by a DateTime structure, its methods give you
 * additional options in retrieving date/time parts. For example, you can obtain the
 * entire date value of a Date variable, with the time value set to midnight, as follows:
 *
 * Dim CurrDatTim As Date = Now   ' Current date and time.
 * Dim LastMidnight As Date = CurrDatTim.Date   ' At midnight.
 *
 *
 * @param Interval   Required. DateInterval enumeration value or String expression
 *                  representing the part of the date/time value you want to return.
 *
 * @param DateValue  Required. Date value that you want to evaluate.
 *
 * @param FirstDayOfWeekValue    Optional. A value chosen from the FirstDayOfWeek
 *                              enumeration that specifies the first day of the week.
 *                              If not specified, FirstDayOfWeek.Sunday is used.
 *
 * @param FirstWeekOfYearValue   Optional. A value chosen from the FirstWeekOfYear
 *                              enumeration that specifies the first week of the year.
 *                              If not specified, FirstWeekOfYear.Jan1 is used.
 *
 *
 * @exception ArgumentException   Interval is invalid.
 * @exception InvalidCastException    DateValue is not coercible to Date.
 *
 *
 *
 * @example
 * This example takes a date and, using the DatePart function, displays the quarter of
 * the year in which it occurs.
 *
 * <PRE>
 * Dim FirstDate, Msg As String   'Declare variables.
 * Dim SecondDate As Date
 * FirstDate = InputBox("Enter a date:")
 * SecondDate = CDate(FirstDate)
 * Msg = "Quarter: " & DatePart(DateInterval.Quarter, SecondDate)
 * MsgBox (Msg)
 * </PRE>
 *
 * @see DateAdd DateAdd Function
 * @see DatePart DatePart Function
 * @see Day      Day Function
 * @see Format   Format Function
 * @see Weekday  Weekday Function
 * @see Year     Year Function
 */
function Integer DatePart(ByVal Interval As String,
                                   ByVal DateValue As Object,
                                   Optional ByVal DayOfWeek As FirstDayOfWeek = FirstDayOfWeek.Sunday,
                                   Optional ByVal WeekOfYear As FirstWeekOfYear = FirstWeekOfYear.Jan1);

/**
 * Returns a Date value representing a specified year, month, and day, with the time
 * information set to midnight (00:00:00).
 *
 * <B>Remarks</B>
 * Under Windows 98 or Windows 2000, two-digit years for the Year argument are
 * interpreted based on user-defined machine settings. The default settings are that
 * values from 0 through 29 are interpreted as the years 20002029, and values from 30
 * through 99 are interpreted as the years 19301999. For all other Year arguments, use a
 * four-digit year; for example, 1924.
 *
 * Earlier versions of Windows interpret two-digit years based on the defaults described
 * previously. To be sure the function returns the proper value, use a four-digit Year.
 *
 * The following example demonstrates negative, zero, and positive argument values. Here,
 * the DateSerial function returns a Date representing the day before the first day of
 * March in the year 10 years before the current year; in other words, the last day of
 * February ten years ago.
 *
 * Dim EndFeb As Date = DateSerial(-10, 3, 0)
 *
 * If either Month or Day exceeds its normal range, it is applied to the next larger unit
 * as appropriate. For example, if you specify 32 days, it is evaluated as one month and
 * from one to four days, depending on the value of Month. If Year is greater than 9999,
 * or if any argument is outside the range -2,147,483,648 through 2,147,483,647, an
 * ArgumentException error occurs. If the date specified by the three arguments is
 * earlier than 00:00:00 on January 1 of the year 1, or later than 23:59:59 on December
 * 31, 9999, an ArgumentOutOfRangeException error occurs.
 *
 * The Date data type includes time components. DateSerial sets all of these to 0, so
 * the returned value represents the beginning of the calculated day.
 *
 * Since every Date value is supported by a DateTime structure, its methods give you
 * additional options in assembling a Date value. For example, you can use one of the
 * overloaded DateTime constructors to populate a Date variable using the desired
 * combination of components. The following example sets NewDateTime to May 6, 1978 at
 * one tenth of a second before 8:30 in the morning:
 *
 * Dim NewDateTime As Date = New Date(1978, 5, 6, 8, 29, 59, 900)
 *
 * @param Year   Required. Integer expression from 1 through 9999. However, values
 *               below this range are also accepted. If Year is 0 through 99, it is
 *               interpreted as being between 1930 and 2029, as explained in the
 *               Remarks section below. If Year is less than 1, it is subtracted from
 *               the current year.
 *
 * @param Month  Required. Integer expression from 1 through 12. However, values outside
 *               this range are also accepted. The value of Month is offset by 1 and
 *               applied to January of the calculated year. In other words, (Month - 1)
 *               is added to January. The year is recalculated if necessary. The following
 *               results illustrate this effect:
 *
 * <UL>
 * <LI>If Month is 1, the result is January of the calculated year.
 * <LI>If Month is 0, the result is December of the previous year.
 * <LI>If Month is -1, the result is November of the previous year.
 * <LI>If Month is 13, the result is January of the following year.
 * </UL>
 *
 * @param Day     Required. Integer expression from 1 through 31. However, values outside
 *                this range are also accepted. The value of Day is offset by 1 and
 *                applied to the first day of the calculated month. In other words,
 *                (Day - 1) is added to the first of the month. The month and year are
 *                recalculated if necessary. The following results illustrate this effect:
 * <UL>
 * <LI>If Day is 1, the result is the first day of the calculated month.
 * <LI>If Day is 0, the result is the last day of the previous month.
 * <LI>If Day is -1, the result is the penultimate day of the previous month.
 * <LI>If Day is past the end of the current month, the result is the appropriate day of the following month. For example, if Month is 4 and Day is 31, the result is May 1.
 * </UL>
 *
 *
 *
 * @example
 * This example uses the DateSerial function to return the date for the specified year,
 * month, and day.
 *
 * <PRE>
 * Dim MyDate As Date
 * ' MyDate contains the date for February 12, 1969.
 * MyDate = DateSerial(1969, 2, 12)   ' Return a date.
 * </PRE>
 *
 * @see DateValue DateValue Function
 * @see Day       Day Function
 * @see Month     Month Function
 * @see TimeSerial TimeSerial Function
 * @see TimeValue  TimeValue Function
 * @see Weekday Weekday Function
 * @see Year Year Function
 */
function DateTime DateSerial(ByVal Year As Integer,
                    ByVal Month As Integer,
                    ByVal Day As Integer);

/**
 * Returns a Date value containing the date information represented by a string, with
 * the time information set to midnight (00:00:00).
 *
 * @param StringDate   Required. String expression representing a date/time value from
 *                    00:00:00 on January 1 of the year 1 through 23:59:59 on
 *                    December 31, 9999.
 *
 * @exception InvalidCastException   StringDate includes invalid time information.
 *
 * <B>Remarks</B>
 * If StringDate includes only numbers from 1 through 12 separated by valid date
 * separators, DateValue recognizes the order for month, day, and year according to
 * the Short Date format specified for your system. DateValue uses the current calendar
 * setting from the CurrentCulture property of the CultureInfo class in the
 * System.Globalization namespace. The default CurrentCulture values are determined by
 * Control Panel settings. You can override the Short Date format by setting the
 * ShortDatePattern property of the DateTimeFormatInfo class in the System.Globalization
 * namespace.
 *
 * DateValue recognizes month names in long, abbreviated, and numeric form. For example,
 * in addition to recognizing 12/30/1991 and 12/30/91, DateValue also recognizes
 * December 30, 1991 and Dec 30, 1991.
 *
 * If the year part of StringDate is omitted, DateValue uses the current year from your
 * computer's system date.
 *
 * If the StringDate argument includes time information, DateValue does not include it
 * in the returned value. However, if StringDate includes invalid time information,
 * such as "89:98", an InvalidCastException error occurs.
 *
 * @example
 * This example uses the DateValue function to convert a string to a date. You can also
 * use date literals to directly assign a date to an Object or Date variable, for example,
 * MyDate = #2/12/69#.
 *
 * <PRE>
 * Dim MyDate As Date
 * MyDate = DateValue("February 12, 1969")   ' Returns a date.
 * </PRE>
 *
 * @see DateSerial DateSerial Function
 * @see Day Day Function
 * @see Month Month Function
 * @see TimeSerial TimeSerial Function
 * @see TimeValue TimeValue Function
 * @see Weekday Weekday Function
 * @see Year Year Function
 */
function DateTime DateValue(ByVal StringDate As String);

/**
 *Returns an Integer value from 1 through 31 representing the day of the month.
 *
 * @param DateValue   Required. Date value from which you want to extract the day.
 * If you use the Day function, you might have to qualify it with the
 * Microsoft.VisualBasic namespace, because the System.Windows.Forms namespace defines Day as an enumeration. The following example shows how qualifying Day resolves this ambiguity:
 *
 * Dim ThisDay As Integer = Microsoft.VisualBasic.Day(Now)
 *
 *You can also obtain the day of the month by calling DatePart and specifying DateInterval.Day for the Interval argument.
 *
 * @example
 * This example uses the Day function to obtain the day of the month >from a specified date. In the development environment, the date literal is displayed in standard short format (such as "02/12/1969") using the locale settings of your code.
 *
 * <PRE>
 * Dim MyDate As Date
 * Dim MyDay As Integer
 * MyDate = #2/12/1969#   ' Assign a date using standard short format.
 * MyDay = Microsoft.VisualBasic.Day(MyDate)   ' MyDay contains 12.
 * </PRE>
 *
 * Day is qualified to distinguish it from the System.Windows.Forms.Day enumeration.
 *
 * @see Hour Hour Function
 * @see Minute Minute Function
 * @see Month Month Function
 * @see Second Second Function
 * @see Weekday Weekday Function
 * @see Year Year Function
 * @see DatePart DatePart Function
 */
function Integer Day(ByVal DateValue As DateTime);

/**
 * Returns a Double specifying the depreciation of an asset for a specific time
 * period using the double-declining balance method or some other method you specify.
 *
 * @param Cost      Required. Double specifying initial cost of the asset.
 * @param Salvage   Required. Double specifying value of the asset at the end of
 *                  its useful life.
 * @param Life      Required. Double specifying length of useful life of the asset.
 * @param Period    Required. Double specifying period for which asset depreciation
 *                  is calculated.
 * @param Factor    Optional. Double specifying rate at which the balance declines.
 *                  If omitted, 2 (double-declining method) is assumed.
 *
 * @exception ArgumentException   Argument value < 0 or Period > Life.
 *
 * <B>Remarks</B>
 * The double-declining balance method computes depreciation at an accelerated rate.
 * Depreciation is highest in the first period and decreases in successive periods.
 *
 * The Life and Period arguments must be expressed in the same units. For example,
 * if Life is given in months, Period must also be given in months. All arguments
 * must be positive numbers.
 *
 * The DDB function uses the following formula to calculate depreciation for a given
 * period:
 *
 * Depreciation / Period = ((Cost  Salvage) * Factor) / Life
 *
 * @example
 * This example uses the DDB function to return the depreciation of an asset for a
 * specified period given the initial cost (InitCost), the salvage value at the end
 * of the asset's useful life (SalvageVal), the total life of the asset in years
 * (LifeTime), and the period in years for which the depreciation is calculated (Depr).
 *
 * <PRE>
 * Sub testDDB()
 * Dim InitCost, SalvageVal, MonthLife, DepYear As Double
 * Dim Fmt As String
 * Dim LifeTime, Depr As Double
 * Const YRMOS As Integer = 12    ' Number of months in a year.
 * Fmt = "###,##0.00"
 * InitCost = CDbl(InputBox("What's the initial cost of the asset?"))
 * SalvageVal = CDbl(InputBox("Enter the asset's value at end of its life.")
 * MonthLife = CDbl(InputBox("What's the asset's useful life in months?")
 * Do While MonthLife < YRMOS   ' Ensure period is >= 1 year.
 *   MsgBox("Asset life must be a year or more.")
 *   MonthLife = CDbl(InputBox("What's the asset's useful life in months?")
 * Loop
 * LifeTime = MonthLife / YRMOS   ' Convert months to years.
 * If LifeTime <> Int(MonthLife / YRMOS) Then
 *   LifeTime = Int(LifeTime + 1)   ' Round up to nearest year.
 * End If
 * DepYear = CInt(InputBox("Enter year for depreciation calculation."))
 * Do While DepYear < 1 Or DepYear > LifeTime
 *   MsgBox("You must enter at least 1 but not more than " & LifeTime)
 *   DepYear = CDbl(InputBox("Enter year for depreciation calculation.")
 * Loop
 * Depr = DDB(InitCost, SalvageVal, LifeTime, DepYear)
 * MsgBox("The depreciation for year " & DepYear & " is " & _
 * Format(Depr, Fmt) & ".")
 * End Sub
 * </PRE>
 *
 * @see FV  FV Function
 * @see IPmt IPmt Function
 * @see IRR  IRR Function
 * @see MIRR MIRR Function
 * @see NPer NPer Function
 * @see NPV NPV Function
 * @see Pmt Pmt Function
 * @see PPmt PPmt Function
 * @see PV PV Function
 * @see Rate Rate Function
 * @see SLN SLN Function
 * @see SYD SYD Function
 */
function Double DDB(
   ByVal Cost As Double,
   ByVal Salvage As Double,
   ByVal Life As Double,
   ByVal Period As Double,
   Optional ByVal Factor As Double = 2.0 );

/**
 * Deletes a section or key setting from an application's entry in the Windows registry.
 *
 * @param AppName   Required. String expression containing the name of the application
 *                  or project to which the section or key setting applies.
 * @param Section   Required. String expression containing the name of the section from
 *                  which the key setting is being deleted. If only AppName and Section
 *                  are provided, the specified section is deleted along with all
 *                  related key settings.
 * @param Key       Optional. String expression containing the name of the key
 *                  setting being deleted.
 *
 * @exception ArgumentException  Section, AppName, or Key setting does not exist.
 * @exception ArgumentException  User is not logged in.
 *
 * <B>Remarks</B>
 * If all arguments are provided, the specified setting is deleted. A run-time error
 * occurs if you attempt to use DeleteSetting on a nonexistent section or key setting.
 *
 * DeleteSetting requires that a user be logged on since it operates under the
 * HKEY_LOCAL_USER registry key, which is not active until a user logs on interactively.
 *
 * Registry settings that are to be accessed from a non-interactive process (such
 * as mtx.exe) should be stored under either the HKEY_LOCAL_MACHINE\Software\ or the
 * HKEY_USER\DEFAULT\Software registry keys.
 *
 * @example
 * The following example first uses the SaveSetting procedure to make entries in the
 * Windows registry for the MyApp application, and then uses the DeleteSetting statement
 * to remove them. Because no Key argument is specified, the whole Startup section is
 * deleted, including the section name and all of its keys.
 *
 * <PRE>
 * ' Place some settings in the registry.
 * SaveSetting("MyApp", "Startup", "Top", "75")
 * SaveSetting("MyApp","Startup", "Left", "50")
 * ' Remove section and all its settings from registry.
 * DeleteSetting ("MyApp", "Startup")
 * ' Remove MyApp from the registry.
 * DeleteSetting ("MyApp")
 * </PRE>
 *
 * @see GetAllSettings GetAllSettings Function
 * @see GetSetting GetSetting Function
 * @see SaveSetting SaveSetting Function
 */
procedure DeleteSetting(
   ByVal AppName As String,
   Optional ByVal Section As String = Nothing,
   Optional ByVal Key As String = Nothing
);

/**
 * Returns a string representing the name of a file, directory, or folder that matches
 * a specified pattern or file attribute, or the volume label of a drive.
 *
 * <P>
 * <B>Settings</B>
 * <pre>
 * The Attributes argument enumeration values are as follows:
 *
 * Value      Constant    Description
 * Normal     vbnormal    Default. Specifies files with no attributes.
 * ReadOnly   vbReadOnly  Specifies read-only files in addition to files with no attributes.
 * Hidden     vbHidden    Specifies hidden files in addition to files with no attributes.
 * System     vbSystem    Specifies system files in addition to files with no attributes.
 * Volume     vbVolume    Specifies volume label; if any other attribute is specified,
 *                        vbVolume is ignored.
 * Directory  vbDirectory Specifies directories or folders in addition to files with no
 *                        attributes.
 * Archive    vbArchive   File has changed since last backup.
 * Alias      vbAlias     File has a different name.
 *
 * Note   These enumerations are specified by the Visual Basic language and can be used
 * anywhere in your code in place of the actual values.
 *
 * </pre>
 *
 * <B>Remarks</B>
 *
 * <pre>
 * The Dir function supports the use of multiple-character (*) and single-character (?)
 * wildcards to specify multiple files.
 *
 * You must supply a PathName the first time you call the Dir function. Subsequent
 * cals to the Dir function may be made with no parameters to retrieve the next item.
 * </pre>
 *
 * @param PathName    Optional. String expression that specifies a file name, directory
 *                    or folder name, or drive volume label. A zero-length string ("")
 *                    is returned if PathName is not found.
 * @param Attributes  Optional. Enumeration or numeric expression whose value specifies
 *                    file attributes. If omitted, returns files that match PathName,
 *                    but have no attributes.
 *
 * @example
 * This example uses the Dir function to check if certain files and directories exist.
 *
 * <PRE>
 * Dim MyFile, MyPath, MyName
 * ' Returns "WIN.INI" if it exists.
 * MyFile = Dir("C:\WINDOWS\WIN.INI")
 *
 * ' Returns filename with specified extension. If more than one *.INI
 * ' file exists, the first file found is returned.
 * MyFile = Dir("C:\WINDOWS\*.INI")
 *
 * ' Call Dir again without arguments to return the next *.INI file in the
 * ' same directory.
 * MyFile = Dir()
 *
 * ' Return first *.TXT file, including files with a set hidden attribute.
 * MyFile = Dir("*.TXT", vbHidden)
 *
 * ' Display the names in C:\ that represent directories.
 * MyPath = "c:\"   ' Set the path.
 * MyName = Dir(MyPath, vbDirectory)   ' Retrieve the first entry.
 * Do While MyName <> ""   ' Start the loop.
 * ' Use bitwise comparison to make sure MyName is a directory.
 * If (GetAttr(MyPath & MyName) And vbDirectory) = vbDirectory Then
 * ' Display entry only if it's a directory.
 * Debug.WriteLine(MyName)
 * End If
 * MyName = Dir()   ' Get next entry.
 * Loop
 * </PRE>
 *
 * @see ChDir ChDir Function
 * @see CurDir CurDir Function
 */
function String Dir();

/**
 * Returns a string representing the name of a file, directory, or folder that matches
 * a specified pattern or file attribute, or the volume label of a drive.
 *
 * <p>
 * <B>Settings</B>
 * <pre>
 * The Attributes argument enumeration values are as follows:
 *
 * Value      Constant    Description
 * Normal     vbnormal    Default. Specifies files with no attributes.
 * ReadOnly   vbReadOnly  Specifies read-only files in addition to files with no attributes.
 * Hidden     vbHidden    Specifies hidden files in addition to files with no attributes.
 * System     vbSystem    Specifies system files in addition to files with no attributes.
 * Volume     vbVolume    Specifies volume label; if any other attribute is specified,
 *                        vbVolume is ignored.
 * Directory  vbDirectory Specifies directories or folders in addition to files with no
 *                        attributes.
 * Archive    vbArchive   File has changed since last backup.
 * Alias      vbAlias     File has a different name.
 *
 * Note   These enumerations are specified by the Visual Basic language and can be used
 * anywhere in your code in place of the actual values.
 *
 * </pre>
 *
 * <B>Remarks</B>
 *
 * <pre>
 * The Dir function supports the use of multiple-character (*) and single-character (?)
 * wildcards to specify multiple files.
 *
 * You must supply a PathName the first time you call the Dir function. Subsequent
 * cals to the Dir function may be made with no parameters to retrieve the next item.
 * </pre>
 *
 * @param PathName    Optional. String expression that specifies a file name, directory
 *                    or folder name, or drive volume label. A zero-length string ("")
 *                    is returned if PathName is not found.
 * @param Attributes  Optional. Enumeration or numeric expression whose value specifies
 *                    file attributes. If omitted, returns files that match PathName,
 *                    but have no attributes.
 *
 * @example
 * This example uses the Dir function to check if certain files and directories exist.
 *
 * <PRE>
 * Dim MyFile, MyPath, MyName
 * ' Returns "WIN.INI" if it exists.
 * MyFile = Dir("C:\WINDOWS\WIN.INI")
 *
 * ' Returns filename with specified extension. If more than one *.INI
 * ' file exists, the first file found is returned.
 * MyFile = Dir("C:\WINDOWS\*.INI")
 *
 * ' Call Dir again without arguments to return the next *.INI file in the
 * ' same directory.
 * MyFile = Dir()
 *
 * ' Return first *.TXT file, including files with a set hidden attribute.
 * MyFile = Dir("*.TXT", vbHidden)
 *
 * ' Display the names in C:\ that represent directories.
 * MyPath = "c:\"   ' Set the path.
 * MyName = Dir(MyPath, vbDirectory)   ' Retrieve the first entry.
 * Do While MyName <> ""   ' Start the loop.
 * ' Use bitwise comparison to make sure MyName is a directory.
 * If (GetAttr(MyPath & MyName) And vbDirectory) = vbDirectory Then
 * ' Display entry only if it's a directory.
 * Debug.WriteLine(MyName)
 * End If
 * MyName = Dir()   ' Get next entry.
 * Loop
 * </PRE>
 *
 * @see ChDir ChDir Function
 * @see CurDir CurDir Function
 */
function String Dir(
   Optional ByVal PathName As String,
   Optional ByVal Attributes As FileAttribute = FileAttribute.Normal);

/**
 * Returns the string associated with an operating system environment variable.
 *
 * @param Expression   Required. Expression that evaluates to either a string
 *                     containing the name of an environment variable, or an integer
 *                     corresponding to the numeric order of an environment string
 *                     in the environment-string table.
 *
 * @exception ArgumentException   Expression is missing.
 *
 * <B>Remarks</B>
 * If Expression contains a string, the Environ function returns the text assigned to
 * the specified environment string; that is, the text following the equal sign (=) in
 * the environment-string table for that environment variable. If the string in
 * Expression cannot be found in the environment-string table, a zero-length string
 * ("") is returned.
 *
 * If Expression contains an integer, the string occupying that numeric position in
 * the environment-string table is returned. In this case, Environ returns all of the
 * text, including the name of the environment variable. If there is no environment
 * string in the specified position, Environ returns a zero-length string.
 *
 * @example
 * This example uses the Environ function to supply the entry number and length of
 * the PATH statement from the environment-string table.
 *
 * <PRE>
 * Sub tenv()
 * Dim envString As String
 * Dim found As Boolean = False
 * Dim index As Integer = 1
 * Dim pathLength As Integer
 * Dim message As String
 *
 * envString = Environ(index)
 * While Not found And (envString <> "")
 *   If (envString.Substring(0, 5) = "Path=") Then
 *     found = True
 *   Else
 *     index += 1
 *     envString = Environ(index)
 *   End If
 * End While
 *
 * If found Then
 *    pathLength = Environ("PATH").Length
 *    message = "PATH entry = " & index & " and length = " & pathLength
 * Else
 *    message = "No PATH environment variable exists."
 * End If
 *
 * MsgBox(message)
 * End Sub
 * </PRE>
 */
function String Environ(ByVal Expression As Integer);

/**
 * Returns the string associated with an operating system environment variable.
 *
 * @param Expression   Required. Expression that evaluates to either a string
 *                     containing the name of an environment variable, or an integer
 *                     corresponding to the numeric order of an environment string
 *                     in the environment-string table.
 *
 * @exception ArgumentException   Expression is missing.
 *
 * <B>Remarks</B>
 * If Expression contains a string, the Environ function returns the text assigned to
 * the specified environment string; that is, the text following the equal sign (=) in
 * the environment-string table for that environment variable. If the string in
 * Expression cannot be found in the environment-string table, a zero-length string
 * ("") is returned.
 *
 * If Expression contains an integer, the string occupying that numeric position in
 * the environment-string table is returned. In this case, Environ returns all of the
 * text, including the name of the environment variable. If there is no environment
 * string in the specified position, Environ returns a zero-length string.
 *
 * @example
 * This example uses the Environ function to supply the entry number and length of
 * the PATH statement from the environment-string table.
 *
 * <PRE>
 * Sub tenv()
 * Dim envString As String
 * Dim found As Boolean = False
 * Dim index As Integer = 1
 * Dim pathLength As Integer
 * Dim message As String
 *
 * envString = Environ(index)
 * While Not found And (envString <> "")
 *   If (envString.Substring(0, 5) = "Path=") Then
 *     found = True
 *   Else
 *     index += 1
 *     envString = Environ(index)
 *   End If
 * End While
 *
 * If found Then
 *    pathLength = Environ("PATH").Length
 *    message = "PATH entry = " & index & " and length = " & pathLength
 * Else
 *    message = "No PATH environment variable exists."
 * End If
 *
 * MsgBox(message)
 * End Sub
 * </PRE>
 */
function String Environ(ByVal Expression As String);

/**
 * Returns a Boolean value True when the end of a file opened for Random or
 * sequential Input has been reached.
 *
 * @param FileNumber   Required. An Integer containing any valid file number.
 *
 * @exception IOException     FileNumber does not exist.
 * @exception IOException     File mode is invalid.
 *
 * <B>Remarks</B>
 * Use EOF to avoid the error generated by attempting to get input past the end of a file.
 *
 * The EOF function returns False until the end of the file has been reached. With
 * files opened for Random or Binary access, EOF returns False until the last executed
 * FileGet function is unable to read an entire record.
 *
 * With files opened for Binary access, an attempt to read through the file using the
 * Input function until EOF returns True generates an error. Use the LOF and Loc
 * functions instead of EOF when reading binary files with Input, or use Get when
 * using the EOF function. With files opened for Output, EOF always returns True.
 *
 * @example
 * This example uses the EOF function to detect the end of a file. This example assumes
 * that TESTFILE is a text file with a few lines of text.
 *
 * <PRE>
 * Dim TextLine As String
 * FileOpen(1, "TESTFILE", OpenMode.Input)   ' Open file.
 * Do While Not EOF(1)   ' Loop until end of file.
 *   TextLine = LineInput(1)   ' Read line into variable.
 *   Debug.WriteLine(TextLine)   ' Print to the Command window.
 * Loop
 * FileClose(1)   ' Close file.
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see Loc Loc Function
 * @see LOF LOF Function
 * @see FileOpen FileOpen Function
 */
function Boolean EOF(ByVal FileNumber As Integer);


/**
 * Returns the error message that corresponds to a given error number.
 *
 * @param errornumber   Optional. Any valid error number.
 *
 * @exception ArgumentException   ErrorNumber is out of range.
 *
 * <B>Remarks</B>
 * The ErrorToString function examines the property settings of the Err object to
 * identify the most recent run-time error. The return value of the ErrorToString
 * function corresponds to the Description property of the Err object. If errornumber
 * is a valid error number but is not defined, ErrorToString returns the string,
 * "Application-defined or object-defined error." If errornumber is not valid, an
 * error occurs. If errornumber is omitted, the message corresponding to the most recent
 * run-time error is returned. If no run-time error has occurred, or errornumber is 0,
 * ErrorToString returns a zero-length string ("").
 *
 * In Visual Basic version 6.0 and earlier, this functionality was provided by the
 * Error function.
 *
 * @example
 * The following code uses the ErrorToString function to display error messages that
 * correspond to the specified error numbers:
 *
 * <PRE>
 * Dim ErrorNumber As Integer
 * For ErrorNumber = 61 To 64   ' Loop through values 61 - 64.
 *   MsgBox(ErrorToString(ErrorNumber))   ' Display error names in message box.
 * Next ErrorNumber
 * </PRE>
 *
 * @see Err Err Function
 */
function String ErrorToString(errornumber);

/**
 * Returns e raised to the specified power.
 *
 * @param d   A number specifying a power.
 *
 * @return The number e raised to the power d. If d equals NaN or PositiveInfinity,
 *         that value is returned. If d equals NegativeInfinity, 0 is returned.
 *
 * <B>Remarks</B>
 * Use the Pow method to calculate powers of other bases.
 *
 * Exp is the inverse of Log.
 *
 * @see E E Function
 * @see Pow Pow Function
 * @see Log Log Function
 */
function Double Exp(ByVal d As Double);

/**
 * Returns an enumeration representing the file mode for files opened using the
 * FileOpen function.
 *
 * <p>
 * <B>Return Values</B>
 * <P>
 * The following enumeration values indicate the file access mode:
 *
 * <pre>
 * Value   Mode
 * 1       OpenMode.Input
 * 2       OpenMode.Output
 * 4       OpenMode.Random
 * 8       OpenMode.Append
 * 32      OpenMode.Binary
 * </pre>
 *
 * @param FileNumber    Required. Integer. Any valid file number.
 *
 * @exception IOException   FileNumber does not exist.
 * @exception IOException   File mode is invalid.
 *
 * @example
 * This example uses the FileAttr function to return the file mode of an open file.
 *
 * <PRE>
 * Dim mode As OpenMode
 * FileOpen(1, "c:\MYFILE.TXT", OpenMode.Input)
 * mode = FileAttr(1)
 * MsgBox("The file mode is " & mode.ToString())
 * FileClose(1)
 * </PRE>
 *
 * @see GetAttr GetAttr Function
 * @see FileOpen FileOpen Function
 * @see SetAttr SetAttr Function
 */
function OpenMode FileAttr(ByVal FileNumber As Integer);

/**
 * Concludes input/output (I/O) to a file opened using the FileOpen function.
 *
 * @param FileNumbers()   Optional. Parameter array of 0 or more channels to be closed.
 *
 * @exception IOException   FileNumber does not exist.
 *
 * <B>Remarks</B>
 * If you omit FileNumbers(), all active files opened by the FileOpen function are closed.
 *
 * When you close files that were opened for Output or Append, the final buffer of output
 * is written to the operating system buffer for that file. All buffer space associated
 * with the closed file is released.
 *
 * When the FileClose function is executed, the association of a file with its file number
 * ends.
 *
 * @example
 * This example uses the FileClose function to close a file opened for Input.
 *
 * <PRE>
 * Dim TextLine As String
 * FileOpen(1, "TESTFILE", OpenMode.Input)   ' Open file.
 * Do While Not EOF(1)   ' Loop until end of file.
 *   TextLine = LineInput(1)   ' Read line into variable.
 *   Debug.WriteLine(TextLine)   ' Print to the Immediate window.
 * Loop
 * FileClose(1)   ' Close file.
 * </PRE>
 *
 * @see FileOpen FileOpen Function
 * @see Reset Reset Function
 */
procedure FileClose(ParamArray FileNumbers() As Integer);

/**
 * Copies a file.
 *
 * @param Source  Required. String expression that specifies the name of the file to be
 *                copied. Source may include the directory or folder, and drive, of the
 *                source file.
 * @param Destination  Required. String expression that specifies the target file name.
 *                     Destination may include the directory or folder, and drive, of the
 *                     destination file.
 *
 * @exception ArgumentException   Source or Destination is invalid or not specified.
 * @exception IOException   File is already open.
 * @exception FileNotFoundException   File does not exist.
 *
 * <b>Remarks</b>
 * If you try to use the FileCopy function on a currently open file, an error occurs.
 *
 * @example
 * This example uses the FileCopy function to copy one file to another. For purposes of
 * this example, assume that SRCFILE is a file containing some data.
 *
 * <PRE>
 * Dim SourceFile, DestinationFile As String
 * SourceFile = "SRCFILE"   ' Define source file name.
 * DestinationFile = "DESTFILE"   ' Define target file name.
 * FileCopy(SourceFile, DestinationFile)   ' Copy source to target.
 * </PRE>
 *
 * @see Kill Kill Function
 */
procedure FileCopy(
   ByVal Source As String,
   ByVal Destination As String
);

/**
 * Returns a Date value that indicates the date and time when a file was created or last
 * modified.
 *
 * @param PathName  Required. String expression that specifies a file name. PathName may
 *                  include the directory or folder, and the drive.
 *
 * @exception ArgumentException   PathName is invalid or contains wildcards.
 * @exception FileNotFoundException   Target file does not exist.
 *
 * @example
 * This example uses the FileDateTime function to determine the date and time a file was
 * created or last modified. The format of the date and time displayed is based on the
 * locale settings of your system.
 *
 * <PRE>
 * Dim MyStamp As Date
 * ' Assume TESTFILE was last modified on October 12, 2001 at 4:35:47 PM.
 * ' Assume English/U.S. locale settings.
 * ' Returns "10/12/2001 4:35:47 PM".
 * MyStamp = FileDateTime("C:\TESTFILE.txt")
 * </PRE>
 *
 * @see FileLen FileLen Function
 * @see GetAttr GetAttr Function
 */
function DateTime FileDateTime(ByVal PathName As String);


/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name into which data is read.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic and so whether to write an
 *                        array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a two-byte descriptor for the string
 *                              describing the length. The default is False.
 *
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * FileGet is only valid in Random and Binary mode.
 *
 * Data read with FileGet is usually written to a file with FilePut.
 *
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte following
 * the last FileGet or FilePut function (or pointed to by the last Seek function) is read.
 *
 * For files opened in Random mode, the following rules apply:
 *
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGet reads subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because
 * the amount of padding data can't be determined with any certainty, it is generally a
 * good idea to have the record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGet reads a two-byte
 * descriptor containing the string length and then reads the data that goes into the
 * variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * put to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you have a choice as to whether
 * to read a descriptor for the size and dimension of the array. To write the descriptor,
 * set the ArrayIsDynamic parameter to True. When reading the array, you need to match
 * the way the array was written. If it was written with the descriptor, then you need to
 * read the descriptor. If the descriptor is not used, then the size and bounds of the
 * array passed into FileGet will be used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk.
 *
 * <pre>
 * Dim MyArray(4,9) As Integer
 * </pre>
 *
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 *
 * <LI>If the variable being read into is any other type of variable (not a
 * variable-length string or an object), FileGet reads only the variable data. The record
 * length specified by the RecordLength clause in the FileOpen function must be greater
 * than or equal to the length of the data being read.
 * <LI>FileGet reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePut) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions.
 * The record length specified by the RecordLength clause in the FileOpen function must
 * be greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 *
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGet reads all
 * variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGet reads only the data. No
 * descriptor is read.
 * <LI>FileGet reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string. For example, the following statements read 11 bytes
 * from file number 1:
 * <PRE>
 * Dim hellow As New String(" ", 11)
 * FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 * FileGet(1, hellow)
 * Console.WriteLine(hellow)
 * FileClose(1)
 * </PRE>
 * </UL>
 *
 * @see FileOpen FileOpen Function
 * @see FilePut FilePut Function
 * @see Seek Seek Function
 * @see FileGetObject FileGetObject Function
 */
procedure FileGet(
   ByVal FileNumber As Integer,
   ByRef Value As Object,
   Optional RecordNumber As Integer = -1
);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name into which data is read.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic and so whether to write an
 *                        array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a two-byte descriptor for the string
 *                              describing the length. The default is False.
 *
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * FileGet is only valid in Random and Binary mode.
 *
 * Data read with FileGet is usually written to a file with FilePut.
 *
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte following
 * the last FileGet or FilePut function (or pointed to by the last Seek function) is read.
 *
 * For files opened in Random mode, the following rules apply:
 *
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGet reads subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because
 * the amount of padding data can't be determined with any certainty, it is generally a
 * good idea to have the record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGet reads a two-byte
 * descriptor containing the string length and then reads the data that goes into the
 * variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * put to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you have a choice as to whether
 * to read a descriptor for the size and dimension of the array. To write the descriptor,
 * set the ArrayIsDynamic parameter to True. When reading the array, you need to match
 * the way the array was written. If it was written with the descriptor, then you need to
 * read the descriptor. If the descriptor is not used, then the size and bounds of the
 * array passed into FileGet will be used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk.
 *
 * <pre>
 * Dim MyArray(4,9) As Integer
 * </pre>
 *
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 *
 * <LI>If the variable being read into is any other type of variable (not a
 * variable-length string or an object), FileGet reads only the variable data. The record
 * length specified by the RecordLength clause in the FileOpen function must be greater
 * than or equal to the length of the data being read.
 * <LI>FileGet reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePut) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions.
 * The record length specified by the RecordLength clause in the FileOpen function must
 * be greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 *
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGet reads all
 * variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGet reads only the data. No
 * descriptor is read.
 * <LI>FileGet reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string. For example, the following statements read 11 bytes
 * from file number 1:
 * <PRE>
 * Dim hellow As New String(" ", 11)
 * FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 * FileGet(1, hellow)
 * Console.WriteLine(hellow)
 * FileClose(1)
 * </PRE>
 * </UL>
 *
 * @see FileOpen FileOpen Function
 * @see FilePut FilePut Function
 * @see Seek Seek Function
 * @see FileGetObject FileGetObject Function
 */
procedure FileGet(
   ByVal FileNumber As Integer,
   ByRef Value As Short,
   Optional RecordNumber As Integer = -1
);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name into which data is read.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic and so whether to write an
 *                        array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a two-byte descriptor for the string
 *                              describing the length. The default is False.
 *
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * FileGet is only valid in Random and Binary mode.
 *
 * Data read with FileGet is usually written to a file with FilePut.
 *
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte following
 * the last FileGet or FilePut function (or pointed to by the last Seek function) is read.
 *
 * For files opened in Random mode, the following rules apply:
 *
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGet reads subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because
 * the amount of padding data can't be determined with any certainty, it is generally a
 * good idea to have the record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGet reads a two-byte
 * descriptor containing the string length and then reads the data that goes into the
 * variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * put to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you have a choice as to whether
 * to read a descriptor for the size and dimension of the array. To write the descriptor,
 * set the ArrayIsDynamic parameter to True. When reading the array, you need to match
 * the way the array was written. If it was written with the descriptor, then you need to
 * read the descriptor. If the descriptor is not used, then the size and bounds of the
 * array passed into FileGet will be used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk.
 *
 * <pre>
 * Dim MyArray(4,9) As Integer
 * </pre>
 *
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 *
 * <LI>If the variable being read into is any other type of variable (not a
 * variable-length string or an object), FileGet reads only the variable data. The record
 * length specified by the RecordLength clause in the FileOpen function must be greater
 * than or equal to the length of the data being read.
 * <LI>FileGet reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePut) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions.
 * The record length specified by the RecordLength clause in the FileOpen function must
 * be greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 *
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGet reads all
 * variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGet reads only the data. No
 * descriptor is read.
 * <LI>FileGet reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string. For example, the following statements read 11 bytes
 * from file number 1:
 * <PRE>
 * Dim hellow As New String(" ", 11)
 * FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 * FileGet(1, hellow)
 * Console.WriteLine(hellow)
 * FileClose(1)
 * </PRE>
 * </UL>
 *
 * @see FileOpen FileOpen Function
 * @see FilePut FilePut Function
 * @see Seek Seek Function
 * @see FileGetObject FileGetObject Function
 */
procedure FileGet(
   ByVal FileNumber As Integer,
   ByRef Value As Integer,
   Optional RecordNumber As Integer = -1
);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name into which data is read.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic and so whether to write an
 *                        array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a two-byte descriptor for the string
 *                              describing the length. The default is False.
 *
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * FileGet is only valid in Random and Binary mode.
 *
 * Data read with FileGet is usually written to a file with FilePut.
 *
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte following
 * the last FileGet or FilePut function (or pointed to by the last Seek function) is read.
 *
 * For files opened in Random mode, the following rules apply:
 *
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGet reads subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because
 * the amount of padding data can't be determined with any certainty, it is generally a
 * good idea to have the record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGet reads a two-byte
 * descriptor containing the string length and then reads the data that goes into the
 * variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * put to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you have a choice as to whether
 * to read a descriptor for the size and dimension of the array. To write the descriptor,
 * set the ArrayIsDynamic parameter to True. When reading the array, you need to match
 * the way the array was written. If it was written with the descriptor, then you need to
 * read the descriptor. If the descriptor is not used, then the size and bounds of the
 * array passed into FileGet will be used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk.
 *
 * <pre>
 * Dim MyArray(4,9) As Integer
 * </pre>
 *
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 *
 * <LI>If the variable being read into is any other type of variable (not a
 * variable-length string or an object), FileGet reads only the variable data. The record
 * length specified by the RecordLength clause in the FileOpen function must be greater
 * than or equal to the length of the data being read.
 * <LI>FileGet reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePut) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions.
 * The record length specified by the RecordLength clause in the FileOpen function must
 * be greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 *
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGet reads all
 * variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGet reads only the data. No
 * descriptor is read.
 * <LI>FileGet reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string. For example, the following statements read 11 bytes
 * from file number 1:
 * <PRE>
 * Dim hellow As New String(" ", 11)
 * FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 * FileGet(1, hellow)
 * Console.WriteLine(hellow)
 * FileClose(1)
 * </PRE>
 * </UL>
 *
 * @see FileOpen FileOpen Function
 * @see FilePut FilePut Function
 * @see Seek Seek Function
 * @see FileGetObject FileGetObject Function
 */
procedure FileGet(
   ByVal FileNumber As Integer,
   ByRef Value As Single,
   Optional RecordNumber As Integer = -1
);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name into which data is read.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic and so whether to write an
 *                        array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a two-byte descriptor for the string
 *                              describing the length. The default is False.
 *
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * FileGet is only valid in Random and Binary mode.
 *
 * Data read with FileGet is usually written to a file with FilePut.
 *
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte following
 * the last FileGet or FilePut function (or pointed to by the last Seek function) is read.
 *
 * For files opened in Random mode, the following rules apply:
 *
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGet reads subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because
 * the amount of padding data can't be determined with any certainty, it is generally a
 * good idea to have the record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGet reads a two-byte
 * descriptor containing the string length and then reads the data that goes into the
 * variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * put to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you have a choice as to whether
 * to read a descriptor for the size and dimension of the array. To write the descriptor,
 * set the ArrayIsDynamic parameter to True. When reading the array, you need to match
 * the way the array was written. If it was written with the descriptor, then you need to
 * read the descriptor. If the descriptor is not used, then the size and bounds of the
 * array passed into FileGet will be used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk.
 *
 * <pre>
 * Dim MyArray(4,9) As Integer
 * </pre>
 *
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 *
 * <LI>If the variable being read into is any other type of variable (not a
 * variable-length string or an object), FileGet reads only the variable data. The record
 * length specified by the RecordLength clause in the FileOpen function must be greater
 * than or equal to the length of the data being read.
 * <LI>FileGet reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePut) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions.
 * The record length specified by the RecordLength clause in the FileOpen function must
 * be greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 *
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGet reads all
 * variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGet reads only the data. No
 * descriptor is read.
 * <LI>FileGet reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string. For example, the following statements read 11 bytes
 * from file number 1:
 * <PRE>
 * Dim hellow As New String(" ", 11)
 * FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 * FileGet(1, hellow)
 * Console.WriteLine(hellow)
 * FileClose(1)
 * </PRE>
 * </UL>
 *
 * @see FileOpen FileOpen Function
 * @see FilePut FilePut Function
 * @see Seek Seek Function
 * @see FileGetObject FileGetObject Function
 */
procedure FileGet(
   ByVal FileNumber As Integer,
   ByRef Value As Double,
   Optional RecordNumber As Integer = -1
);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name into which data is read.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic and so whether to write an
 *                        array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a two-byte descriptor for the string
 *                              describing the length. The default is False.
 *
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * FileGet is only valid in Random and Binary mode.
 *
 * Data read with FileGet is usually written to a file with FilePut.
 *
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte following
 * the last FileGet or FilePut function (or pointed to by the last Seek function) is read.
 *
 * For files opened in Random mode, the following rules apply:
 *
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGet reads subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because
 * the amount of padding data can't be determined with any certainty, it is generally a
 * good idea to have the record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGet reads a two-byte
 * descriptor containing the string length and then reads the data that goes into the
 * variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * put to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you have a choice as to whether
 * to read a descriptor for the size and dimension of the array. To write the descriptor,
 * set the ArrayIsDynamic parameter to True. When reading the array, you need to match
 * the way the array was written. If it was written with the descriptor, then you need to
 * read the descriptor. If the descriptor is not used, then the size and bounds of the
 * array passed into FileGet will be used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk.
 *
 * <pre>
 * Dim MyArray(4,9) As Integer
 * </pre>
 *
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 *
 * <LI>If the variable being read into is any other type of variable (not a
 * variable-length string or an object), FileGet reads only the variable data. The record
 * length specified by the RecordLength clause in the FileOpen function must be greater
 * than or equal to the length of the data being read.
 * <LI>FileGet reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePut) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions.
 * The record length specified by the RecordLength clause in the FileOpen function must
 * be greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 *
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGet reads all
 * variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGet reads only the data. No
 * descriptor is read.
 * <LI>FileGet reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string. For example, the following statements read 11 bytes
 * from file number 1:
 * <PRE>
 * Dim hellow As New String(" ", 11)
 * FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 * FileGet(1, hellow)
 * Console.WriteLine(hellow)
 * FileClose(1)
 * </PRE>
 * </UL>
 *
 * @see FileOpen FileOpen Function
 * @see FilePut FilePut Function
 * @see Seek Seek Function
 * @see FileGetObject FileGetObject Function
 */
procedure FileGet(
   ByVal FileNumber As Integer,
   ByRef Value As Decimal,
   Optional RecordNumber As Integer = -1
);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name into which data is read.
 * @param RecordNumber    Optional. Record number (Random mode files) or
byte number
 *                        (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic and so whether to write an
 *                        array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a two-byte descriptor for the string
 *                              describing the length. The default is False.
 *
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * FileGet is only valid in Random and Binary mode.
 *
 * Data read with FileGet is usually written to a file with FilePut.
 *
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte following
 * the last FileGet or FilePut function (or pointed to by the last Seek function) is read.
 *
 * For files opened in Random mode, the following rules apply:
 *
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGet reads subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because
 * the amount of padding data can't be determined with any certainty, it is generally a
 * good idea to have the record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGet reads a two-byte
 * descriptor containing the string length and then reads the data that goes into the
 * variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * put to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you have a choice as to whether
 * to read a descriptor for the size and dimension of the array. To write the descriptor,
 * set the ArrayIsDynamic parameter to True. When reading the array, you need to match
 * the way the array was written. If it was written with the descriptor, then you need to
 * read the descriptor. If the descriptor is not used, then the size and bounds of the
 * array passed into FileGet will be used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk.
 *
 * <pre>
 * Dim MyArray(4,9) As Integer
 * </pre>
 *
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 *
 * <LI>If the variable being read into is any other type of variable (not a
 * variable-length string or an object), FileGet reads only the variable data. The record
 * length specified by the RecordLength clause in the FileOpen function must be greater
 * than or equal to the length of the data being read.
 * <LI>FileGet reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePut) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions.
 * The record length specified by the RecordLength clause in the FileOpen function must
 * be greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 *
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGet reads all
 * variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGet reads only the data. No
 * descriptor is read.
 * <LI>FileGet reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string. For example, the following statements read 11 bytes
 * from file number 1:
 * <PRE>
 * Dim hellow As New String(" ", 11)
 * FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 * FileGet(1, hellow)
 * Console.WriteLine(hellow)
 * FileClose(1)
 * </PRE>
 * </UL>
 *
 * @see FileOpen FileOpen Function
 * @see FilePut FilePut Function
 * @see Seek Seek Function
 * @see FileGetObject FileGetObject Function
 */
procedure FileGet(
   ByVal FileNumber As Integer,
   ByRef Value As Byte,
   Optional RecordNumber As Integer = -1
);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name into which data is read.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic and so whether to write an
 *                        array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a two-byte descriptor for the string
 *                              describing the length. The default is False.
 *
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * FileGet is only valid in Random and Binary mode.
 *
 * Data read with FileGet is usually written to a file with FilePut.
 *
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte following
 * the last FileGet or FilePut function (or pointed to by the last Seek function) is read.
 *
 * For files opened in Random mode, the following rules apply:
 *
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGet reads subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because
 * the amount of padding data can't be determined with any certainty, it is generally a
 * good idea to have the record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGet reads a two-byte
 * descriptor containing the string length and then reads the data that goes into the
 * variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * put to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you have a choice as to whether
 * to read a descriptor for the size and dimension of the array. To write the descriptor,
 * set the ArrayIsDynamic parameter to True. When reading the array, you need to match
 * the way the array was written. If it was written with the descriptor, then you need to
 * read the descriptor. If the descriptor is not used, then the size and bounds of the
 * array passed into FileGet will be used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk.
 *
 * <pre>
 * Dim MyArray(4,9) As Integer
 * </pre>
 *
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 *
 * <LI>If the variable being read into is any other type of variable (not a
 * variable-length string or an object), FileGet reads only the variable data. The record
 * length specified by the RecordLength clause in the FileOpen function must be greater
 * than or equal to the length of the data being read.
 * <LI>FileGet reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePut) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions.
 * The record length specified by the RecordLength clause in the FileOpen function must
 * be greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 *
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGet reads all
 * variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGet reads only the data. No
 * descriptor is read.
 * <LI>FileGet reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string. For example, the following statements read 11 bytes
 * from file number 1:
 * <PRE>
 * Dim hellow As New String(" ", 11)
 * FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 * FileGet(1, hellow)
 * Console.WriteLine(hellow)
 * FileClose(1)
 * </PRE>
 * </UL>
 *
 * @see FileOpen FileOpen Function
 * @see FilePut FilePut Function
 * @see Seek Seek Function
 * @see FileGetObject FileGetObject Function
 */
procedure FileGet(
   ByVal FileNumber As Integer,
   ByRef Value As Boolean,
   Optional RecordNumber As Integer = -1
);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name into which data is read.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic and so whether to write an
 *                        array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a two-byte descriptor for the string
 *                              describing the length. The default is False.
 *
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * FileGet is only valid in Random and Binary mode.
 *
 * Data read with FileGet is usually written to a file with FilePut.
 *
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte following
 * the last FileGet or FilePut function (or pointed to by the last Seek function) is read.
 *
 * For files opened in Random mode, the following rules apply:
 *
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGet reads subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because
 * the amount of padding data can't be determined with any certainty, it is generally a
 * good idea to have the record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGet reads a two-byte
 * descriptor containing the string length and then reads the data that goes into the
 * variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * put to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you have a choice as to whether
 * to read a descriptor for the size and dimension of the array. To write the descriptor,
 * set the ArrayIsDynamic parameter to True. When reading the array, you need to match
 * the way the array was written. If it was written with the descriptor, then you need to
 * read the descriptor. If the descriptor is not used, then the size and bounds of the
 * array passed into FileGet will be used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk.
 *
 * <pre>
 * Dim MyArray(4,9) As Integer
 * </pre>
 *
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 *
 * <LI>If the variable being read into is any other type of variable (not a
 * variable-length string or an object), FileGet reads only the variable data. The record
 * length specified by the RecordLength clause in the FileOpen function must be greater
 * than or equal to the length of the data being read.
 * <LI>FileGet reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePut) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions.
 * The record length specified by the RecordLength clause in the FileOpen function must
 * be greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 *
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGet reads all
 * variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGet reads only the data. No
 * descriptor is read.
 * <LI>FileGet reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string. For example, the following statements read 11 bytes
 * from file number 1:
 * <PRE>
 * Dim hellow As New String(" ", 11)
 * FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 * FileGet(1, hellow)
 * Console.WriteLine(hellow)
 * FileClose(1)
 * </PRE>
 * </UL>
 *
 * @see FileOpen FileOpen Function
 * @see FilePut FilePut Function
 * @see Seek Seek Function
 * @see FileGetObject FileGetObject Function
 */
procedure FileGet(
   ByVal FileNumber As Integer,
   ByRef Value As Date,
   Optional RecordNumber As Integer = -1
);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name into which data is read.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic and so whether to write an
 *                        array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a two-byte descriptor for the string
 *                              describing the length. The default is False.
 *
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * FileGet is only valid in Random and Binary mode.
 *
 * Data read with FileGet is usually written to a file with FilePut.
 *
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte following
 * the last FileGet or FilePut function (or pointed to by the last Seek function) is read.
 *
 * For files opened in Random mode, the following rules apply:
 *
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGet reads subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because
 * the amount of padding data can't be determined with any certainty, it is generally a
 * good idea to have the record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGet reads a two-byte
 * descriptor containing the string length and then reads the data that goes into the
 * variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * put to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you have a choice as to whether
 * to read a descriptor for the size and dimension of the array. To write the descriptor,
 * set the ArrayIsDynamic parameter to True. When reading the array, you need to match
 * the way the array was written. If it was written with the descriptor, then you need to
 * read the descriptor. If the descriptor is not used, then the size and bounds of the
 * array passed into FileGet will be used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk.
 *
 * <pre>
 * Dim MyArray(4,9) As Integer
 * </pre>
 *
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 *
 * <LI>If the variable being read into is any other type of variable (not a
 * variable-length string or an object), FileGet reads only the variable data. The record
 * length specified by the RecordLength clause in the FileOpen function must be greater
 * than or equal to the length of the data being read.
 * <LI>FileGet reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePut) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions.
 * The record length specified by the RecordLength clause in the FileOpen function must
 * be greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 *
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGet reads all
 * variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGet reads only the data. No
 * descriptor is read.
 * <LI>FileGet reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string. For example, the following statements read 11 bytes
 * from file number 1:
 * <PRE>
 * Dim hellow As New String(" ", 11)
 * FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 * FileGet(1, hellow)
 * Console.WriteLine(hellow)
 * FileClose(1)
 * </PRE>
 * </UL>
 *
 * @see FileOpen FileOpen Function
 * @see FilePut FilePut Function
 * @see Seek Seek Function
 * @see FileGetObject FileGetObject Function
 */
procedure FileGet(
   ByVal FileNumber As Integer,
   ByRef Value As System.Array,
   Optional RecordNumber As Integer = -1,
   Optional ArrayIsDynamic as Boolean = False
);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name into which data is read.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic and so whether to write an
 *                        array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a two-byte descriptor for the string
 *                              describing the length. The default is False.
 *
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * FileGet is only valid in Random and Binary mode.
 *
 * Data read with FileGet is usually written to a file with FilePut.
 *
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte following
 * the last FileGet or FilePut function (or pointed to by the last Seek function) is read.
 *
 * For files opened in Random mode, the following rules apply:
 *
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGet reads subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because
 * the amount of padding data can't be determined with any certainty, it is generally a
 * good idea to have the record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGet reads a two-byte
 * descriptor containing the string length and then reads the data that goes into the
 * variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * put to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you have a choice as to whether
 * to read a descriptor for the size and dimension of the array. To write the descriptor,
 * set the ArrayIsDynamic parameter to True. When reading the array, you need to match
 * the way the array was written. If it was written with the descriptor, then you need to
 * read the descriptor. If the descriptor is not used, then the size and bounds of the
 * array passed into FileGet will be used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk.
 *
 * <pre>
 * Dim MyArray(4,9) As Integer
 * </pre>
 *
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 *
 * <LI>If the variable being read into is any other type of variable (not a
 * variable-length string or an object), FileGet reads only the variable data. The record
 * length specified by the RecordLength clause in the FileOpen function must be greater
 * than or equal to the length of the data being read.
 * <LI>FileGet reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePut) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions.
 * The record length specified by the RecordLength clause in the FileOpen function must
 * be greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 *
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGet reads all
 * variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGet reads only the data. No
 * descriptor is read.
 * <LI>FileGet reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string. For example, the following statements read 11 bytes
 * from file number 1:
 * <PRE>
 * Dim hellow As New String(" ", 11)
 * FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 * FileGet(1, hellow)
 * Console.WriteLine(hellow)
 * FileClose(1)
 * </PRE>
 * </UL>
 *
 * @see FileOpen FileOpen Function
 * @see FilePut FilePut Function
 * @see Seek Seek Function
 * @see FileGetObject FileGetObject Function
 */
procedure FileGet(
   ByVal FileNumber As Integer,
   ByRef Value As String,
   Optional RecordNumber As Integer = -1,
   Optional StringIsFixedLength as Boolean = False
);


/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber     Required. Any valid file number.
 * @param Value          Required. Valid variable name into which data is read.
 * @param RecordNumber   Optional. Record number (Random mode files) or byte number
 *                       (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic Optional. Applies only when writing an array. Specifies whether
 *                       the array is to be treated as dynamic and so whether to write an
 *                       array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength  Optional. Applies only when writing a string. Specifies
 *                             whether to write a two-byte descriptor for the string
 *                             describing the length. The default is False.
 *
 * <b>Remarks</b>
 * <P>
 * The FileGetObject function is used in place of FileGet to avoid ambiguities at compile
 * time if type Object is returned rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * If you intend to write out the Variant type, FileGetObject is required. When in doubt,
 * if you are using an object for the second parameter, it is always safer to use
 * FilePutObject and FileGetObject.
 * <P>
 * FileGetObject is only valid in Random and Binary mode.
 * <P>
 * Data read with FileGetObject is usually written with FilePutObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FileGetObject reads the record or byte
 * after the last FileGetObject or FilePutObject function (or pointed to by the last Seek
 * function).
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGetObject reads subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is a good idea to have the
 * record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGetObject reads a
 * two-byte descriptor containing the string length and then reads the data that goes into
 * the variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * read to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you can choose to read a
 * descriptor for the size and dimension of the array. To read the descriptor, set the
 * ArrayIsDynamic parameter to True. When reading the array, you need to match the way
 * the array was written. If it was written with the descriptor, you need to read the
 * descriptor. If the descriptor is not used, the size and bounds of the array passed
 * into FileGetObject is used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk:
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 * <LI>FileGetObject reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePutObject) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions. The
 * record length specified by the RecordLength clause in the FileOpen function must be
 * greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGetObject
 * reads all variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGetObject reads only the data.
 * No descriptor is read.
 * </UL>
 * FileGetObject reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string.
 *
 * @example
 * The following example reads a record into a test file and then retrieves it.
 *
 * <PRE>
 * Dim c As String
 * FileSystem.FileOpen(1, "test.dat", OpenMode.Binary)
 * FileSystem.FilePutObject(1, "ABCDEF")
 * FileSystem.Seek(1, 1)
 * FileSystem.FileGetObject(1, c)
 * System.Console.WriteLine(c)
 * FileSystem.FileClose(1)
 * </PRE>
 *
 * @see FilePut FilePut Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FileGet FileGet Function
 */
procedure FileGetObject(
   ByVal FileNumber As Integer,
   ByRef Value As Object,
   Optional RecordNumber As Integer = -1
);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber     Required. Any valid file number.
 * @param Value          Required. Valid variable name into which data is read.
 * @param RecordNumber   Optional. Record number (Random mode files) or byte number
 *                       (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic Optional. Applies only when writing an array. Specifies whether
 *                       the array is to be treated as dynamic and so whether to write an
 *                       array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength  Optional. Applies only when writing a string. Specifies
 *                             whether to write a two-byte descriptor for the string
 *                             describing the length. The default is False.
 *
 * <b>Remarks</b>
 * <P>
 * The FileGetObject function is used in place of FileGet to avoid ambiguities at compile
 * time if type Object is returned rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * If you intend to write out the Variant type, FileGetObject is required. When in doubt,
 * if you are using an object for the second parameter, it is always safer to use
 * FilePutObject and FileGetObject.
 * <P>
 * FileGetObject is only valid in Random and Binary mode.
 * <P>
 * Data read with FileGetObject is usually written with FilePutObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FileGetObject reads the record or byte
 * after the last FileGetObject or FilePutObject function (or pointed to by the last Seek
 * function).
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGetObject reads subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is a good idea to have the
 * record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGetObject reads a
 * two-byte descriptor containing the string length and then reads the data that goes into
 * the variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * read to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you can choose to read a
 * descriptor for the size and dimension of the array. To read the descriptor, set the
 * ArrayIsDynamic parameter to True. When reading the array, you need to match the way
 * the array was written. If it was written with the descriptor, you need to read the
 * descriptor. If the descriptor is not used, the size and bounds of the array passed
 * into FileGetObject is used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk:
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 * <LI>FileGetObject reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePutObject) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions. The
 * record length specified by the RecordLength clause in the FileOpen function must be
 * greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGetObject
 * reads all variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGetObject reads only the data.
 * No descriptor is read.
 * </UL>
 * FileGetObject reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string.
 *
 * @example
 * The following example reads a record into a test file and then retrieves it.
 *
 * <PRE>
 * Dim c As String
 * FileSystem.FileOpen(1, "test.dat", OpenMode.Binary)
 * FileSystem.FilePutObject(1, "ABCDEF")
 * FileSystem.Seek(1, 1)
 * FileSystem.FileGetObject(1, c)
 * System.Console.WriteLine(c)
 * FileSystem.FileClose(1)
 * </PRE>
 *
 * @see FilePut FilePut Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FileGet FileGet Function
 */
procedure FileGetObject(
   ByVal FileNumber As Integer,
   ByRef Value As Short,
   Optional RecordNumber As Integer = -1
);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber     Required. Any valid file number.
 * @param Value          Required. Valid variable name into which data is read.
 * @param RecordNumber   Optional. Record number (Random mode files) or byte number
 *                       (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic Optional. Applies only when writing an array. Specifies whether
 *                       the array is to be treated as dynamic and so whether to write an
 *                       array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength  Optional. Applies only when writing a string. Specifies
 *                             whether to write a two-byte descriptor for the string
 *                             describing the length. The default is False.
 *
 * <b>Remarks</b>
 * <P>
 * The FileGetObject function is used in place of FileGet to avoid ambiguities at compile
 * time if type Object is returned rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * If you intend to write out the Variant type, FileGetObject is required. When in doubt,
 * if you are using an object for the second parameter, it is always safer to use
 * FilePutObject and FileGetObject.
 * <P>
 * FileGetObject is only valid in Random and Binary mode.
 * <P>
 * Data read with FileGetObject is usually written with FilePutObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FileGetObject reads the record or byte
 * after the last FileGetObject or FilePutObject function (or pointed to by the last Seek
 * function).
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGetObject reads subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is a good idea to have the
 * record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGetObject reads a
 * two-byte descriptor containing the string length and then reads the data that goes into
 * the variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * read to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you can choose to read a
 * descriptor for the size and dimension of the array. To read the descriptor, set the
 * ArrayIsDynamic parameter to True. When reading the array, you need to match the way
 * the array was written. If it was written with the descriptor, you need to read the
 * descriptor. If the descriptor is not used, the size and bounds of the array passed
 * into FileGetObject is used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk:
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 * <LI>FileGetObject reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePutObject) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions. The
 * record length specified by the RecordLength clause in the FileOpen function must be
 * greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGetObject
 * reads all variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGetObject reads only the data.
 * No descriptor is read.
 * </UL>
 * FileGetObject reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string.
 *
 * @example
 * The following example reads a record into a test file and then retrieves it.
 *
 * <PRE>
 * Dim c As String
 * FileSystem.FileOpen(1, "test.dat", OpenMode.Binary)
 * FileSystem.FilePutObject(1, "ABCDEF")
 * FileSystem.Seek(1, 1)
 * FileSystem.FileGetObject(1, c)
 * System.Console.WriteLine(c)
 * FileSystem.FileClose(1)
 * </PRE>
 *
 * @see FilePut FilePut Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FileGet FileGet Function
 */
procedure FileGetObject(
   ByVal FileNumber As Integer,
   ByRef Value As Integer,
   Optional RecordNumber As Integer = -1);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber     Required. Any valid file number.
 * @param Value          Required. Valid variable name into which data is read.
 * @param RecordNumber   Optional. Record number (Random mode files) or byte number
 *                       (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic Optional. Applies only when writing an array. Specifies whether
 *                       the array is to be treated as dynamic and so whether to write an
 *                       array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength  Optional. Applies only when writing a string. Specifies
 *                             whether to write a two-byte descriptor for the string
 *                             describing the length. The default is False.
 *
 * <b>Remarks</b>
 * <P>
 * The FileGetObject function is used in place of FileGet to avoid ambiguities at compile
 * time if type Object is returned rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * If you intend to write out the Variant type, FileGetObject is required. When in doubt,
 * if you are using an object for the second parameter, it is always safer to use
 * FilePutObject and FileGetObject.
 * <P>
 * FileGetObject is only valid in Random and Binary mode.
 * <P>
 * Data read with FileGetObject is usually written with FilePutObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FileGetObject reads the record or byte
 * after the last FileGetObject or FilePutObject function (or pointed to by the last Seek
 * function).
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGetObject reads subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is a good idea to have the
 * record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGetObject reads a
 * two-byte descriptor containing the string length and then reads the data that goes into
 * the variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * read to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you can choose to read a
 * descriptor for the size and dimension of the array. To read the descriptor, set the
 * ArrayIsDynamic parameter to True. When reading the array, you need to match the way
 * the array was written. If it was written with the descriptor, you need to read the
 * descriptor. If the descriptor is not used, the size and bounds of the array passed
 * into FileGetObject is used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk:
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 * <LI>FileGetObject reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePutObject) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions. The
 * record length specified by the RecordLength clause in the FileOpen function must be
 * greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGetObject
 * reads all variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGetObject reads only the data.
 * No descriptor is read.
 * </UL>
 * FileGetObject reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string.
 *
 * @example
 * The following example reads a record into a test file and then retrieves it.
 *
 * <PRE>
 * Dim c As String
 * FileSystem.FileOpen(1, "test.dat", OpenMode.Binary)
 * FileSystem.FilePutObject(1, "ABCDEF")
 * FileSystem.Seek(1, 1)
 * FileSystem.FileGetObject(1, c)
 * System.Console.WriteLine(c)
 * FileSystem.FileClose(1)
 * </PRE>
 *
 * @see FilePut FilePut Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FileGet FileGet Function
 */
procedure FileGetObject(
   ByVal FileNumber As Integer,
   ByRef Value As Single,
   Optional RecordNumber As Integer = -1
);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber     Required. Any valid file number.
 * @param Value          Required. Valid variable name into which data is read.
 * @param RecordNumber   Optional. Record number (Random mode files) or byte number
 *                       (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic Optional. Applies only when writing an array. Specifies whether
 *                       the array is to be treated as dynamic and so whether to write an
 *                       array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength  Optional. Applies only when writing a string. Specifies
 *                             whether to write a two-byte descriptor for the string
 *                             describing the length. The default is False.
 *
 * <b>Remarks</b>
 * <P>
 * The FileGetObject function is used in place of FileGet to avoid ambiguities at compile
 * time if type Object is returned rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * If you intend to write out the Variant type, FileGetObject is required. When in doubt,
 * if you are using an object for the second parameter, it is always safer to use
 * FilePutObject and FileGetObject.
 * <P>
 * FileGetObject is only valid in Random and Binary mode.
 * <P>
 * Data read with FileGetObject is usually written with FilePutObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FileGetObject reads the record or byte
 * after the last FileGetObject or FilePutObject function (or pointed to by the last Seek
 * function).
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGetObject reads subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is a good idea to have the
 * record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGetObject reads a
 * two-byte descriptor containing the string length and then reads the data that goes into
 * the variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * read to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you can choose to read a
 * descriptor for the size and dimension of the array. To read the descriptor, set the
 * ArrayIsDynamic parameter to True. When reading the array, you need to match the way
 * the array was written. If it was written with the descriptor, you need to read the
 * descriptor. If the descriptor is not used, the size and bounds of the array passed
 * into FileGetObject is used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk:
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 * <LI>FileGetObject reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePutObject) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions. The
 * record length specified by the RecordLength clause in the FileOpen function must be
 * greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGetObject
 * reads all variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGetObject reads only the data.
 * No descriptor is read.
 * </UL>
 * FileGetObject reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string.
 *
 * @example
 * The following example reads a record into a test file and then retrieves it.
 *
 * <PRE>
 * Dim c As String
 * FileSystem.FileOpen(1, "test.dat", OpenMode.Binary)
 * FileSystem.FilePutObject(1, "ABCDEF")
 * FileSystem.Seek(1, 1)
 * FileSystem.FileGetObject(1, c)
 * System.Console.WriteLine(c)
 * FileSystem.FileClose(1)
 * </PRE>
 *
 * @see FilePut FilePut Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FileGet FileGet Function
 */
procedure FileGetObject(
   ByVal FileNumber As Integer,
   ByRef Value As Double,
   Optional RecordNumber As Integer = -1
);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber     Required. Any valid file number.
 * @param Value          Required. Valid variable name into which data is read.
 * @param RecordNumber   Optional. Record number (Random mode files) or byte number
 *                       (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic Optional. Applies only when writing an array. Specifies whether
 *                       the array is to be treated as dynamic and so whether to write an
 *                       array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength  Optional. Applies only when writing a string. Specifies
 *                             whether to write a two-byte descriptor for the string
 *                             describing the length. The default is False.
 *
 * <b>Remarks</b>
 * <P>
 * The FileGetObject function is used in place of FileGet to avoid ambiguities at compile
 * time if type Object is returned rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * If you intend to write out the Variant type, FileGetObject is required. When in doubt,
 * if you are using an object for the second parameter, it is always safer to use
 * FilePutObject and FileGetObject.
 * <P>
 * FileGetObject is only valid in Random and Binary mode.
 * <P>
 * Data read with FileGetObject is usually written with FilePutObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FileGetObject reads the record or byte
 * after the last FileGetObject or FilePutObject function (or pointed to by the last Seek
 * function).
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGetObject reads subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is a good idea to have the
 * record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGetObject reads a
 * two-byte descriptor containing the string length and then reads the data that goes into
 * the variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * read to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you can choose to read a
 * descriptor for the size and dimension of the array. To read the descriptor, set the
 * ArrayIsDynamic parameter to True. When reading the array, you need to match the way
 * the array was written. If it was written with the descriptor, you need to read the
 * descriptor. If the descriptor is not used, the size and bounds of the array passed
 * into FileGetObject is used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk:
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 * <LI>FileGetObject reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePutObject) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions. The
 * record length specified by the RecordLength clause in the FileOpen function must be
 * greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGetObject
 * reads all variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGetObject reads only the data.
 * No descriptor is read.
 * </UL>
 * FileGetObject reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string.
 *
 * @example
 * The following example reads a record into a test file and then retrieves it.
 *
 * <PRE>
 * Dim c As String
 * FileSystem.FileOpen(1, "test.dat", OpenMode.Binary)
 * FileSystem.FilePutObject(1, "ABCDEF")
 * FileSystem.Seek(1, 1)
 * FileSystem.FileGetObject(1, c)
 * System.Console.WriteLine(c)
 * FileSystem.FileClose(1)
 * </PRE>
 *
 * @see FilePut FilePut Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FileGet FileGet Function
 */
procedure FileGetObject(
   ByVal FileNumber As Integer,
   ByRef Value As Decimal,
   Optional RecordNumber As Integer = -1
);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber     Required. Any valid file number.
 * @param Value          Required. Valid variable name into which data is read.
 * @param RecordNumber   Optional. Record number (Random mode files) or byte number
 *                       (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic Optional. Applies only when writing an array. Specifies whether
 *                       the array is to be treated as dynamic and so whether to write an
 *                       array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength  Optional. Applies only when writing a string. Specifies
 *                             whether to write a two-byte descriptor for the string
 *                             describing the length. The default is False.
 *
 * <b>Remarks</b>
 * <P>
 * The FileGetObject function is used in place of FileGet to avoid ambiguities at compile
 * time if type Object is returned rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * If you intend to write out the Variant type, FileGetObject is required. When in doubt,
 * if you are using an object for the second parameter, it is always safer to use
 * FilePutObject and FileGetObject.
 * <P>
 * FileGetObject is only valid in Random and Binary mode.
 * <P>
 * Data read with FileGetObject is usually written with FilePutObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FileGetObject reads the record or byte
 * after the last FileGetObject or FilePutObject function (or pointed to by the last Seek
 * function).
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGetObject reads subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is a good idea to have the
 * record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGetObject reads a
 * two-byte descriptor containing the string length and then reads the data that goes into
 * the variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * read to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you can choose to read a
 * descriptor for the size and dimension of the array. To read the descriptor, set the
 * ArrayIsDynamic parameter to True. When reading the array, you need to match the way
 * the array was written. If it was written with the descriptor, you need to read the
 * descriptor. If the descriptor is not used, the size and bounds of the array passed
 * into FileGetObject is used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk:
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 * <LI>FileGetObject reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePutObject) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions. The
 * record length specified by the RecordLength clause in the FileOpen function must be
 * greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGetObject
 * reads all variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGetObject reads only the data.
 * No descriptor is read.
 * </UL>
 * FileGetObject reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string.
 *
 * @example
 * The following example reads a record into a test file and then retrieves it.
 *
 * <PRE>
 * Dim c As String
 * FileSystem.FileOpen(1, "test.dat", OpenMode.Binary)
 * FileSystem.FilePutObject(1, "ABCDEF")
 * FileSystem.Seek(1, 1)
 * FileSystem.FileGetObject(1, c)
 * System.Console.WriteLine(c)
 * FileSystem.FileClose(1)
 * </PRE>
 *
 * @see FilePut FilePut Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FileGet FileGet Function
 */
procedure FileGetObject(
   ByVal FileNumber As Integer,
   ByRef Value As Byte,
   Optional RecordNumber As Integer = -1
);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber     Required. Any valid file number.
 * @param Value          Required. Valid variable name into which data is read.
 * @param RecordNumber   Optional. Record number (Random mode files) or byte number
 *                       (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic Optional. Applies only when writing an array. Specifies whether
 *                       the array is to be treated as dynamic and so whether to write an
 *                       array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength  Optional. Applies only when writing a string. Specifies
 *                             whether to write a two-byte descriptor for the string
 *                             describing the length. The default is False.
 *
 * <b>Remarks</b>
 * <P>
 * The FileGetObject function is used in place of FileGet to avoid ambiguities at compile
 * time if type Object is returned rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * If you intend to write out the Variant type, FileGetObject is required. When in doubt,
 * if you are using an object for the second parameter, it is always safer to use
 * FilePutObject and FileGetObject.
 * <P>
 * FileGetObject is only valid in Random and Binary mode.
 * <P>
 * Data read with FileGetObject is usually written with FilePutObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FileGetObject reads the record or byte
 * after the last FileGetObject or FilePutObject function (or pointed to by the last Seek
 * function).
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGetObject reads subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is a good idea to have the
 * record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGetObject reads a
 * two-byte descriptor containing the string length and then reads the data that goes into
 * the variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * read to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you can choose to read a
 * descriptor for the size and dimension of the array. To read the descriptor, set the
 * ArrayIsDynamic parameter to True. When reading the array, you need to match the way
 * the array was written. If it was written with the descriptor, you need to read the
 * descriptor. If the descriptor is not used, the size and bounds of the array passed
 * into FileGetObject is used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk:
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 * <LI>FileGetObject reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePutObject) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions. The
 * record length specified by the RecordLength clause in the FileOpen function must be
 * greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGetObject
 * reads all variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGetObject reads only the data.
 * No descriptor is read.
 * </UL>
 * FileGetObject reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string.
 *
 * @example
 * The following example reads a record into a test file and then retrieves it.
 *
 * <PRE>
 * Dim c As String
 * FileSystem.FileOpen(1, "test.dat", OpenMode.Binary)
 * FileSystem.FilePutObject(1, "ABCDEF")
 * FileSystem.Seek(1, 1)
 * FileSystem.FileGetObject(1, c)
 * System.Console.WriteLine(c)
 * FileSystem.FileClose(1)
 * </PRE>
 *
 * @see FilePut FilePut Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FileGet FileGet Function
 */
procedure FileGetObject(
   ByVal FileNumber As Integer,
   ByRef Value As Boolean,
   Optional RecordNumber As Integer = -1
);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber     Required. Any valid file number.
 * @param Value          Required. Valid variable name into which data is read.
 * @param RecordNumber   Optional. Record number (Random mode files) or byte number
 *                       (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic Optional. Applies only when writing an array. Specifies whether
 *                       the array is to be treated as dynamic and so whether to write an
 *                       array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength  Optional. Applies only when writing a string. Specifies
 *                             whether to write a two-byte descriptor for the string
 *                             describing the length. The default is False.
 *
 * <b>Remarks</b>
 * <P>
 * The FileGetObject function is used in place of FileGet to avoid ambiguities at compile
 * time if type Object is returned rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * If you intend to write out the Variant type, FileGetObject is required. When in doubt,
 * if you are using an object for the second parameter, it is always safer to use
 * FilePutObject and FileGetObject.
 * <P>
 * FileGetObject is only valid in Random and Binary mode.
 * <P>
 * Data read with FileGetObject is usually written with FilePutObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FileGetObject reads the record or byte
 * after the last FileGetObject or FilePutObject function (or pointed to by the last Seek
 * function).
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGetObject reads subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is a good idea to have the
 * record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGetObject reads a
 * two-byte descriptor containing the string length and then reads the data that goes into
 * the variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * read to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you can choose to read a
 * descriptor for the size and dimension of the array. To read the descriptor, set the
 * ArrayIsDynamic parameter to True. When reading the array, you need to match the way
 * the array was written. If it was written with the descriptor, you need to read the
 * descriptor. If the descriptor is not used, the size and bounds of the array passed
 * into FileGetObject is used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk:
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 * <LI>FileGetObject reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePutObject) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions. The
 * record length specified by the RecordLength clause in the FileOpen function must be
 * greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGetObject
 * reads all variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGetObject reads only the data.
 * No descriptor is read.
 * </UL>
 * FileGetObject reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string.
 *
 * @example
 * The following example reads a record into a test file and then retrieves it.
 *
 * <PRE>
 * Dim c As String
 * FileSystem.FileOpen(1, "test.dat", OpenMode.Binary)
 * FileSystem.FilePutObject(1, "ABCDEF")
 * FileSystem.Seek(1, 1)
 * FileSystem.FileGetObject(1, c)
 * System.Console.WriteLine(c)
 * FileSystem.FileClose(1)
 * </PRE>
 *
 * @see FilePut FilePut Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FileGet FileGet Function
 */
procedure FileGetObject(
   ByVal FileNumber As Integer,
   ByRef Value As Date,
   Optional RecordNumber As Integer = -1
);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber     Required. Any valid file number.
 * @param Value          Required. Valid variable name into which data is read.
 * @param RecordNumber   Optional. Record number (Random mode files) or byte number
 *                       (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic Optional. Applies only when writing an array. Specifies whether
 *                       the array is to be treated as dynamic and so whether to write an
 *                       array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength  Optional. Applies only when writing a string. Specifies
 *                             whether to write a two-byte descriptor for the string
 *                             describing the length. The default is False.
 *
 * <b>Remarks</b>
 * <P>
 * The FileGetObject function is used in place of FileGet to avoid ambiguities at compile
 * time if type Object is returned rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * If you intend to write out the Variant type, FileGetObject is required. When in doubt,
 * if you are using an object for the second parameter, it is always safer to use
 * FilePutObject and FileGetObject.
 * <P>
 * FileGetObject is only valid in Random and Binary mode.
 * <P>
 * Data read with FileGetObject is usually written with FilePutObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FileGetObject reads the record or byte
 * after the last FileGetObject or FilePutObject function (or pointed to by the last Seek
 * function).
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGetObject reads subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is a good idea to have the
 * record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGetObject reads a
 * two-byte descriptor containing the string length and then reads the data that goes into
 * the variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * read to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you can choose to read a
 * descriptor for the size and dimension of the array. To read the descriptor, set the
 * ArrayIsDynamic parameter to True. When reading the array, you need to match the way
 * the array was written. If it was written with the descriptor, you need to read the
 * descriptor. If the descriptor is not used, the size and bounds of the array passed
 * into FileGetObject is used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk:
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 * <LI>FileGetObject reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePutObject) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions. The
 * record length specified by the RecordLength clause in the FileOpen function must be
 * greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGetObject
 * reads all variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGetObject reads only the data.
 * No descriptor is read.
 * </UL>
 * FileGetObject reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string.
 *
 * @example
 * The following example reads a record into a test file and then retrieves it.
 *
 * <PRE>
 * Dim c As String
 * FileSystem.FileOpen(1, "test.dat", OpenMode.Binary)
 * FileSystem.FilePutObject(1, "ABCDEF")
 * FileSystem.Seek(1, 1)
 * FileSystem.FileGetObject(1, c)
 * System.Console.WriteLine(c)
 * FileSystem.FileClose(1)
 * </PRE>
 *
 * @see FilePut FilePut Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FileGet FileGet Function
 */
procedure FileGetObject(
   ByVal FileNumber As Integer,
   ByRef Value As System.Array,
   Optional RecordNumber As Integer = -1,
   Optional ArrayIsDynamic as Boolean = False
);

/**
 * Reads data from an open disk file into a variable.
 *
 * @param FileNumber     Required. Any valid file number.
 * @param Value          Required. Valid variable name into which data is read.
 * @param RecordNumber   Optional. Record number (Random mode files) or byte number
 *                       (Binary mode files) at which reading begins.
 * @param ArrayIsDynamic Optional. Applies only when writing an array. Specifies whether
 *                       the array is to be treated as dynamic and so whether to write an
 *                       array descriptor describing the size and bounds of the array.
 * @param StringIsFixedLength  Optional. Applies only when writing a string. Specifies
 *                             whether to write a two-byte descriptor for the string
 *                             describing the length. The default is False.
 *
 * <b>Remarks</b>
 * <P>
 * The FileGetObject function is used in place of FileGet to avoid ambiguities at compile
 * time if type Object is returned rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * If you intend to write out the Variant type, FileGetObject is required. When in doubt,
 * if you are using an object for the second parameter, it is always safer to use
 * FilePutObject and FileGetObject.
 * <P>
 * FileGetObject is only valid in Random and Binary mode.
 * <P>
 * Data read with FileGetObject is usually written with FilePutObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FileGetObject reads the record or byte
 * after the last FileGetObject or FilePutObject function (or pointed to by the last Seek
 * function).
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being read is less than the length specified in the
 * RecordLength clause of the FileOpen function, FileGetObject reads subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is a good idea to have the
 * record length match the length of the data being read.
 * <LI>If the variable being read into is a string, by default FileGetObject reads a
 * two-byte descriptor containing the string length and then reads the data that goes into
 * the variable. Therefore, the record length specified by the RecordLength clause of the
 * FileOpen function must be at least two bytes greater than the actual length of the
 * string. Visual Basic 6 and earlier versions supported fixed-length strings and when
 * read to a file, the length descriptor would not be written. If you wish to read a
 * string without the descriptor, you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being read into is an array, then you can choose to read a
 * descriptor for the size and dimension of the array. To read the descriptor, set the
 * ArrayIsDynamic parameter to True. When reading the array, you need to match the way
 * the array was written. If it was written with the descriptor, you need to read the
 * descriptor. If the descriptor is not used, the size and bounds of the array passed
 * into FileGetObject is used to determine what to read.
 * <LI>The descriptor specifies the rank of the array, the size, and the lower bounds for
 * each rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength parameter
 * in the FileOpen function must be greater than or equal to the sum of all the bytes
 * required to write the array data and the array descriptor. For example, the following
 * array declaration requires 118 bytes when the array is written to disk:
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * The 118 bytes are distributed as follows: 18 bytes for the descriptor (2 + 8 * 2),
 * and 100 bytes for the data (5 * 10 * 2).
 * <LI>FileGetObject reads elements of structures as if each were being read individually,
 * except that there is no padding between elements. On disk, a dynamic array in a
 * user-defined type (written with FilePutObject) is prefixed by a descriptor whose length
 * equals 2 plus 8 times the number of dimensions, that is, 2 + 8 * NumberOfDimensions. The
 * record length specified by the RecordLength clause in the FileOpen function must be
 * greater than or equal to the sum of all the bytes required to read the individual
 * elements, including any arrays and their descriptors. The VBFixedString attribute can
 * be applied to string fields in the structures to indicate the size of string when
 * written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FileGetObject
 * reads all variables from disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FileGetObject reads only the data.
 * No descriptor is read.
 * </UL>
 * FileGetObject reads variable-length strings that aren't elements of structures without
 * expecting the two-byte length descriptor. The number of bytes read equals the number of
 * characters already in the string.
 *
 * @example
 * The following example reads a record into a test file and then retrieves it.
 *
 * <PRE>
 * Dim c As String
 * FileSystem.FileOpen(1, "test.dat", OpenMode.Binary)
 * FileSystem.FilePutObject(1, "ABCDEF")
 * FileSystem.Seek(1, 1)
 * FileSystem.FileGetObject(1, c)
 * System.Console.WriteLine(c)
 * FileSystem.FileClose(1)
 * </PRE>
 *
 * @see FilePut FilePut Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FileGet FileGet Function
 */
procedure FileGetObject(
   ByVal FileNumber As Integer,
   ByRef Value As String,
   Optional RecordNumber As Integer = -1,
   Optional StringIsFixedLength as Boolean = False
);

/**
 * Returns a Long value specifying the length of a file in bytes.
 *
 * @param PathName  Required. String expression that specifies a file. PathName may
 *                  include the directory or folder, and the drive.
 *
 * @exception FileNotFoundException   File does not exist.
 *
 * <b>Remarks</b>
 * <P>
 * If the specified file is open when the FileLen function is called, the value returned
 * represents the size of the file at the time it was opened.
 * <P>
 * Note   To obtain the current length of an open file, use the LOF function.
 *
 * @example
 * <P>
 * This example uses the FileLen function to return the length of a file in bytes. For
 * purposes of this example, assume that TESTFILE is a file containing some data.
 *
 * <PRE>
 * Dim MySize As Long
 * MySize = FileLen("TESTFILE")   ' Returns file length (bytes).
 * </PRE>
 *
 * @see FileDateTime FileDateTime Function
 * @see GetAttr GetAttr Function
 * @see LOF LOF Function
 */
function Long FileLen(ByVal PathName As String);

/**
 * Opens a file for input or output.
 *
 * @param FileNumber   Required. Any valid file number. Use the FreeFile function to
 *                     obtain the next available file number.
 * @param FileName     Required. String expression that specifies a file name  may
 *                     include directory or folder, and drive.
 * @param Mode         Required. Enum specifying the file mode: Append, Binary, Input,
 *                     Output, or Random.
 * @param Access       Optional. Keyword specifying the operations permitted on the open
 *                     file: Read, Write, or ReadWrite. Defaults to ReadWrite.
 * @param Share        Optional. Enum specifying the operations restricted on the open
 *                     file by other processes: Shared, Lock Read, Lock Write, and Lock
 *                     Read Write. Defaults to Shared.
 * @param RecordLength Optional. Number less than or equal to 32,767 (bytes). For files
 *                     opened for random access, this value is the record length. For
 *                     sequential files, this value is the number of characters buffered.
 *
 * @exception ArgumentException   Invalid Access, Share, or Mode.
 * @exception ArgumentException   WriteOnly file is opened for Input.
 * @exception ArgumentException   ReadOnly file is opened for Output.
 * @exception ArgumentException   ReadOnly file is opened for Append.
 * @exception ArgumentException   Record length is negative (and not equal to -1).
 * @exception IOException         FileNumber is invalid (<-1 or >255), or FileNumber is
 *                                already in use.
 * @exception IOException         FileName is already open, or FileName is invalid.
 *
 * <b>Remarks</b>
 * <P>
 * You must open a file before any I/O operation can be performed on it. FileOpen
 * allocates a buffer for I/O to the file and determines the mode of access to use with
 * the buffer.
 * <P>
 * If the file specified by FileName doesn't exist, it is created when a file is opened
 * for Append, Binary, Output, or Random modes.
 * <P>
 * The channel to open can be found using the FreeFile() function.
 *
 * @example
 * <P>
 * This example illustrates various uses of the FileOpen function to enable input and
 * output to a file.
 *
 * <P>
 * The following code opens the file TESTFILE in Input mode.
 * <PRE>
 * FileOpen(1, "TESTFILE", OpenMode.Input)
 * ' Close before reopening in another mode.
 * FileClose(1)
 * </PRE>
 *
 * <P>
 * This example opens the file in Binary mode for writing operations only.
 * <PRE>
 * FileOpen(1, "TESTFILE", OpenMode.Binary,OpenAccess.Write)
 * ' Close before reopening in another mode.
 * FileClose(1)
 * </PRE>
 *
 * <P>
 * The following example opens the file in Random mode. The file contains records of the
 * structure Person.
 * <PRE>
 * Structure Person
 * <VBFixedString(30)> Dim Name As String
 * Dim ID As Integer
 * End Structure
 * ' Count 30 for the string, plus 4 for the integer.
 * FileOpen(1, "TESTFILE", OpenMode.Random, , , 34)
 * ' Close before reopening in another mode.
 * FileClose(1)
 * </PRE>
 *
 * <P>
 * This code example opens the file in Output mode; any process can read or write to file.
 * <PRE>
 * FileOpen(1, "TESTFILE", OpenMode.Output, OpenShare.Shared)
 * ' Close before reopening in another mode.
 * FileClose(1)
 * </PRE>
 * <P>
 * This code example opens the file in Binary mode for reading; other processes can't
 * read file.
 * <PRE>
 * FileOpen(1, "TESTFILE", OpenMode.Binary, OpenAccess.Read, OpenShare.LockRead)
 * </PRE>
 *
 * @see FileClose FileClose Function
 * @see FreeFile FreeFile Function
 */
procedure FileOpen(
   ByVal FileNumber As Integer,
   ByVal FileName As String,
   ByVal Mode As OpenMode,
   Optional ByVal Access As OpenAccess = OpenAccess.Default,
   Optional ByVal Share As OpenShare = OpenShare.Default,
   Optional ByVal RecordLength As Integer = -1
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name containing data written to disk.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength    Optional. Applies only when writing a string. Specifies
 *                               whether to write a two-byte string length descriptor for
 *                               the string to the file. The default is False
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * <P>
 * FilePut is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePut is usually read from a file with FileGet.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte after the
 * last FileGet or FilePut function or pointed to by the last Seek function is written.
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePut does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePut, you will need to
 * do the same with FileGet, and also make sure the string is initialized to the length
 * expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePut writes subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning of
 * the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be determined with any certainty, it is generally a good
 * idea to have the record length match the length of the data being written. If the
 * length of the data being written is greater than the length specified in the
 * RecordLength clause of the FileOpen function, an exception will be thrown.
 * <LI>If the variable being written is a string, FilePut writes a two-byte descriptor
 * containing the string length, and then writes the data that goes into the variable.
 * Therefore, the record length specified by the RecordLength clause in the FileOpen
 * function must be at least two bytes greater than the actual length of the string.
 * <LI>If the variable being written is an object containing a numeric type, FilePut
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePut writes six bytes:
 * two bytes identifying the object as VarType(3) (Integer) and four bytes containing the
 * data. The record length specified by the RecordLength parameter in the FileOpen
 * function must be at least two bytes greater than the actual number of bytes required
 * to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePut writes a
 * two byte descriptor identifying the VarType(8) of the object, a two-byte descriptor
 * indicating the length of the string, and then writes the string data. The record
 * length specified by the RecordLength parameter in the FileOpen function must be at
 * least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, then you have a choice as to whether or
 * not to write a descriptor for the size and dimensions of the array. Visual Basic 6 and
 * earlier versions would write the file descriptor for a dynamic array, but not for a
 * fixed-size array. Visual Basic .NET defaults to not writing the descriptor. To write
 * the descriptor, set the ArrayIsDynamic parameter to True. When writing the array, you
 * need to match the way the array will be read; if it will be read with the descriptor,
 * then you need to write the descriptor. The descriptor specifies the rank of the array,
 * the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the
 * number of dimensions, that is, 2 + 8 * NumberOfDimensions. The record length specified
 * by the RecordLength clause in the FileOpen function must be greater than or equal to
 * the sum of all the bytes required to write the array data and the array descriptor.
 * For example, the following array declaration requires 118 bytes when the array is
 * written to disk.
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * <LI>If the variable being written is any other type of variable (not a variable-length
 * string or an object), FilePut writes only the variable data. The record length
 * specified by the RecordLength clause in the FileOpen function must be greater than or
 * equal to the length of the data being written.
 * <LI>FilePut writes elements of structures as if each were written individually, except
 * there is no padding between elements. The VBFixedString attribute can be applied to
 * string fields in the structures to indicate the size of the string when written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePut writes all
 * variables to disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FilePut writes only the data. No
 * descriptor is written.
 * <LI>FilePut writes variable-length strings that are not elements of structures without
 * the two-byte length descriptor. The number of bytes written equals the number of
 * characters in the string. For example, the following statements write 11 bytes to
 * file number 1:
 * <PRE>
 * Dim hellow As String = "Hello World"
 * FilePut(1,hellow)
 * </PRE>
 *
 * @example
 * <P>
 * This example uses the FilePut function to write data to a file. Five records of the
 * structure Person are written to the file.
 * <PRE>
 * Structure Person
 *   Public ID As Integer
 *   Public Name As String
 * End Structure
 *
 * Sub WriteData()
 *   Dim MyRecord As Person
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     MyRecord.ID = recordNumber   ' Define ID.
 *     MyRecord.Name = "My Name" & recordNumber   ' Create a string.
 *     FilePut(1, MyRecord)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 */
procedure FilePut(
   FileNumber As Integer,
   Value As Short,
   Optional RecordNumber As Integer = -1
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name containing data written to disk.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength    Optional. Applies only when writing a string. Specifies
 *                               whether to write a two-byte string length descriptor for
 *                               the string to the file. The default is False
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * <P>
 * FilePut is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePut is usually read from a file with FileGet.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte after the
 * last FileGet or FilePut function or pointed to by the last Seek function is written.
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePut does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePut, you will need to
 * do the same with FileGet, and also make sure the string is initialized to the length
 * expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePut writes subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning of
 * the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be determined with any certainty, it is generally a good
 * idea to have the record length match the length of the data being written. If the
 * length of the data being written is greater than the length specified in the
 * RecordLength clause of the FileOpen function, an exception will be thrown.
 * <LI>If the variable being written is a string, FilePut writes a two-byte descriptor
 * containing the string length, and then writes the data that goes into the variable.
 * Therefore, the record length specified by the RecordLength clause in the FileOpen
 * function must be at least two bytes greater than the actual length of the string.
 * <LI>If the variable being written is an object containing a numeric type, FilePut
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePut writes six bytes:
 * two bytes identifying the object as VarType(3) (Integer) and four bytes containing the
 * data. The record length specified by the RecordLength parameter in the FileOpen
 * function must be at least two bytes greater than the actual number of bytes required
 * to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePut writes a
 * two byte descriptor identifying the VarType(8) of the object, a two-byte descriptor
 * indicating the length of the string, and then writes the string data. The record
 * length specified by the RecordLength parameter in the FileOpen function must be at
 * least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, then you have a choice as to whether or
 * not to write a descriptor for the size and dimensions of the array. Visual Basic 6 and
 * earlier versions would write the file descriptor for a dynamic array, but not for a
 * fixed-size array. Visual Basic .NET defaults to not writing the descriptor. To write
 * the descriptor, set the ArrayIsDynamic parameter to True. When writing the array, you
 * need to match the way the array will be read; if it will be read with the descriptor,
 * then you need to write the descriptor. The descriptor specifies the rank of the array,
 * the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the
 * number of dimensions, that is, 2 + 8 * NumberOfDimensions. The record length specified
 * by the RecordLength clause in the FileOpen function must be greater than or equal to
 * the sum of all the bytes required to write the array data and the array descriptor.
 * For example, the following array declaration requires 118 bytes when the array is
 * written to disk.
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * <LI>If the variable being written is any other type of variable (not a variable-length
 * string or an object), FilePut writes only the variable data. The record length
 * specified by the RecordLength clause in the FileOpen function must be greater than or
 * equal to the length of the data being written.
 * <LI>FilePut writes elements of structures as if each were written individually, except
 * there is no padding between elements. The VBFixedString attribute can be applied to
 * string fields in the structures to indicate the size of the string when written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePut writes all
 * variables to disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FilePut writes only the data. No
 * descriptor is written.
 * <LI>FilePut writes variable-length strings that are not elements of structures without
 * the two-byte length descriptor. The number of bytes written equals the number of
 * characters in the string. For example, the following statements write 11 bytes to
 * file number 1:
 * <PRE>
 * Dim hellow As String = "Hello World"
 * FilePut(1,hellow)
 * </PRE>
 *
 * @example
 * <P>
 * This example uses the FilePut function to write data to a file. Five records of the
 * structure Person are written to the file.
 * <PRE>
 * Structure Person
 *   Public ID As Integer
 *   Public Name As String
 * End Structure
 *
 * Sub WriteData()
 *   Dim MyRecord As Person
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     MyRecord.ID = recordNumber   ' Define ID.
 *     MyRecord.Name = "My Name" & recordNumber   ' Create a string.
 *     FilePut(1, MyRecord)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 */
procedure FilePut(
   FileNumber As Integer,
   Value As Integer,
   Optional RecordNumber As Integer = -1
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name containing data written to disk.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength    Optional. Applies only when writing a string. Specifies
 *                               whether to write a two-byte string length descriptor for
 *                               the string to the file. The default is False
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * <P>
 * FilePut is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePut is usually read from a file with FileGet.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte after the
 * last FileGet or FilePut function or pointed to by the last Seek function is written.
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePut does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePut, you will need to
 * do the same with FileGet, and also make sure the string is initialized to the length
 * expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePut writes subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning of
 * the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be determined with any certainty, it is generally a good
 * idea to have the record length match the length of the data being written. If the
 * length of the data being written is greater than the length specified in the
 * RecordLength clause of the FileOpen function, an exception will be thrown.
 * <LI>If the variable being written is a string, FilePut writes a two-byte descriptor
 * containing the string length, and then writes the data that goes into the variable.
 * Therefore, the record length specified by the RecordLength clause in the FileOpen
 * function must be at least two bytes greater than the actual length of the string.
 * <LI>If the variable being written is an object containing a numeric type, FilePut
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePut writes six bytes:
 * two bytes identifying the object as VarType(3) (Integer) and four bytes containing the
 * data. The record length specified by the RecordLength parameter in the FileOpen
 * function must be at least two bytes greater than the actual number of bytes required
 * to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePut writes a
 * two byte descriptor identifying the VarType(8) of the object, a two-byte descriptor
 * indicating the length of the string, and then writes the string data. The record
 * length specified by the RecordLength parameter in the FileOpen function must be at
 * least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, then you have a choice as to whether or
 * not to write a descriptor for the size and dimensions of the array. Visual Basic 6 and
 * earlier versions would write the file descriptor for a dynamic array, but not for a
 * fixed-size array. Visual Basic .NET defaults to not writing the descriptor. To write
 * the descriptor, set the ArrayIsDynamic parameter to True. When writing the array, you
 * need to match the way the array will be read; if it will be read with the descriptor,
 * then you need to write the descriptor. The descriptor specifies the rank of the array,
 * the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the
 * number of dimensions, that is, 2 + 8 * NumberOfDimensions. The record length specified
 * by the RecordLength clause in the FileOpen function must be greater than or equal to
 * the sum of all the bytes required to write the array data and the array descriptor.
 * For example, the following array declaration requires 118 bytes when the array is
 * written to disk.
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * <LI>If the variable being written is any other type of variable (not a variable-length
 * string or an object), FilePut writes only the variable data. The record length
 * specified by the RecordLength clause in the FileOpen function must be greater than or
 * equal to the length of the data being written.
 * <LI>FilePut writes elements of structures as if each were written individually, except
 * there is no padding between elements. The VBFixedString attribute can be applied to
 * string fields in the structures to indicate the size of the string when written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePut writes all
 * variables to disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FilePut writes only the data. No
 * descriptor is written.
 * <LI>FilePut writes variable-length strings that are not elements of structures without
 * the two-byte length descriptor. The number of bytes written equals the number of
 * characters in the string. For example, the following statements write 11 bytes to
 * file number 1:
 * <PRE>
 * Dim hellow As String = "Hello World"
 * FilePut(1,hellow)
 * </PRE>
 *
 * @example
 * <P>
 * This example uses the FilePut function to write data to a file. Five records of the
 * structure Person are written to the file.
 * <PRE>
 * Structure Person
 *   Public ID As Integer
 *   Public Name As String
 * End Structure
 *
 * Sub WriteData()
 *   Dim MyRecord As Person
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     MyRecord.ID = recordNumber   ' Define ID.
 *     MyRecord.Name = "My Name" & recordNumber   ' Create a string.
 *     FilePut(1, MyRecord)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 */
procedure FilePut(
   FileNumber As Integer,
   Value As Single,
   Optional RecordNumber As Integer = -1
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name containing data written to disk.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength    Optional. Applies only when writing a string. Specifies
 *                               whether to write a two-byte string length descriptor for
 *                               the string to the file. The default is False
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * <P>
 * FilePut is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePut is usually read from a file with FileGet.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte after the
 * last FileGet or FilePut function or pointed to by the last Seek function is written.
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePut does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePut, you will need to
 * do the same with FileGet, and also make sure the string is initialized to the length
 * expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePut writes subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning of
 * the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be determined with any certainty, it is generally a good
 * idea to have the record length match the length of the data being written. If the
 * length of the data being written is greater than the length specified in the
 * RecordLength clause of the FileOpen function, an exception will be thrown.
 * <LI>If the variable being written is a string, FilePut writes a two-byte descriptor
 * containing the string length, and then writes the data that goes into the variable.
 * Therefore, the record length specified by the RecordLength clause in the FileOpen
 * function must be at least two bytes greater than the actual length of the string.
 * <LI>If the variable being written is an object containing a numeric type, FilePut
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePut writes six bytes:
 * two bytes identifying the object as VarType(3) (Integer) and four bytes containing the
 * data. The record length specified by the RecordLength parameter in the FileOpen
 * function must be at least two bytes greater than the actual number of bytes required
 * to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePut writes a
 * two byte descriptor identifying the VarType(8) of the object, a two-byte descriptor
 * indicating the length of the string, and then writes the string data. The record
 * length specified by the RecordLength parameter in the FileOpen function must be at
 * least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, then you have a choice as to whether or
 * not to write a descriptor for the size and dimensions of the array. Visual Basic 6 and
 * earlier versions would write the file descriptor for a dynamic array, but not for a
 * fixed-size array. Visual Basic .NET defaults to not writing the descriptor. To write
 * the descriptor, set the ArrayIsDynamic parameter to True. When writing the array, you
 * need to match the way the array will be read; if it will be read with the descriptor,
 * then you need to write the descriptor. The descriptor specifies the rank of the array,
 * the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the
 * number of dimensions, that is, 2 + 8 * NumberOfDimensions. The record length specified
 * by the RecordLength clause in the FileOpen function must be greater than or equal to
 * the sum of all the bytes required to write the array data and the array descriptor.
 * For example, the following array declaration requires 118 bytes when the array is
 * written to disk.
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * <LI>If the variable being written is any other type of variable (not a variable-length
 * string or an object), FilePut writes only the variable data. The record length
 * specified by the RecordLength clause in the FileOpen function must be greater than or
 * equal to the length of the data being written.
 * <LI>FilePut writes elements of structures as if each were written individually, except
 * there is no padding between elements. The VBFixedString attribute can be applied to
 * string fields in the structures to indicate the size of the string when written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePut writes all
 * variables to disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FilePut writes only the data. No
 * descriptor is written.
 * <LI>FilePut writes variable-length strings that are not elements of structures without
 * the two-byte length descriptor. The number of bytes written equals the number of
 * characters in the string. For example, the following statements write 11 bytes to
 * file number 1:
 * <PRE>
 * Dim hellow As String = "Hello World"
 * FilePut(1,hellow)
 * </PRE>
 *
 * @example
 * <P>
 * This example uses the FilePut function to write data to a file. Five records of the
 * structure Person are written to the file.
 * <PRE>
 * Structure Person
 *   Public ID As Integer
 *   Public Name As String
 * End Structure
 *
 * Sub WriteData()
 *   Dim MyRecord As Person
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     MyRecord.ID = recordNumber   ' Define ID.
 *     MyRecord.Name = "My Name" & recordNumber   ' Create a string.
 *     FilePut(1, MyRecord)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 */
procedure FilePut(
   FileNumber As Integer,
   Value As Double,
   RecordNumber As Integer = -1
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name containing data written to disk.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength    Optional. Applies only when writing a string. Specifies
 *                               whether to write a two-byte string length descriptor for
 *                               the string to the file. The default is False
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * <P>
 * FilePut is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePut is usually read from a file with FileGet.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte after the
 * last FileGet or FilePut function or pointed to by the last Seek function is written.
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePut does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePut, you will need to
 * do the same with FileGet, and also make sure the string is initialized to the length
 * expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePut writes subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning of
 * the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be determined with any certainty, it is generally a good
 * idea to have the record length match the length of the data being written. If the
 * length of the data being written is greater than the length specified in the
 * RecordLength clause of the FileOpen function, an exception will be thrown.
 * <LI>If the variable being written is a string, FilePut writes a two-byte descriptor
 * containing the string length, and then writes the data that goes into the variable.
 * Therefore, the record length specified by the RecordLength clause in the FileOpen
 * function must be at least two bytes greater than the actual length of the string.
 * <LI>If the variable being written is an object containing a numeric type, FilePut
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePut writes six bytes:
 * two bytes identifying the object as VarType(3) (Integer) and four bytes containing the
 * data. The record length specified by the RecordLength parameter in the FileOpen
 * function must be at least two bytes greater than the actual number of bytes required
 * to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePut writes a
 * two byte descriptor identifying the VarType(8) of the object, a two-byte descriptor
 * indicating the length of the string, and then writes the string data. The record
 * length specified by the RecordLength parameter in the FileOpen function must be at
 * least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, then you have a choice as to whether or
 * not to write a descriptor for the size and dimensions of the array. Visual Basic 6 and
 * earlier versions would write the file descriptor for a dynamic array, but not for a
 * fixed-size array. Visual Basic .NET defaults to not writing the descriptor. To write
 * the descriptor, set the ArrayIsDynamic parameter to True. When writing the array, you
 * need to match the way the array will be read; if it will be read with the descriptor,
 * then you need to write the descriptor. The descriptor specifies the rank of the array,
 * the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the
 * number of dimensions, that is, 2 + 8 * NumberOfDimensions. The record length specified
 * by the RecordLength clause in the FileOpen function must be greater than or equal to
 * the sum of all the bytes required to write the array data and the array descriptor.
 * For example, the following array declaration requires 118 bytes when the array is
 * written to disk.
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * <LI>If the variable being written is any other type of variable (not a variable-length
 * string or an object), FilePut writes only the variable data. The record length
 * specified by the RecordLength clause in the FileOpen function must be greater than or
 * equal to the length of the data being written.
 * <LI>FilePut writes elements of structures as if each were written individually, except
 * there is no padding between elements. The VBFixedString attribute can be applied to
 * string fields in the structures to indicate the size of the string when written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePut writes all
 * variables to disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FilePut writes only the data. No
 * descriptor is written.
 * <LI>FilePut writes variable-length strings that are not elements of structures without
 * the two-byte length descriptor. The number of bytes written equals the number of
 * characters in the string. For example, the following statements write 11 bytes to
 * file number 1:
 * <PRE>
 * Dim hellow As String = "Hello World"
 * FilePut(1,hellow)
 * </PRE>
 *
 *@example
 * <P>
 * This example uses the FilePut function to write data to a file. Five records of the
 * structure Person are written to the file.
 * <PRE>
 * Structure Person
 *   Public ID As Integer
 *   Public Name As String
 * End Structure
 *
 * Sub WriteData()
 *   Dim MyRecord As Person
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     MyRecord.ID = recordNumber   ' Define ID.
 *     MyRecord.Name = "My Name" & recordNumber   ' Create a string.
 *     FilePut(1, MyRecord)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 */
procedure FilePut(
   FileNumber As Integer,
   Value As Decimal,
   Optional RecordNumber As Integer = -1
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name containing data written to disk.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength    Optional. Applies only when writing a string. Specifies
 *                               whether to write a two-byte string length descriptor for
 *                               the string to the file. The default is False
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * <P>
 * FilePut is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePut is usually read from a file with FileGet.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte after the
 * last FileGet or FilePut function or pointed to by the last Seek function is written.
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePut does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePut, you will need to
 * do the same with FileGet, and also make sure the string is initialized to the length
 * expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePut writes subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning of
 * the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be determined with any certainty, it is generally a good
 * idea to have the record length match the length of the data being written. If the
 * length of the data being written is greater than the length specified in the
 * RecordLength clause of the FileOpen function, an exception will be thrown.
 * <LI>If the variable being written is a string, FilePut writes a two-byte descriptor
 * containing the string length, and then writes the data that goes into the variable.
 * Therefore, the record length specified by the RecordLength clause in the FileOpen
 * function must be at least two bytes greater than the actual length of the string.
 * <LI>If the variable being written is an object containing a numeric type, FilePut
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePut writes six bytes:
 * two bytes identifying the object as VarType(3) (Integer) and four bytes containing the
 * data. The record length specified by the RecordLength parameter in the FileOpen
 * function must be at least two bytes greater than the actual number of bytes required
 * to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePut writes a
 * two byte descriptor identifying the VarType(8) of the object, a two-byte descriptor
 * indicating the length of the string, and then writes the string data. The record
 * length specified by the RecordLength parameter in the FileOpen function must be at
 * least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, then you have a choice as to whether or
 * not to write a descriptor for the size and dimensions of the array. Visual Basic 6 and
 * earlier versions would write the file descriptor for a dynamic array, but not for a
 * fixed-size array. Visual Basic .NET defaults to not writing the descriptor. To write
 * the descriptor, set the ArrayIsDynamic parameter to True. When writing the array, you
 * need to match the way the array will be read; if it will be read with the descriptor,
 * then you need to write the descriptor. The descriptor specifies the rank of the array,
 * the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the
 * number of dimensions, that is, 2 + 8 * NumberOfDimensions. The record length specified
 * by the RecordLength clause in the FileOpen function must be greater than or equal to
 * the sum of all the bytes required to write the array data and the array descriptor.
 * For example, the following array declaration requires 118 bytes when the array is
 * written to disk.
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * <LI>If the variable being written is any other type of variable (not a variable-length
 * string or an object), FilePut writes only the variable data. The record length
 * specified by the RecordLength clause in the FileOpen function must be greater than or
 * equal to the length of the data being written.
 * <LI>FilePut writes elements of structures as if each were written individually, except
 * there is no padding between elements. The VBFixedString attribute can be applied to
 * string fields in the structures to indicate the size of the string when written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePut writes all
 * variables to disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FilePut writes only the data. No
 * descriptor is written.
 * <LI>FilePut writes variable-length strings that are not elements of structures without
 * the two-byte length descriptor. The number of bytes written equals the number of
 * characters in the string. For example, the following statements write 11 bytes to
 * file number 1:
 * <PRE>
 * Dim hellow As String = "Hello World"
 * FilePut(1,hellow)
 * </PRE>
 *
 * @example
 * <P>
 * This example uses the FilePut function to write data to a file. Five records of the
 * structure Person are written to the file.
 * <PRE>
 * Structure Person
 *   Public ID As Integer
 *   Public Name As String
 * End Structure
 *
 * Sub WriteData()
 *   Dim MyRecord As Person
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     MyRecord.ID = recordNumber   ' Define ID.
 *     MyRecord.Name = "My Name" & recordNumber   ' Create a string.
 *     FilePut(1, MyRecord)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 */
procedure FilePut(
   FileNumber As Integer,
   Value As Byte,
   Optional RecordNumber As Integer = -1
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name containing data written to disk.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength    Optional. Applies only when writing a string. Specifies
 *                               whether to write a two-byte string length descriptor for
 *                               the string to the file. The default is False
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * <P>
 * FilePut is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePut is usually read from a file with FileGet.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte after the
 * last FileGet or FilePut function or pointed to by the last Seek function is written.
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePut does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePut, you will need to
 * do the same with FileGet, and also make sure the string is initialized to the length
 * expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePut writes subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning of
 * the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be determined with any certainty, it is generally a good
 * idea to have the record length match the length of the data being written. If the
 * length of the data being written is greater than the length specified in the
 * RecordLength clause of the FileOpen function, an exception will be thrown.
 * <LI>If the variable being written is a string, FilePut writes a two-byte descriptor
 * containing the string length, and then writes the data that goes into the variable.
 * Therefore, the record length specified by the RecordLength clause in the FileOpen
 * function must be at least two bytes greater than the actual length of the string.
 * <LI>If the variable being written is an object containing a numeric type, FilePut
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePut writes six bytes:
 * two bytes identifying the object as VarType(3) (Integer) and four bytes containing the
 * data. The record length specified by the RecordLength parameter in the FileOpen
 * function must be at least two bytes greater than the actual number of bytes required
 * to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePut writes a
 * two byte descriptor identifying the VarType(8) of the object, a two-byte descriptor
 * indicating the length of the string, and then writes the string data. The record
 * length specified by the RecordLength parameter in the FileOpen function must be at
 * least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, then you have a choice as to whether or
 * not to write a descriptor for the size and dimensions of the array. Visual Basic 6 and
 * earlier versions would write the file descriptor for a dynamic array, but not for a
 * fixed-size array. Visual Basic .NET defaults to not writing the descriptor. To write
 * the descriptor, set the ArrayIsDynamic parameter to True. When writing the array, you
 * need to match the way the array will be read; if it will be read with the descriptor,
 * then you need to write the descriptor. The descriptor specifies the rank of the array,
 * the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the
 * number of dimensions, that is, 2 + 8 * NumberOfDimensions. The record length specified
 * by the RecordLength clause in the FileOpen function must be greater than or equal to
 * the sum of all the bytes required to write the array data and the array descriptor.
 * For example, the following array declaration requires 118 bytes when the array is
 * written to disk.
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * <LI>If the variable being written is any other type of variable (not a variable-length
 * string or an object), FilePut writes only the variable data. The record length
 * specified by the RecordLength clause in the FileOpen function must be greater than or
 * equal to the length of the data being written.
 * <LI>FilePut writes elements of structures as if each were written individually, except
 * there is no padding between elements. The VBFixedString attribute can be applied to
 * string fields in the structures to indicate the size of the string when written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePut writes all
 * variables to disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FilePut writes only the data. No
 * descriptor is written.
 * <LI>FilePut writes variable-length strings that are not elements of structures without
 * the two-byte length descriptor. The number of bytes written equals the number of
 * characters in the string. For example, the following statements write 11 bytes to
 * file number 1:
 * <PRE>
 * Dim hellow As String = "Hello World"
 * FilePut(1,hellow)
 * </PRE>
 *
 * @example
 * <P>
 * This example uses the FilePut function to write data to a file. Five records of the
 * structure Person are written to the file.
 * <PRE>
 * Structure Person
 *   Public ID As Integer
 *   Public Name As String
 * End Structure
 *
 * Sub WriteData()
 *   Dim MyRecord As Person
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     MyRecord.ID = recordNumber   ' Define ID.
 *     MyRecord.Name = "My Name" & recordNumber   ' Create a string.
 *     FilePut(1, MyRecord)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 */
procedure FilePut(
   FileNumber As Integer,
   Value As Boolean,
   Optional RecordNumber As Integer = -1
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name containing data written to disk.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength    Optional. Applies only when writing a string. Specifies
 *                               whether to write a two-byte string length descriptor for
 *                               the string to the file. The default is False
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * <P>
 * FilePut is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePut is usually read from a file with FileGet.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte after the
 * last FileGet or FilePut function or pointed to by the last Seek function is written.
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePut does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePut, you will need to
 * do the same with FileGet, and also make sure the string is initialized to the length
 * expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePut writes subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning of
 * the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be determined with any certainty, it is generally a good
 * idea to have the record length match the length of the data being written. If the
 * length of the data being written is greater than the length specified in the
 * RecordLength clause of the FileOpen function, an exception will be thrown.
 * <LI>If the variable being written is a string, FilePut writes a two-byte descriptor
 * containing the string length, and then writes the data that goes into the variable.
 * Therefore, the record length specified by the RecordLength clause in the FileOpen
 * function must be at least two bytes greater than the actual length of the string.
 * <LI>If the variable being written is an object containing a numeric type, FilePut
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePut writes six bytes:
 * two bytes identifying the object as VarType(3) (Integer) and four bytes containing the
 * data. The record length specified by the RecordLength parameter in the FileOpen
 * function must be at least two bytes greater than the actual number of bytes required
 * to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePut writes a
 * two byte descriptor identifying the VarType(8) of the object, a two-byte descriptor
 * indicating the length of the string, and then writes the string data. The record
 * length specified by the RecordLength parameter in the FileOpen function must be at
 * least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, then you have a choice as to whether or
 * not to write a descriptor for the size and dimensions of the array. Visual Basic 6 and
 * earlier versions would write the file descriptor for a dynamic array, but not for a
 * fixed-size array. Visual Basic .NET defaults to not writing the descriptor. To write
 * the descriptor, set the ArrayIsDynamic parameter to True. When writing the array, you
 * need to match the way the array will be read; if it will be read with the descriptor,
 * then you need to write the descriptor. The descriptor specifies the rank of the array,
 * the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the
 * number of dimensions, that is, 2 + 8 * NumberOfDimensions. The record length specified
 * by the RecordLength clause in the FileOpen function must be greater than or equal to
 * the sum of all the bytes required to write the array data and the array descriptor.
 * For example, the following array declaration requires 118 bytes when the array is
 * written to disk.
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * <LI>If the variable being written is any other type of variable (not a variable-length
 * string or an object), FilePut writes only the variable data. The record length
 * specified by the RecordLength clause in the FileOpen function must be greater than or
 * equal to the length of the data being written.
 * <LI>FilePut writes elements of structures as if each were written individually, except
 * there is no padding between elements. The VBFixedString attribute can be applied to
 * string fields in the structures to indicate the size of the string when written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePut writes all
 * variables to disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FilePut writes only the data. No
 * descriptor is written.
 * <LI>FilePut writes variable-length strings that are not elements of structures without
 * the two-byte length descriptor. The number of bytes written equals the number of
 * characters in the string. For example, the following statements write 11 bytes to
 * file number 1:
 * <PRE>
 * Dim hellow As String = "Hello World"
 * FilePut(1,hellow)
 * </PRE>
 *
 * @example
 * <P>
 * This example uses the FilePut function to write data to a file. Five records of the
 * structure Person are written to the file.
 * <PRE>
 * Structure Person
 *   Public ID As Integer
 *   Public Name As String
 * End Structure
 *
 * Sub WriteData()
 *   Dim MyRecord As Person
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     MyRecord.ID = recordNumber   ' Define ID.
 *     MyRecord.Name = "My Name" & recordNumber   ' Create a string.
 *     FilePut(1, MyRecord)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 */
procedure FilePut(
   FileNumber As Integer,
   Value As Date,
   Optional RecordNumber As Integer = -1
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name containing data written to disk.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength    Optional. Applies only when writing a string. Specifies
 *                               whether to write a two-byte string length descriptor for
 *                               the string to the file. The default is False
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * <P>
 * FilePut is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePut is usually read from a file with FileGet.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte after the
 * last FileGet or FilePut function or pointed to by the last Seek function is written.
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePut does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePut, you will need to
 * do the same with FileGet, and also make sure the string is initialized to the length
 * expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePut writes subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning of
 * the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be determined with any certainty, it is generally a good
 * idea to have the record length match the length of the data being written. If the
 * length of the data being written is greater than the length specified in the
 * RecordLength clause of the FileOpen function, an exception will be thrown.
 * <LI>If the variable being written is a string, FilePut writes a two-byte descriptor
 * containing the string length, and then writes the data that goes into the variable.
 * Therefore, the record length specified by the RecordLength clause in the FileOpen
 * function must be at least two bytes greater than the actual length of the string.
 * <LI>If the variable being written is an object containing a numeric type, FilePut
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePut writes six bytes:
 * two bytes identifying the object as VarType(3) (Integer) and four bytes containing the
 * data. The record length specified by the RecordLength parameter in the FileOpen
 * function must be at least two bytes greater than the actual number of bytes required
 * to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePut writes a
 * two byte descriptor identifying the VarType(8) of the object, a two-byte descriptor
 * indicating the length of the string, and then writes the string data. The record
 * length specified by the RecordLength parameter in the FileOpen function must be at
 * least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, then you have a choice as to whether or
 * not to write a descriptor for the size and dimensions of the array. Visual Basic 6 and
 * earlier versions would write the file descriptor for a dynamic array, but not for a
 * fixed-size array. Visual Basic .NET defaults to not writing the descriptor. To write
 * the descriptor, set the ArrayIsDynamic parameter to True. When writing the array, you
 * need to match the way the array will be read; if it will be read with the descriptor,
 * then you need to write the descriptor. The descriptor specifies the rank of the array,
 * the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the
 * number of dimensions, that is, 2 + 8 * NumberOfDimensions. The record length specified
 * by the RecordLength clause in the FileOpen function must be greater than or equal to
 * the sum of all the bytes required to write the array data and the array descriptor.
 * For example, the following array declaration requires 118 bytes when the array is
 * written to disk.
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * <LI>If the variable being written is any other type of variable (not a variable-length
 * string or an object), FilePut writes only the variable data. The record length
 * specified by the RecordLength clause in the FileOpen function must be greater than or
 * equal to the length of the data being written.
 * <LI>FilePut writes elements of structures as if each were written individually, except
 * there is no padding between elements. The VBFixedString attribute can be applied to
 * string fields in the structures to indicate the size of the string when written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePut writes all
 * variables to disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FilePut writes only the data. No
 * descriptor is written.
 * <LI>FilePut writes variable-length strings that are not elements of structures without
 * the two-byte length descriptor. The number of bytes written equals the number of
 * characters in the string. For example, the following statements write 11 bytes to
 * file number 1:
 * <PRE>
 * Dim hellow As String = "Hello World"
 * FilePut(1,hellow)
 * </PRE>
 *
 * @example
 * <P>
 * This example uses the FilePut function to write data to a file. Five records of the
 * structure Person are written to the file.
 * <PRE>
 * Structure Person
 *   Public ID As Integer
 *   Public Name As String
 * End Structure
 *
 * Sub WriteData()
 *   Dim MyRecord As Person
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     MyRecord.ID = recordNumber   ' Define ID.
 *     MyRecord.Name = "My Name" & recordNumber   ' Create a string.
 *     FilePut(1, MyRecord)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 */
procedure FilePut(
   FileNumber As Integer,
   Value As System.Array,
   Optional RecordNumber As Integer = -1,
   Optional ArrayIsDynamic As Boolean = False
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber      Required. Any valid file number.
 * @param Value           Required. Valid variable name containing data written to disk.
 * @param RecordNumber    Optional. Record number (Random mode files) or byte number
 *                        (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength    Optional. Applies only when writing a string. Specifies
 *                               whether to write a two-byte string length descriptor for
 *                               the string to the file. The default is False
 * @exception ArgumentException   RecordNumber < 1 and not equal to -1.
 * @exception IOException         FileNumber does not exist.
 * @exception IOException         File mode is invalid.
 *
 * <b>Remarks</b>
 * <P>
 * FilePut is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePut is usually read from a file with FileGet.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte at
 * position 2, and so on. If you omit RecordNumber, the next record or byte after the
 * last FileGet or FilePut function or pointed to by the last Seek function is written.
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePut does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePut, you will need to
 * do the same with FileGet, and also make sure the string is initialized to the length
 * expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePut writes subsequent records on
 * record-length boundaries. The space between the end of one record and the beginning of
 * the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be determined with any certainty, it is generally a good
 * idea to have the record length match the length of the data being written. If the
 * length of the data being written is greater than the length specified in the
 * RecordLength clause of the FileOpen function, an exception will be thrown.
 * <LI>If the variable being written is a string, FilePut writes a two-byte descriptor
 * containing the string length, and then writes the data that goes into the variable.
 * Therefore, the record length specified by the RecordLength clause in the FileOpen
 * function must be at least two bytes greater than the actual length of the string.
 * <LI>If the variable being written is an object containing a numeric type, FilePut
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePut writes six bytes:
 * two bytes identifying the object as VarType(3) (Integer) and four bytes containing the
 * data. The record length specified by the RecordLength parameter in the FileOpen
 * function must be at least two bytes greater than the actual number of bytes required
 * to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePut writes a
 * two byte descriptor identifying the VarType(8) of the object, a two-byte descriptor
 * indicating the length of the string, and then writes the string data. The record
 * length specified by the RecordLength parameter in the FileOpen function must be at
 * least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, then you have a choice as to whether or
 * not to write a descriptor for the size and dimensions of the array. Visual Basic 6 and
 * earlier versions would write the file descriptor for a dynamic array, but not for a
 * fixed-size array. Visual Basic .NET defaults to not writing the descriptor. To write
 * the descriptor, set the ArrayIsDynamic parameter to True. When writing the array, you
 * need to match the way the array will be read; if it will be read with the descriptor,
 * then you need to write the descriptor. The descriptor specifies the rank of the array,
 * the size, and the lower bounds for each rank. Its length equals 2 plus 8 times the
 * number of dimensions, that is, 2 + 8 * NumberOfDimensions. The record length specified
 * by the RecordLength clause in the FileOpen function must be greater than or equal to
 * the sum of all the bytes required to write the array data and the array descriptor.
 * For example, the following array declaration requires 118 bytes when the array is
 * written to disk.
 * <PRE>
 * Dim MyArray(4,9) As Integer
 * </PRE>
 * <LI>If the variable being written is any other type of variable (not a variable-length
 * string or an object), FilePut writes only the variable data. The record length
 * specified by the RecordLength clause in the FileOpen function must be greater than or
 * equal to the length of the data being written.
 * <LI>FilePut writes elements of structures as if each were written individually, except
 * there is no padding between elements. The VBFixedString attribute can be applied to
 * string fields in the structures to indicate the size of the string when written to disk.
 * </UL>
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePut writes all
 * variables to disk contiguously; that is, with no padding between records.
 * <LI>For any array other than an array in a structure, FilePut writes only the data. No
 * descriptor is written.
 * <LI>FilePut writes variable-length strings that are not elements of structures without
 * the two-byte length descriptor. The number of bytes written equals the number of
 * characters in the string. For example, the following statements write 11 bytes to
 * file number 1:
 * <PRE>
 * Dim hellow As String = "Hello World"
 * FilePut(1,hellow)
 * </PRE>
 *
 * @example
 * <P>
 * This example uses the FilePut function to write data to a file. Five records of the
 * structure Person are written to the file.
 * <PRE>
 * Structure Person
 *   Public ID As Integer
 *   Public Name As String
 * End Structure
 *
 * Sub WriteData()
 *   Dim MyRecord As Person
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     MyRecord.ID = recordNumber   ' Define ID.
 *     MyRecord.Name = "My Name" & recordNumber   ' Create a string.
 *     FilePut(1, MyRecord)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 */
procedure FilePut (
   FileNumber As Integer,
   Value As String,
   Optional RecordNumber As Integer = -1,
   Optional StringIsFixedLength As Boolean = False
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber   Required. Any valid file number.
 * @param Value        Required. Valid variable name containing data written to disk.
 * @param RecordNumber Optional. Record number (Random mode files) or byte number
 *                     (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a descriptor for the string describing
 *                              the length. The default is False.
 * <b>Remarks</b>
 * <P>
 * The FilePutObject function is used in place of FilePut to avoid ambiguities at compile
 * time if type Object is passed rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * FilePutObject writes and reads descriptors that describe the object. If you intend to
 * write out the Variant type, FilePutObject is required. When in doubt, if you are using
 * an object for the second parameter, it is always safer to use FilePutObject and
 * FileGetObject.
 * <P>
 * FilePutObject is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePutObject is usually read from a file with FileGetObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FilePutObject writes the next record
 * or byte after the last FileGetObject or FilePutObject function (or the record or byte
 * pointed to by the last Seek function).
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePutObject does not write the length descriptor when the

 * argument is True. If you use StringIsFixedLength = True with FilePutObject, you need
 * to do the same with FileGetObject, and must also make sure that the string is
 * initialized to the length expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePutObject writes subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is generally a good idea to
 * have the record length match the length of the data being written. If the length of the
 * data being written is greater than the length specified in the RecordLength clause of
 * the FileOpen function, an exception is thrown.
 * <LI>If the variable being written is an object containing a numeric type, FilePutObject
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePutObject writes six
 * bytes: two bytes identifying the object as VarType(3) (Integer) and four bytes
 * containing the data. The record length specified by the RecordLength parameter in the
 * FileOpen function must be at least two bytes greater than the actual number of bytes
 * required to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePutObject
 * writes a two-byte descriptor identifying the VarType(8) of the object, a two-byte
 * descriptor indicating the length of the string, and then writes the string data. The
 * record length specified by the RecordLength parameter in the FileOpen function must be
 * at least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, you can choose to write a descriptor
 * for the size and dimensions of the array. Visual Basic 6 and earlier versions would
 * write the file descriptor for a dynamic array, but not for a fixed-size array; Visual
 * Basic .NET defaults to not writing the descriptor. To write the descriptor, set the
 * ArrayIsDynamic parameter to True. When writing the array, you need to match the way
 * the array is read; if it is read with the descriptor, you need to write the descriptor.
 * The descriptor specifies the rank of the array, the size, and the lower bounds for each
 * rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength clause in
 * the FileOpen function must be greater than or equal to the sum of all the bytes required
 * to write the array data and the array descriptor.
 * </UL>
 *
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePutObject
 * writes all variables to disk contiguously, that is, with no padding between records.
 * </UL>
 *
 * @example
 * <P>
 * This example uses the FilePutObject function to write data to a file. Five records of
 * the structure Person are written to the file.
 * <PRE>
 * Sub WriteData()
 *   Dim Person As String
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     Person = "My Name" & recordNumber   ' Create a string.
 *     FilePutObject(1, Person)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FilePut FilePut Function
 */
procedure FilePutObject(
   FileNumber As Integer,
   Value As Object,
   RecordNumber As Integer = -1
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber   Required. Any valid file number.
 * @param Value        Required. Valid variable name containing data written to disk.
 * @param RecordNumber Optional. Record number (Random mode files) or byte number
 *                     (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a descriptor for the string describing
 *                              the length. The default is False.
 * <b>Remarks</b>
 * <P>
 * The FilePutObject function is used in place of FilePut to avoid ambiguities at compile
 * time if type Object is passed rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * FilePutObject writes and reads descriptors that describe the object. If you intend to
 * write out the Variant type, FilePutObject is required. When in doubt, if you are using
 * an object for the second parameter, it is always safer to use FilePutObject and
 * FileGetObject.
 * <P>
 * FilePutObject is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePutObject is usually read from a file with FileGetObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FilePutObject writes the next record
 * or byte after the last FileGetObject or FilePutObject function (or the record or byte
 * pointed to by the last Seek function).
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePutObject does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePutObject, you need
 * to do the same with FileGetObject, and must also make sure that the string is
 * initialized to the length expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePutObject writes subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is generally a good idea to
 * have the record length match the length of the data being written. If the length of the
 * data being written is greater than the length specified in the RecordLength clause of
 * the FileOpen function, an exception is thrown.
 * <LI>If the variable being written is an object containing a numeric type, FilePutObject
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePutObject writes six
 * bytes: two bytes identifying the object as VarType(3) (Integer) and four bytes
 * containing the data. The record length specified by the RecordLength parameter in the
 * FileOpen function must be at least two bytes greater than the actual number of bytes
 * required to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePutObject
 * writes a two-byte descriptor identifying the VarType(8) of the object, a two-byte
 * descriptor indicating the length of the string, and then writes the string data. The
 * record length specified by the RecordLength parameter in the FileOpen function must be
 * at least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, you can choose to write a descriptor
 * for the size and dimensions of the array. Visual Basic 6 and earlier versions would
 * write the file descriptor for a dynamic array, but not for a fixed-size array; Visual
 * Basic .NET defaults to not writing the descriptor. To write the descriptor, set the
 * ArrayIsDynamic parameter to True. When writing the array, you need to match the way
 * the array is read; if it is read with the descriptor, you need to write the descriptor.
 * The descriptor specifies the rank of the array, the size, and the lower bounds for each
 * rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength clause in
 * the FileOpen function must be greater than or equal to the sum of all the bytes required
 * to write the array data and the array descriptor.
 * </UL>
 *
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePutObject
 * writes all variables to disk contiguously, that is, with no padding between records.
 * </UL>
 *
 * @example
 * <P>
 * This example uses the FilePutObject function to write data to a file. Five records of
 * the structure Person are written to the file.
 * <PRE>
 * Sub WriteData()
 *   Dim Person As String
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     Person = "My Name" & recordNumber   ' Create a string.
 *     FilePutObject(1, Person)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FilePut FilePut Function
 */
procedure FilePutObject(
   FileNumber As Integer,
   Value As Short,
   Optional RecordNumber As Integer = -1
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber   Required. Any valid file number.
 * @param Value        Required. Valid variable name containing data written to disk.
 * @param RecordNumber Optional. Record number (Random mode files) or byte number
 *                     (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a descriptor for the string describing
 *                              the length. The default is False.
 * <b>Remarks</b>
 * <P>
 * The FilePutObject function is used in place of FilePut to avoid ambiguities at compile
 * time if type Object is passed rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * FilePutObject writes and reads descriptors that describe the object. If you intend to
 * write out the Variant type, FilePutObject is required. When in doubt, if you are using
 * an object for the second parameter, it is always safer to use FilePutObject and
 * FileGetObject.
 * <P>
 * FilePutObject is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePutObject is usually read from a file with FileGetObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FilePutObject writes the next record
 * or byte after the last FileGetObject or FilePutObject function (or the record or byte
 * pointed to by the last Seek function).
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePutObject does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePutObject, you need
 * to do the same with FileGetObject, and must also make sure that the string is
 * initialized to the length expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePutObject writes subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is generally a good idea to
 * have the record length match the length of the data being written. If the length of the
 * data being written is greater than the length specified in the RecordLength clause of
 * the FileOpen function, an exception is thrown.
 * <LI>If the variable being written is an object containing a numeric type, FilePutObject
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePutObject writes six
 * bytes: two bytes identifying the object as VarType(3) (Integer) and four bytes
 * containing the data. The record length specified by the RecordLength parameter in the
 * FileOpen function must be at least two bytes greater than the actual number of bytes
 * required to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePutObject
 * writes a two-byte descriptor identifying the VarType(8) of the object, a two-byte
 * descriptor indicating the length of the string, and then writes the string data. The
 * record length specified by the RecordLength parameter in the FileOpen function must be
 * at least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, you can choose to write a descriptor
 * for the size and dimensions of the array. Visual Basic 6 and earlier versions would
 * write the file descriptor for a dynamic array, but not for a fixed-size array; Visual
 * Basic .NET defaults to not writing the descriptor. To write the descriptor, set the
 * ArrayIsDynamic parameter to True. When writing the array, you need to match the way
 * the array is read; if it is read with the descriptor, you need to write the descriptor.
 * The descriptor specifies the rank of the array, the size, and the lower bounds for each
 * rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength clause in
 * the FileOpen function must be greater than or equal to the sum of all the bytes required
 * to write the array data and the array descriptor.
 * </UL>
 *
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePutObject
 * writes all variables to disk contiguously, that is, with no padding between records.
 * </UL>
 *
 * @example
 * <P>
 * This example uses the FilePutObject function to write data to a file. Five records of
 * the structure Person are written to the file.
 * <PRE>
 * Sub WriteData()
 *   Dim Person As String
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     Person = "My Name" & recordNumber   ' Create a string.
 *     FilePutObject(1, Person)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FilePut FilePut Function
 */
procedure FilePutObject(
   FileNumber As Integer,
   Value As Integer,
   Optional RecordNumber As Integer = -1
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber   Required. Any valid file number.
 * @param Value        Required. Valid variable name containing data written to disk.
 * @param RecordNumber Optional. Record number (Random mode files) or byte number
 *                     (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a descriptor for the string describing
 *                              the length. The default is False.
 * <b>Remarks</b>
 * <P>
 * The FilePutObject function is used in place of FilePut to avoid ambiguities at compile
 * time if type Object is passed rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * FilePutObject writes and reads descriptors that describe the object. If you intend to
 * write out the Variant type, FilePutObject is required. When in doubt, if you are using
 * an object for the second parameter, it is always safer to use FilePutObject and
 * FileGetObject.
 * <P>
 * FilePutObject is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePutObject is usually read from a file with FileGetObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FilePutObject writes the next record
 * or byte after the last FileGetObject or FilePutObject function (or the record or byte
 * pointed to by the last Seek function).
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePutObject does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePutObject, you need
 * to do the same with FileGetObject, and must also make sure that the string is
 * initialized to the length expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePutObject writes subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is generally a good idea to
 * have the record length match the length of the data being written. If the length of the
 * data being written is greater than the length specified in the RecordLength clause of
 * the FileOpen function, an exception is thrown.
 * <LI>If the variable being written is an object containing a numeric type, FilePutObject
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePutObject writes six
 * bytes: two bytes identifying the object as VarType(3) (Integer) and four bytes
 * containing the data. The record length specified by the RecordLength parameter in the
 * FileOpen function must be at least two bytes greater than the actual number of bytes
 * required to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePutObject
 * writes a two-byte descriptor identifying the VarType(8) of the object, a two-byte
 * descriptor indicating the length of the string, and then writes the string data. The
 * record length specified by the RecordLength parameter in the FileOpen function must be
 * at least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, you can choose to write a descriptor
 * for the size and dimensions of the array. Visual Basic 6 and earlier versions would
 * write the file descriptor for a dynamic array, but not for a fixed-size array; Visual
 * Basic .NET defaults to not writing the descriptor. To write the descriptor, set the
 * ArrayIsDynamic parameter to True. When writing the array, you need to match the way
 * the array is read; if it is read with the descriptor, you need to write the descriptor.
 * The descriptor specifies the rank of the array, the size, and the lower bounds for each
 * rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength clause in
 * the FileOpen function must be greater than or equal to the sum of all the bytes required
 * to write the array data and the array descriptor.
 * </UL>
 *
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePutObject
 * writes all variables to disk contiguously, that is, with no padding between records.
 * </UL>
 *
 * @example
 * <P>
 * This example uses the FilePutObject function to write data to a file. Five records of
 * the structure Person are written to the file.
 * <PRE>
 * Sub WriteData()
 *   Dim Person As String
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     Person = "My Name" & recordNumber   ' Create a string.
 *     FilePutObject(1, Person)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FilePut FilePut Function
 */
procedure FilePutObject(
   FileNumber As Integer,
   Value As Single,
   Optional RecordNumber As Integer = -1
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber   Required. Any valid file number.
 * @param Value        Required. Valid variable name containing data written to disk.
 * @param RecordNumber Optional. Record number (Random mode files) or byte number
 *                     (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a descriptor for the string describing
 *                              the length. The default is False.
 * <b>Remarks</b>
 * <P>
 * The FilePutObject function is used in place of FilePut to avoid ambiguities at compile
 * time if type Object is passed rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * FilePutObject writes and reads descriptors that describe the object. If you intend to
 * write out the Variant type, FilePutObject is required. When in doubt, if you are using
 * an object for the second parameter, it is always safer to use FilePutObject and
 * FileGetObject.
 * <P>
 * FilePutObject is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePutObject is usually read from a file with FileGetObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FilePutObject writes the next record
 * or byte after the last FileGetObject or FilePutObject function (or the record or byte
 * pointed to by the last Seek function).
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePutObject does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePutObject, you need
 * to do the same with FileGetObject, and must also make sure that the string is
 * initialized to the length expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePutObject writes subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is generally a good idea to
 * have the record length match the length of the data being written. If the length of the
 * data being written is greater than the length specified in the RecordLength clause of
 * the FileOpen function, an exception is thrown.
 * <LI>If the variable being written is an object containing a numeric type, FilePutObject
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePutObject writes six
 * bytes: two bytes identifying the object as VarType(3) (Integer) and four bytes
 * containing the data. The record length specified by the RecordLength parameter in the
 * FileOpen function must be at least two bytes greater than the actual number of bytes
 * required to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePutObject
 * writes a two-byte descriptor identifying the VarType(8) of the object, a two-byte
 * descriptor indicating the length of the string, and then writes the string data. The
 * record length specified by the RecordLength parameter in the FileOpen function must be
 * at least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, you can choose to write a descriptor
 * for the size and dimensions of the array. Visual Basic 6 and earlier versions would
 * write the file descriptor for a dynamic array, but not for a fixed-size array; Visual
 * Basic .NET defaults to not writing the descriptor. To write the descriptor, set the
 * ArrayIsDynamic parameter to True. When writing the array, you need to match the way
 * the array is read; if it is read with the descriptor, you need to write the descriptor.
 * The descriptor specifies the rank of the array, the size, and the lower bounds for each
 * rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength clause in
 * the FileOpen function must be greater than or equal to the sum of all the bytes required
 * to write the array data and the array descriptor.
 * </UL>
 *
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePutObject
 * writes all variables to disk contiguously, that is, with no padding between records.
 * </UL>
 *
 * @example
 * <P>
 * This example uses the FilePutObject function to write data to a file. Five records of
 * the structure Person are written to the file.
 * <PRE>
 * Sub WriteData()
 *   Dim Person As String
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     Person = "My Name" & recordNumber   ' Create a string.
 *     FilePutObject(1, Person)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FilePut FilePut Function
 */
procedure FilePutObject(
   FileNumber As Integer,
   Value As Double,
   RecordNumber As Integer = -1
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber   Required. Any valid file number.
 * @param Value        Required. Valid variable name containing data written to disk.
 * @param RecordNumber Optional. Record number (Random mode files) or byte number
 *                     (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a descriptor for the string describing
 *                              the length. The default is False.
 * <b>Remarks</b>
 * <P>
 * The FilePutObject function is used in place of FilePut to avoid ambiguities at compile
 * time if type Object is passed rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * FilePutObject writes and reads descriptors that describe the object. If you intend to
 * write out the Variant type, FilePutObject is required. When in doubt, if you are using
 * an object for the second parameter, it is always safer to use FilePutObject and
 * FileGetObject.
 * <P>
 * FilePutObject is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePutObject is usually read from a file with FileGetObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FilePutObject writes the next record
 * or byte after the last FileGetObject or FilePutObject function (or the record or byte
 * pointed to by the last Seek function).
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePutObject does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePutObject, you need
 * to do the same with FileGetObject, and must also make sure that the string is
 * initialized to the length expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePutObject writes subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is generally a good idea to
 * have the record length match the length of the data being written. If the length of the
 * data being written is greater than the length specified in the RecordLength clause of
 * the FileOpen function, an exception is thrown.
 * <LI>If the variable being written is an object containing a numeric type, FilePutObject
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePutObject writes six
 * bytes: two bytes identifying the object as VarType(3) (Integer) and four bytes
 * containing the data. The record length specified by the RecordLength parameter in the
 * FileOpen function must be at least two bytes greater than the actual number of bytes
 * required to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePutObject
 * writes a two-byte descriptor identifying the VarType(8) of the object, a two-byte
 * descriptor indicating the length of the string, and then writes the string data. The
 * record length specified by the RecordLength parameter in the FileOpen function must be
 * at least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, you can choose to write a descriptor
 * for the size and dimensions of the array. Visual Basic 6 and earlier versions would
 * write the file descriptor for a dynamic array, but not for a fixed-size array; Visual
 * Basic .NET defaults to not writing the descriptor. To write the descriptor, set the
 * ArrayIsDynamic parameter to True. When writing the array, you need to match the way
 * the array is read; if it is read with the descriptor, you need to write the descriptor.
 * The descriptor specifies the rank of the array, the size, and the lower bounds for each
 * rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength clause in
 * the FileOpen function must be greater than or equal to the sum of all the bytes required
 * to write the array data and the array descriptor.
 * </UL>
 *
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePutObject
 * writes all variables to disk contiguously, that is, with no padding between records.
 * </UL>
 *
 * @example
 * <P>
 * This example uses the FilePutObject function to write data to a file. Five records of
 * the structure Person are written to the file.
 * <PRE>
 * Sub WriteData()
 *   Dim Person As String
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     Person = "My Name" & recordNumber   ' Create a string.
 *     FilePutObject(1, Person)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FilePut FilePut Function
 */
procedure FilePutObject(
   FileNumber As Integer,
   Value As Decimal,
   Optional RecordNumber As Integer = -1
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber   Required. Any valid file number.
 * @param Value        Required. Valid variable name containing data written to disk.
 * @param RecordNumber Optional. Record number (Random mode files) or byte number
 *                     (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a descriptor for the string describing
 *                              the length. The default is False.
 * <b>Remarks</b>
 * <P>
 * The FilePutObject function is used in place of FilePut to avoid ambiguities at compile
 * time if type Object is passed rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * FilePutObject writes and reads descriptors that describe the object. If you intend to
 * write out the Variant type, FilePutObject is required. When in doubt, if you are using
 * an object for the second parameter, it is always safer to use FilePutObject and
 * FileGetObject.
 * <P>
 * FilePutObject is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePutObject is usually read from a file with FileGetObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FilePutObject writes the next record
 * or byte after the last FileGetObject or FilePutObject function (or the record or byte
 * pointed to by the last Seek function).
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePutObject does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePutObject, you need
 * to do the same with FileGetObject, and must also make sure that the string is
 * initialized to the length expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePutObject writes subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is generally a good idea to
 * have the record length match the length of the data being written. If the length of the
 * data being written is greater than the length specified in the RecordLength clause of
 * the FileOpen function, an exception is thrown.
 * <LI>If the variable being written is an object containing a numeric type, FilePutObject
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePutObject writes six
 * bytes: two bytes identifying the object as VarType(3) (Integer) and four bytes
 * containing the data. The record length specified by the RecordLength parameter in the
 * FileOpen function must be at least two bytes greater than the actual number of bytes
 * required to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePutObject
 * writes a two-byte descriptor identifying the VarType(8) of the object, a two-byte
 * descriptor indicating the length of the string, and then writes the string data. The
 * record length specified by the RecordLength parameter in the FileOpen function must be
 * at least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, you can choose to write a descriptor
 * for the size and dimensions of the array. Visual Basic 6 and earlier versions would
 * write the file descriptor for a dynamic array, but not for a fixed-size array; Visual
 * Basic .NET defaults to not writing the descriptor. To write the descriptor, set the
 * ArrayIsDynamic parameter to True. When writing the array, you need to match the way
 * the array is read; if it is read with the descriptor, you need to write the descriptor.
 * The descriptor specifies the rank of the array, the size, and the lower bounds for each
 * rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength clause in
 * the FileOpen function must be greater than or equal to the sum of all the bytes required
 * to write the array data and the array descriptor.
 * </UL>
 *
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePutObject
 * writes all variables to disk contiguously, that is, with no padding between records.
 * </UL>
 *
 * @example
 * <P>
 * This example uses the FilePutObject function to write data to a file. Five records of
 * the structure Person are written to the file.
 * <PRE>
 * Sub WriteData()
 *   Dim Person As String
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     Person = "My Name" & recordNumber   ' Create a string.
 *     FilePutObject(1, Person)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FilePut FilePut Function
 */
procedure FilePutObject(
   FileNumber As Integer,
   Value As Byte,
   Optional RecordNumber As Integer = -1
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber   Required. Any valid file number.
 * @param Value        Required. Valid variable name containing data written to disk.
 * @param RecordNumber Optional. Record number (Random mode files) or byte number
 *                     (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a descriptor for the string describing
 *                              the length. The default is False.
 * <b>Remarks</b>
 * <P>
 * The FilePutObject function is used in place of FilePut to avoid ambiguities at compile
 * time if type Object is passed rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * FilePutObject writes and reads descriptors that describe the object. If you intend to
 * write out the Variant type, FilePutObject is required. When in doubt, if you are using
 * an object for the second parameter, it is always safer to use FilePutObject and
 * FileGetObject.
 * <P>
 * FilePutObject is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePutObject is usually read from a file with FileGetObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FilePutObject writes the next record
 * or byte after the last FileGetObject or FilePutObject function (or the record or byte
 * pointed to by the last Seek function).
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePutObject does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePutObject, you need
 * to do the same with FileGetObject, and must also make sure that the string is
 * initialized to the length expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePutObject writes subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is generally a good idea to
 * have the record length match the length of the data being written. If the length of the
 * data being written is greater than the length specified in the RecordLength clause of
 * the FileOpen function, an exception is thrown.
 * <LI>If the variable being written is an object containing a numeric type, FilePutObject
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePutObject writes six
 * bytes: two bytes identifying the object as VarType(3) (Integer) and four bytes
 * containing the data. The record length specified by the RecordLength parameter in the
 * FileOpen function must be at least two bytes greater than the actual number of bytes
 * required to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePutObject
 * writes a two-byte descriptor identifying the VarType(8) of the object, a two-byte
 * descriptor indicating the length of the string, and then writes the string data. The
 * record length specified by the RecordLength parameter in the FileOpen function must be
 * at least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, you can choose to write a descriptor
 * for the size and dimensions of the array. Visual Basic 6 and earlier versions would
 * write the file descriptor for a dynamic array, but not for a fixed-size array; Visual
 * Basic .NET defaults to not writing the descriptor. To write the descriptor, set the
 * ArrayIsDynamic parameter to True. When writing the array, you need to match the way
 * the array is read; if it is read with the descriptor, you need to write the descriptor.
 * The descriptor specifies the rank of the array, the size, and the lower bounds for each
 * rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength clause in
 * the FileOpen function must be greater than or equal to the sum of all the bytes required
 * to write the array data and the array descriptor.
 * </UL>
 *
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePutObject
 * writes all variables to disk contiguously, that is, with no padding between records.
 * </UL>
 *
 * @example
 * <P>
 * This example uses the FilePutObject function to write data to a file. Five records of
 * the structure Person are written to the file.
 * <PRE>
 * Sub WriteData()
 *   Dim Person As String
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     Person = "My Name" & recordNumber   ' Create a string.
 *     FilePutObject(1, Person)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FilePut FilePut Function
 */
procedure FilePutObject(
   FileNumber As Integer,
   Value As Boolean,
   Optional RecordNumber As Integer = -1
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber   Required. Any valid file number.
 * @param Value        Required. Valid variable name containing data written to disk.
 * @param RecordNumber Optional. Record number (Random mode files) or byte number
 *                     (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a descriptor for the string describing
 *                              the length. The default is False.
 * <b>Remarks</b>
 * <P>
 * The FilePutObject function is used in place of FilePut to avoid ambiguities at compile
 * time if type Object is passed rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * FilePutObject writes and reads descriptors that describe the object. If you intend to
 * write out the Variant type, FilePutObject is required. When in doubt, if you are using
 * an object for the second parameter, it is always safer to use FilePutObject and
 * FileGetObject.
 * <P>
 * FilePutObject is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePutObject is usually read from a file with FileGetObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FilePutObject writes the next record
 * or byte after the last FileGetObject or FilePutObject function (or the record or byte
 * pointed to by the last Seek function).
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePutObject does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePutObject, you need
 * to do the same with FileGetObject, and must also make sure that the string is
 * initialized to the length expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePutObject writes subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is generally a good idea to
 * have the record length match the length of the data being written. If the length of the
 * data being written is greater than the length specified in the RecordLength clause of
 * the FileOpen function, an exception is thrown.
 * <LI>If the variable being written is an object containing a numeric type, FilePutObject
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePutObject writes six
 * bytes: two bytes identifying the object as VarType(3) (Integer) and four bytes
 * containing the data. The record length specified by the RecordLength parameter in the
 * FileOpen function must be at least two bytes greater than the actual number of bytes
 * required to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePutObject
 * writes a two-byte descriptor identifying the VarType(8) of the object, a two-byte
 * descriptor indicating the length of the string, and then writes the string data. The
 * record length specified by the RecordLength parameter in the FileOpen function must be
 * at least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, you can choose to write a descriptor
 * for the size and dimensions of the array. Visual Basic 6 and earlier versions would
 * write the file descriptor for a dynamic array, but not for a fixed-size array; Visual
 * Basic .NET defaults to not writing the descriptor. To write the descriptor, set the
 * ArrayIsDynamic parameter to True. When writing the array, you need to match the way
 * the array is read; if it is read with the descriptor, you need to write the descriptor.
 * The descriptor specifies the rank of the array, the size, and the lower bounds for each
 * rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength clause in
 * the FileOpen function must be greater than or equal to the sum of all the bytes required
 * to write the array data and the array descriptor.
 * </UL>
 *
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePutObject
 * writes all variables to disk contiguously, that is, with no padding between records.
 * </UL>
 *
 * @example
 * <P>
 * This example uses the FilePutObject function to write data to a file. Five records of
 * the structure Person are written to the file.
 * <PRE>
 * Sub WriteData()
 *   Dim Person As String
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     Person = "My Name" & recordNumber   ' Create a string.
 *     FilePutObject(1, Person)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FilePut FilePut Function
 */
procedure FilePutObject(
   FileNumber As Integer,
   Value As Date,
   Optional RecordNumber As Integer = -1
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber   Required. Any valid file number.
 * @param Value        Required. Valid variable name containing data written to disk.
 * @param RecordNumber Optional. Record number (Random mode files) or byte number
 *                     (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a descriptor for the string describing
 *                              the length. The default is False.
 * <b>Remarks</b>
 * <P>
 * The FilePutObject function is used in place of FilePut to avoid ambiguities at compile
 * time if type Object is passed rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * FilePutObject writes and reads descriptors that describe the object. If you intend to
 * write out the Variant type, FilePutObject is required. When in doubt, if you are using
 * an object for the second parameter, it is always safer to use FilePutObject and
 * FileGetObject.
 * <P>
 * FilePutObject is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePutObject is usually read from a file with FileGetObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FilePutObject writes the next record
 * or byte after the last FileGetObject or FilePutObject function (or the record or byte
 * pointed to by the last Seek function).
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePutObject does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePutObject, you need
 * to do the same with FileGetObject, and must also make sure that the string is
 * initialized to the length expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePutObject writes subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is generally a good idea to
 * have the record length match the length of the data being written. If the length of the
 * data being written is greater than the length specified in the RecordLength clause of
 * the FileOpen function, an exception is thrown.
 * <LI>If the variable being written is an object containing a numeric type, FilePutObject
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePutObject writes six
 * bytes: two bytes identifying the object as VarType(3) (Integer) and four bytes
 * containing the data. The record length specified by the RecordLength parameter in the
 * FileOpen function must be at least two bytes greater than the actual number of bytes
 * required to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePutObject
 * writes a two-byte descriptor identifying the VarType(8) of the object, a two-byte
 * descriptor indicating the length of the string, and then writes the string data. The
 * record length specified by the RecordLength parameter in the FileOpen function must be
 * at least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, you can choose to write a descriptor
 * for the size and dimensions of the array. Visual Basic 6 and earlier versions would
 * write the file descriptor for a dynamic array, but not for a fixed-size array; Visual
 * Basic .NET defaults to not writing the descriptor. To write the descriptor, set the
 * ArrayIsDynamic parameter to True. When writing the array, you need to match the way
 * the array is read; if it is read with the descriptor, you need to write the descriptor.
 * The descriptor specifies the rank of the array, the size, and the lower bounds for each
 * rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength clause in
 * the FileOpen function must be greater than or equal to the sum of all the bytes required
 * to write the array data and the array descriptor.
 * </UL>
 *
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePutObject
 * writes all variables to disk contiguously, that is, with no padding between records.
 * </UL>
 *
 * @example
 * <P>
 * This example uses the FilePutObject function to write data to a file. Five records of
 * the structure Person are written to the file.
 * <PRE>
 * Sub WriteData()
 *   Dim Person As String
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     Person = "My Name" & recordNumber   ' Create a string.
 *     FilePutObject(1, Person)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FilePut FilePut Function
 */
procedure FilePutObject(
   FileNumber As Integer,
   Value As System.Array,
   Optional RecordNumber As Integer = -1,
   Optional ArrayIsDynamic As Boolean = False
);

/**
 * Writes data from a variable to a disk file.
 *
 * @param FileNumber   Required. Any valid file number.
 * @param Value        Required. Valid variable name containing data written to disk.
 * @param RecordNumber Optional. Record number (Random mode files) or byte number
 *                     (Binary mode files) at which writing begins.
 * @param ArrayIsDynamic  Optional. Applies only when writing an array. Specifies whether
 *                        the array is to be treated as dynamic, and whether to write an
 *                        array descriptor for the string describing the length.
 * @param StringIsFixedLength   Optional. Applies only when writing a string. Specifies
 *                              whether to write a descriptor for the string describing
 *                              the length. The default is False.
 * <b>Remarks</b>
 * <P>
 * The FilePutObject function is used in place of FilePut to avoid ambiguities at compile
 * time if type Object is passed rather than another type, such as Integer, Long, Short,
 * and so forth.
 * <P>
 * FilePutObject writes and reads descriptors that describe the object. If you intend to
 * write out the Variant type, FilePutObject is required. When in doubt, if you are using
 * an object for the second parameter, it is always safer to use FilePutObject and
 * FileGetObject.
 * <P>
 * FilePutObject is only valid in Random and Binary mode.
 * <P>
 * Data written with FilePutObject is usually read from a file with FileGetObject.
 * <P>
 * The first record or byte in a file is at position 1, the second record or byte is at
 * position 2, and so on. If you omit RecordNumber, FilePutObject writes the next record
 * or byte after the last FileGetObject or FilePutObject function (or the record or byte
 * pointed to by the last Seek function).
 * <P>
 * The StringIsFixedLength argument controls whether the function interprets strings as
 * variable or fixed length. FilePutObject does not write the length descriptor when the
 * argument is True. If you use StringIsFixedLength = True with FilePutObject, you need
 * to do the same with FileGetObject, and must also make sure that the string is
 * initialized to the length expected.
 * <P>
 * For files opened in Random mode, the following rules apply:
 * <UL>
 * <LI>If the length of the data being written is less than the length specified in the
 * RecordLength clause of the FileOpen function, FilePutObject writes subsequent records
 * on record-length boundaries. The space between the end of one record and the beginning
 * of the next record is padded with the existing contents of the file buffer. Because the
 * amount of padding data can't be precisely determined, it is generally a good idea to
 * have the record length match the length of the data being written. If the length of the
 * data being written is greater than the length specified in the RecordLength clause of
 * the FileOpen function, an exception is thrown.
 * <LI>If the variable being written is an object containing a numeric type, FilePutObject
 * writes two bytes identifying the VarType of the object and then writes the variable.
 * For example, when writing an object containing an integer, FilePutObject writes six
 * bytes: two bytes identifying the object as VarType(3) (Integer) and four bytes
 * containing the data. The record length specified by the RecordLength parameter in the
 * FileOpen function must be at least two bytes greater than the actual number of bytes
 * required to store the variable.
 * <LI>If the variable being written is an object containing a string, FilePutObject
 * writes a two-byte descriptor identifying the VarType(8) of the object, a two-byte
 * descriptor indicating the length of the string, and then writes the string data. The
 * record length specified by the RecordLength parameter in the FileOpen function must be
 * at least four bytes greater than the actual length of the string. If you wish to put a
 * string without the descriptor, then you should pass True to the StringIsFixedLength
 * parameter, and the string you read into should be the correct length.
 * <LI>If the variable being written is an array, you can choose to write a descriptor
 * for the size and dimensions of the array. Visual Basic 6 and earlier versions would
 * write the file descriptor for a dynamic array, but not for a fixed-size array; Visual
 * Basic .NET defaults to not writing the descriptor. To write the descriptor, set the
 * ArrayIsDynamic parameter to True. When writing the array, you need to match the way
 * the array is read; if it is read with the descriptor, you need to write the descriptor.
 * The descriptor specifies the rank of the array, the size, and the lower bounds for each
 * rank. Its length equals 2 plus 8 times the number of dimensions, that is,
 * 2 + 8 * NumberOfDimensions. The record length specified by the RecordLength clause in
 * the FileOpen function must be greater than or equal to the sum of all the bytes required
 * to write the array data and the array descriptor.
 * </UL>
 *
 * <P>
 * For files opened in Binary mode, all of the Random mode rules apply, except:
 * <UL>
 * <LI>The RecordLength clause in the FileOpen function has no effect. FilePutObject
 * writes all variables to disk contiguously, that is, with no padding between records.
 * </UL>
 *
 * @example
 * <P>
 * This example uses the FilePutObject function to write data to a file. Five records of
 * the structure Person are written to the file.
 * <PRE>
 * Sub WriteData()
 *   Dim Person As String
 *   Dim recordNumber As Integer
 *   '    Open file for random access.
 *   FileOpen(1, "C:\TESTFILE.txt", OpenMode.Binary)
 *   For recordNumber = 1 To 5   ' Loop 5 times.
 *     Person = "My Name" & recordNumber   ' Create a string.
 *     FilePutObject(1, Person)   ' Write record to file.
 *   Next recordNumber
 *   FileClose(1)
 * End Sub
 * </PRE>
 *
 * @see FileGet FileGet Function
 * @see FileOpen FileOpen Function
 * @see Seek Seek Function
 * @see FilePut FilePut Function
 */
procedure FilePutObject(
   FileNumber As Integer,
   Value As String,
   Optional RecordNumber As Integer = -1,
   Optional StringIsFixedLength as Boolean = False
);

/**
 * Assigns an output line width to a file opened using the FileOpen function.
 *
 * @param FileNumber    Required. Any valid file number.
 * @param RecordWidth   Required. Numeric expression in the range 0255, inclusive, which
 *                      indicates how many characters appear on a line before a new line
 *                      is started. If RecordWidth equals 0, there is no limit to the
 *                      length of a line. The default value for RecordWidth is 0.
 *
 * @exception IOException   FileNumber does not exist.
 * @exception IOException   File mode is invalid.
 *
 * @example
 * <P>
 * This example uses the FileWidth function to set the output line width for a file.
 * <PRE>
 * Dim i As Integer
 * FileOpen(1, "TESTFILE", OpenMode.Output) ' Open file for output.
 * FileWidth(1, 5)   ' Set output line width to 5.
 * For i = 0 To 9   ' Loop 10 times.
 *   Print(1, Chr(48 + I))   ' Prints five characters per line.
 * Next
 * FileClose(1)   ' Close file.
 * </PRE>
 *
 * @see FileOpen FileOpen Function
 * @see Print Print Function
 * @see PrintLine PrintLine Function
 */
procedure FileWidth(
   FileNumber As Integer,
   RecordWidth As Integer
);

/**
 * Returns a zero-based array containing a subset of a String array based on specified
 * filter criteria.
 *
 * <p>
 * <B>Settings</B>
 * <P>
 * The Compare argument can have the following values:
 * <P>
 *
 * <pre>
 * Constant                    Description
 * CompareMethod.Binary        Performs a binary comparison
 * CompareMethod.Text          Performs a textual comparison
 * </pre>
 *
 * @exception ArgumentException   Source is Nothing or is not a one-dimensional array.
 *
 * <b>Remarks</b>
 * <p>
 * If no matches of Match are found within Source, the Filter function returns an empty
 * array. An error occurs if Source is set to Nothing or is not a one-dimensional array.
 * <p>
 * The array returned by the Filter function contains only enough elements to contain the
 * number of matched items.
 *
 * @param Source   Required. One-dimensional array of strings to be searched.
 * @param Match    Required. String to search for.
 * @param Include  Optional. Boolean value indicating whether to return substrings that
 *                 include or exclude Match. If Include is True, the Filter function
 *                 returns the subset of the array that contains Match as a substring.
 *                 If Include is False, the Filter function returns the subset of the
 *                 array that does not contain Match as a substring.
 * @param Compare  Optional. Numeric value indicating the kind of string comparison to
 *                 use. See Settings for values.
 *
 *
 *
 * @example
 * <P>
 * This example demonstrates the use of the Filter function.
 * <PRE>
 * Dim myStrings(2) As String
 * MyStrings(0) = "This"
 * MyStrings(1) = "Is"
 * MyStrings(2) = "It"
 * ' Returns ["This", "Is"].
 * Dim subStrings() As String = Filter(myStrings, "is", True, _
 * CompareMethod.Text)
 * ' Returns ["This"].
 * Dim subStrings() As String = Filter(myStrings, "is", True, _
 * CompareMethod.Binary)
 * ' Returns ["Is", "It"].
 * Dim subStrings() As String = Filter(myStrings, "is", False, _
 *  CompareMethod.Binary)
 * </pre>
 *
 * @see Replace Replace Function
 */
function Array Filter(
   ByVal Source() As Object,
   ByVal Match As String,
   Optional ByVal Include As Boolean = True,
   Optional ByVal Compare As CompareMethod = CompareMethod.Binary
);

/**
 * Returns a zero-based array containing a subset of a String array based on specified
 * filter criteria.
 *
 * @param Source   Required. One-dimensional array of strings to be searched.
 * @param Match    Required. String to search for.
 * @param Include  Optional. Boolean value indicating whether to return substrings that
 *                 include or exclude Match. If Include is True, the Filter function
 *                 returns the subset of the array that contains Match as a substring.
 *                 If Include is False, the Filter function returns the subset of the
 *                 array that does not contain Match as a substring.
 * @param Compare  Optional. Numeric value indicating the kind of string comparison to
 *                 use. See Settings for values.
 *
 * <B>Settings</B>
 * <P>
 * The Compare argument can have the following values:
 *
 * Constant                    Description
 * CompareMethod.Binary        Performs a binary comparison
 * CompareMethod.Text          Performs a textual comparison
 *
 * @exception ArgumentException   Source is Nothing or is not a one-dimensional array.
 *
 * <b>Remarks</b>
 * <p>
 * If no matches of Match are found within Source, the Filter function returns an empty
 * array. An error occurs if Source is set to Nothing or is not a one-dimensional array.
 * <p>
 * The array returned by the Filter function contains only enough elements to contain the
 * number of matched items.
 *
 * @example
 * <P>
 * This example demonstrates the use of the Filter function.
 * <PRE>
 * Dim myStrings(2) As String
 * MyStrings(0) = "This"
 * MyStrings(1) = "Is"
 * MyStrings(2) = "It"
 * ' Returns ["This", "Is"].
 * Dim subStrings() As String = Filter(myStrings, "is", True, _
 * CompareMethod.Text)
 * ' Returns ["This"].
 * Dim subStrings() As String = Filter(myStrings, "is", True, _
 * CompareMethod.Binary)
 * ' Returns ["Is", "It"].
 * Dim subStrings() As String = Filter(myStrings, "is", False, _
 * CompareMethod.Binary)
 *
 * @see Replace Replace Function
 */
function Array Filter(
   ByVal Source() As String,
   ByVal Match As String,
   Optional ByVal Include As Boolean = True,
   Optional ByVal Compare As CompareMethod = CompareMethod.Binary
);

/**
 * Return the integer portion of a number.
 *
 * @param number   Required. A number of type Double or any valid numeric expression.
 *                 If number contains Nothing, Nothing is returned.
 *
 * <b>Remarks</b>
 * <P>
 * Both the Int and Fix functions remove the fractional part of number and return the
 * resulting integer value.
 * <P>
 * The difference between Int and Fix functions is that if number is negative, Int
 * returns the first negative integer less than or equal to number, whereas Fix returns
 * the first negative integer greater than or equal to number. For example, Int
 * converts -8.4 to -9, and Fix converts -8.4 to -8.
 * <PRE>
 * Fix(number) is equivalent to Sign(number) * Int(Abs(number)).
 * </PRE>
 *
 * @example
 * <P>
 * This example illustrates how the Int and Fix functions return integer portions of
 * numbers. In the case of a negative number argument, the Int function returns the first
 * negative integer less than or equal to the number; the Fix function returns the first
 * negative integer greater than or equal to the number. The following example requires
 * you to specify Option Strict Off because implicit conversions from type Double to type
 * Integer are not allowed under Option Strict On:
 *
 * <PRE>
 * Option Strict Off
 * ...
 * Dim MyNumber As Integer
 * MyNumber = Int(99.8)   ' Returns 99.
 * MyNumber = Fix(99.8)   ' Returns 99.
 *
 * MyNumber = Int(-99.8)   ' Returns -100.
 * MyNumber = Fix(-99.8)   ' Returns -99.
 *
 * MyNumber = Int(-99.2)   ' Returns -100.
 * MyNumber = Fix(-99.2)   ' Returns -99.
 * </PRE>
 *
 * <P>
 * You can use the CInt function to explicitly convert other data types to type Integer
 * with Option Strict Off. However, Cint rounds to the nearest integer instead of
 * truncating the fractional part of numbers. For example:
 * <PRE>
 * MyNumber = CInt(99.8)    ' Returns 100.
 * MyNumber = CInt(-99.8)   ' Returns -100.
 * MyNumber = CInt(-99.2)   ' Returns -99.
 * </PRE>
 *
 * <P>
 * You can use the CInt function on the result of a call to Fix or Int to perform
 * explicit conversion to integer without rounding. For example:
 * <PRE>
 * MyNumber = CInt(Fix(99.8))   ' Returns 99.
 * MyNumber = CInt(Int(99.8))   ' Returns 99.
 * </PRE>
 *
 * @see CInt CInt Function
 */
function Int(number);

/**
 * Return the integer portion of a number.
 *
 * @param number   Required. A number of type Double or any valid numeric expression.
 *                 If number contains Nothing, Nothing is returned.
 *
 * <b>Remarks</b>
 * <P>
 * Both the Int and Fix functions remove the fractional part of number and return the
 * resulting integer value.
 * <P>
 * The difference between Int and Fix functions is that if number is negative, Int
 * returns the first negative integer less than or equal to number, whereas Fix returns
 * the first negative integer greater than or equal to number. For example, Int
 * converts -8.4 to -9, and Fix converts -8.4 to -8.
 * <PRE>
 * Fix(number) is equivalent to Sign(number) * Int(Abs(number)).
 * </PRE>
 *
 * @example
 * <P>
 * This example illustrates how the Int and Fix functions return integer portions of
 * numbers. In the case of a negative number argument, the Int function returns the first
 * negative integer less than or equal to the number; the Fix function returns the first
 * negative integer greater than or equal to the number. The following example requires
 * you to specify Option Strict Off because implicit conversions from type Double to type
 * Integer are not allowed under Option Strict On:
 *
 * <PRE>
 * Option Strict Off
 * ...
 * Dim MyNumber As Integer
 * MyNumber = Int(99.8)   ' Returns 99.
 * MyNumber = Fix(99.8)   ' Returns 99.
 *
 * MyNumber = Int(-99.8)   ' Returns -100.
 * MyNumber = Fix(-99.8)   ' Returns -99.
 *
 * MyNumber = Int(-99.2)   ' Returns -100.
 * MyNumber = Fix(-99.2)   ' Returns -99.
 * </PRE>
 *
 * <P>
 * You can use the CInt function to explicitly convert other data types to type Integer
 * with Option Strict Off. However, Cint rounds to the nearest integer instead of
 * truncating the fractional part of numbers. For example:
 * <PRE>
 * MyNumber = CInt(99.8)    ' Returns 100.
 * MyNumber = CInt(-99.8)   ' Returns -100.
 * MyNumber = CInt(-99.2)   ' Returns -99.
 * </PRE>
 *
 * <P>
 * You can use the CInt function on the result of a call to Fix or Int to perform
 * explicit conversion to integer without rounding. For example:
 * <PRE>
 * MyNumber = CInt(Fix(99.8))   ' Returns 99.
 * MyNumber = CInt(Int(99.8))   ' Returns 99.
 * </PRE>
 *
 * @see CInt CInt Function
 */
function Fix(number);


/**
 * Returns a string formatted according to instructions contained in a format String expression.
 *
 * <P>
 * <b>Settings</b>
 * <P>
 * For information on how to create the Style argument, see the appropriate topic listed below:
 * <P>
 *
 * <pre>
 * To format                       Do this
 * Numbers                         Use predefined numeric formats or create user-defined numeric formats.
 * Dates and times                 Use predefined date/time formats or create user-defined date/time formats.
 * Date and time serial numbers    Use date and time formats or numeric formats.
 * </pre>
 * <P>
 *
 * If you try to format a number without specifying Style, the Format function provides functionality similar to the Str function, although it is internationally aware. However, positive numbers formatted as strings using the Format function don't include a leading space reserved for the sign of the value; those converted using the Str function retain the leading space.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 *
 * If you are formatting a nonlocalized numeric string, you should use a user-defined numeric format to ensure that you get the look you want.
 *
 * <P>
 * The String.Format method also provides similar functionality.
 *
 * @param Expression   Required. Any valid expression.
 * @param Style        Optional. A valid named or user-defined format String expression.
 *
 * @example
 * This example shows various uses of the Format function to format values using both String formats and user-defined formats. For the date separator (/), time separator (:), and the AM/PM indicators (t and tt), the actual formatted output displayed by your system depends on the locale settings the code is using. When times and dates are displayed in the development environment, the short time format and short date format of the code locale are used.
 *
 * <PRE>
 * Dim MyDateTime As Date = #1/27/2001 5:04:23 PM#
 * Dim MyStr As String
 * ' Returns current system time in the system-defined long time format.
 * MyStr = Format(Now(), "Long Time")
 * ' Returns current system date in the system-defined long date format.
 * MyStr = Format(Now(), "Long Date")
 * ' Also returns current system date in the system-defined long date
 * ' format, using the single letter code for the format.
 * MyStr = Format(Now(), "D")
 * ' Returns the value of MyDateTime in user-defined date/time formats.
 * MyStr = Format(MyDateTime, "h:m:s")   ' Returns "5:4:23".
 * MyStr = Format(MyDateTime, "hh:mm:ss tt")   ' Returns "05:04:23 PM".
 * MyStr = Format(MyDateTime, "dddd, MMM d yyyy")   ' Returns "Saturday,
 * ' Jan 27 2001".
 * MyStr = Format(MyDateTime, "HH:mm:ss")   ' Returns "17:04:23"
 * MyStr = Format(23)   ' Returns "23".
 * ' User-defined numeric formats.
 * MyStr = Format(5459.4, "##,##0.00")   ' Returns "5,459.40".
 * MyStr = Format(334.9, "###0.00")   ' Returns "334.90".
 * MyStr = Format(5, "0.00%")   ' Returns "500.00%".
 * </PRE>
 *
 * @see Str Str Function
 */
function String Format(
   ByVal Expression As Object,
   Optional ByVal Style As String = ""
);

/**
 * Returns an expression formatted as a currency value using the currency symbol defined in the system control panel.
 *
 * <P>
 * <b>Settings</b>
 * <P>
 * The IncludeLeadingDigit, UseParensForNegativeNumbers, and GroupDigits arguments take the following Tristate enumeration values:
 *
 * <Pre>
 *
 * Value                Description
 * TriState.True        True
 * TriState.False       False
 * TriState.UseDefault  The computer's regional settings
 * </pre>
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * When one or more optional arguments are omitted, the computer's matching regional-settings values are used instead.
 *
 * <P>
 * The position of the currency symbol relative to the currency value is determined by the system's regional settings.
 *
 * <P>
 * Note   All settings information comes from the locale of the application. By default, that will be the locale set in the control panel. However, it may be changed programmatically by using the .NET Framework, except leading zero, which comes from the Number tab.
 *
 *
 * @example ArgumentException   Number of digits after decimal point is greater than 99.
 * @example InvalidCastException   Type is not numeric.
 *
 * @example
 * <P>
 * The following example illustrates the use of the FormatCurrency function.
 *
 * <PRE>
 * Dim myDebt As Double = -4456.43
 * Dim myString As String
 * ' Returns"($4,456.43)".
 * MyString = FormatCurrency(myDebt,,, TriState.True, TriState.True)
 * </PRE>
 *
 * @see FormatDateTime FormatDateTime Function
 * @see FormatNumber FormatNumber Function
 * @see FormatPercent FormatPercent Function
 */
function String FormatCurrency(
   ByVal Expression As Object,
   Optional ByVal NumDigitsAfterDecimal As Integer = -1,
   Optional ByVal IncludeLeadingDigit As TriState = TriState.UseDefault,
   Optional ByVal UseParensForNegativeNumbers As TriState = TriState.UseDefault,
   Optional ByVal GroupDigits As TriState = TriState.UseDefault
);

/**
 * Returns an expression formatted as a date or time.
 *
 * <P>
 * <b>Settings</b>
 * <P>
 * The NamedFormat argument has the following settings:
 *
 *
 * <pre>
 * Constant                  Description
 * DateFormat.GeneralDate    Display a date and/or time. If there is a date part, display it as a short date. If there is a time part, display it as a long time. If present, both parts are displayed.
 * DateFormat.LongDate       Display a date using the long date format specified in your computer's regional settings.
 * DateFormat.ShortDate      Display a date using the short date format specified in your computer's regional settings.
 * DateFormat.LongTime       Display a time using the time format specified in your computer's regional settings.
 * DateFormat.ShortTime      Display a time using the 24-hour format (hh:mm).
 * </pre>
 *
 * <P>
 * @exception ArgumentException   NamedFormat setting is invalid.
 *
 * @example
 * <P>
 * This example demonstrates the use of the FormatDateTime function.
 *
 * <PRE>
 * Dim myDate As DateTime = #2/14/89#
 * Dim myString As String
 * ' Returns "Tuesday, February 14, 1989".
 * myString = FormatDateTime(myDate, DateFormat.LongDate)
 * </PRE>
 *
 * @see FormatCurrency FormatCurrency Function
 * @see FormatNumber FormatNumber Function
 * @see FormatPercent FormatPercent Function
 */
function String FormatDateTime(
   ByVal Expression As DateTime,
   Optional ByVal NamedFormat As DateFormat = DateFormat.GeneralDate
);


/**
 * Returns an expression formatted as a number.
 *
 * <P>
 * <b>Settings</b>
 * <P>
 * The IncludeLeadingDigit, UseParensForNegativeNumbers, and GroupDigits arguments have the following settings:
 *
 * <Pre>
 * Constant            Description
 * TriState.True       True
 * TriState.False      False
 * TriState.UseDefault The computer's regional settings
 * </Pre>
 *
 * <b>Remarks</b>
 * <P>
 * When one or more optional arguments are omitted, the values for omitted arguments are provided by the locale settings.
 * <P>
 * Note   All settings information comes from the locale of the application. by default, that will be the locale set in the control panel. However, it may be changed programmatically by using the .NET Framework.
 * <P>
 *
 * @param Expression Required.    Expression to be formatted.
 * @param NumDigitsAfterDecimal   Optional. Numeric value indicating how many places are displayed to the right of the decimal. The default value is 1, which indicates that the computer's regional settings are used.
 * @param IncludeLeadingDigit   Optional. Tristate constant that indicates whether a leading zero is displayed for fractional values. See Settings for values.
 * @param UseParensForNegativeNumbers  Optional. Tristate constant that indicates whether to place negative values within parentheses. See Settings for values.
 * @param GroupDigits   Optional. Tristate constant that indicates whether or not numbers are grouped using the group delimiter specified in the locale settings. See Settings for values.
 *
 * @exception InvalidCastException  Type is not numeric.
 *
 * @example
 * <P>
 * This example demonstrates the FormatNumber function.
 *
 * <PRE>
 * Dim myNumber As Integer = 45600
 * Dim myString As String
 * ' Returns "45,600.00".
 * myString = FormatNumber(myNumber, 2, , ,TriState.True)
 * </PRE>
 *
 * @see FormatCurrency FormatCurrency Function
 * @see FormatDateTime FormatDateTime Function
 * @see FormatPercent FormatPercent Function
 */
function String FormatNumber(
   ByVal Expression As Object,
   Optional ByVal NumDigitsAfterDecimal As Integer = -1,
   Optional ByVal IncludeLeadingDigit As TriState = TriState.UseDefault,
   Optional ByVal UseParensForNegativeNumbers As TriState = TriState.UseDefault,
   Optional ByVal GroupDigits As TriState = TriState.UseDefault);



/**
 * Returns an expression formatted as a percentage (that is, multiplied by 100) with a trailing % character.
 *
 * <P>
 * <b>Settings</b>
 * <P>
 * The IncludeLeadingDigit, UseParensForNegativeNumbers, and GroupDigits arguments have the following settings:
 *
 * <Pre>
 * Constant             Description
 * TriState.True        True
 * TriState.False       False
 * TriState.Default     The computer's regional settings
 * </pre>
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * When one or more optional arguments are omitted, the values for omitted arguments are provided by the locale settings.
 * <P>
 * Note   All settings information comes from the locale of the application. by default, that will be the locale set in the control panel. However, it may be changed programmatically by using the .NET Framework.
 * <P>
 *
 * @param Expression                  Required. Expression to be formatted.
 * @param NumDigitsAfterDecimal       Optional. Numeric value indicating how many places to the right of the decimal are displayed. Default value is 1, which indicates that the locale settings are used.
 * @param IncludeLeadingDigit         Optional. Tristate constant that indicates whether or not a leading zero is displayed for fractional values. See Settings for values.
 * @param UseParensForNegativeNumbers Optional. Tristate constant that indicates whether or not to place negative values within parentheses. See Settings for values.
 * @param GroupDigits              Optional. Tristate constant that indicates whether or not numbers are grouped using the group delimiter specified in the locale settings. See Settings for values.
 *
 * @exception InvalidCastException   Type is not numeric.
 *
 * @example
 * <P>
 * This example illustrates the use of the FormatPercent function:
 *
 * <PRE>
 * Dim myNumber As Single = 0.76
 * Dim myString As String
 * ' Returns "76.00%".
 * myString = FormatPercent(myNumber)
 * </PRE>
 *
 * @see FormatCurrency FormatCurrency Function
 * @see FormatDateTime FormatDateTime Function
 * @see FormatNumber FormatNumber Function
 */
function String FormatPercent(
   ByVal Expression As Object,
   Optional ByVal NumDigitsAfterDecimal As Integer = -1,
   Optional ByVal IncludeLeadingDigit As TriState = TriState.UseDefault,
   Optional ByVal UseParensForNegativeNumbers As TriState = TriState.UseDefault,
   Optional ByVal GroupDigits As TriState = TriState.UseDefault
);


/**
 * Returns an Integer value representing the next file number available for use by the FileOpen function.
 *
 * <P>
 * <b>Remarks</b>
 *
 * Use FreeFile to supply a file number that is not already in use.
 *
 * @exception IOException   More than 255 files are in use.
 *
 * @example
 * <P>
 * This example uses the FreeFile function to return the next available file number. Five files are opened for output within the loop, and some sample data is written to each.
 *
 * <PRE>
 * Dim count As Integer
 * Dim fileNumber As Integer
 * For count = 1 To 5
 *   fileNumber = FreeFile()
 *   FileOpen(fileNumber, "TEST" & count & ".TXT", OpenMode.Output)
 *   PrintLine(fileNumber, "This is a sample.")
 *   FileClose(fileNumber)
 * Next
 * </PRE>
 *
 * @see FileOpen FileOpen Function
 */
function Integer FreeFile();


/**
 * Returns a Double specifying the future value of an annuity based on periodic, fixed payments and a fixed interest rate.
 *
 * <P>
 * <b>Remarks</b>
 * An annuity is a series of fixed cash payments made over a period of time. An annuity can be a loan (such as a home mortgage) or an investment (such as a monthly savings plan).
 * <P>
 * The Rate and NPer arguments must be calculated using payment periods expressed in the same units. For example, if Rate is calculated using months, NPer must also be calculated using months.
 * <P>
 * For all arguments, cash paid out (such as deposits to savings) is represented by negative numbers; cash received (such as dividend checks) is represented by positive numbers.
 * <P>
 *
 * @param Rate Required. Double specifying interest rate per period. For example, if you get a car loan at an annual percentage rate (APR) of 10 percent and make monthly payments, the rate per period is 0.1/12, or 0.0083.
 * @param NPer Required. Double specifying total number of payment periods in the annuity. For example, if you make monthly payments on a four-year car loan, your loan has a total of 4 * 12 (or 48) payment periods.
 * @param Pmt  Required. Double specifying payment to be made each period. Payments usually contain principal and interest that doesn't change over the life of the annuity.
 * @param PV   Optional. Double specifying present value (or lump sum) of a series of future payments. For example, when you borrow money to buy a car, the loan amount is the present value to the lender of the monthly car payments you will make. If omitted, 0 is assumed.
 * @param Due  Optional. Object of type Microsoft.VisualBasic.DueDate that specifies when payments are due. This argument must be either DueDate.EndOfPeriod if payments are due at the end of the payment period, or DueDate.BegOfPeriod if payments are due at the beginning of the period. If omitted, DueDate.EndOfPeriod is assumed.
 *
 * @example
 * <P>
 * This example uses the FV function to return the future value of an investment given the percentage rate that accrues per period (APR / 12), the total number of payments (TotPmts), the payment (Payment), the current value of the investment (PVal), and a number that indicates whether the payment is made at the beginning or end of the payment period (PayType). Note that because Payment represents cash paid out, it is a negative number.
 *
 * <PRE>
 * Sub TestFV()
 *   Dim Fmt As String
 *   Dim TotPmts As Integer
 *   Dim Payment, APR, PVal, Fval As Double
 *   Dim PayType As DueDate
 *   Dim Response As MsgBoxResult
 *   Fmt = "###,###,##0.00"   ' Define money format.
 *   Payment = CDbl(InputBox("How much do you plan to save each month?"))
 *   APR = CDbl(InputBox("Enter the expected interest annual percentage rate."))
 *   If APR > 1 Then APR = APR / 100 ' Ensure proper form.
 *   TotPmts = CInt(InputBox("For how many months do you expect to save?"))
 *   Response = MsgBox("Do you make payments at the end of month?", MsgBoxStyle.YesNo)
 *   If Response = MsgBoxResult.No Then
 *     PayType = DueDate.BegOfPeriod
 *   Else
 *     PayType = DueDate.EndOfPeriod
 *   End If
 *   PVal = CDbl(InputBox("How much is in this savings account now?"))
 *   Fval = FV(APR / 12, TotPmts, -Payment, -PVal, PayType)
 *   MsgBox("Your savings will be worth " & Format(Fval, Fmt) & ".")
 * End Sub
 * </PRE>
 *
 * @see DDB  DDB Function
 * @see IPmt IPmt Function
 * @see IRR IRR Function
 * @see MIRR MIRR Function
 * @see NPer NPer Function
 * @see NPV NPV Function
 * @see Pmt Pmt Function
 * @see PPmt PPmt Function
 * @see PV PV Function
 * @see Rate Rate Function
 * @see SLN SLN Function
 * @see SYD SYD Function
 */
function Double FV(
   ByVal Rate As Double,
   ByVal NPer As Double,
   ByVal Pmt As Double,
   Optional ByVal PV As Double = 0,
   Optional ByVal Due As DueDate = DueDate.EndOfPeriod
);


/**
 * Returns a list of key settings and their respective values (originally created with SaveSetting) from an application's entry in the Windows registry.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * GetAllSettings returns an uninitialized Object if either AppName or Section does not exist.
 * <P>
 * GetAllSettings requires that a user be logged on since it operates under the HKEY_LOCAL_USER registry key, which is not active until a user logs on interactively.
 * <P>
 * Registry settings that are to be accessed from a non-interactive process (such as mtx.exe) should be stored under either the HKEY_LOCAL_MACHINE\Software\ or the HKEY_USER\DEFAULT\Software registry keys.
 *
 * @param AppName  Required. String expression containing the name of the application or project whose key settings are requested.
 * @param Section  Required. String expression containing the name of the section whose key settings are requested. GetAllSettings returns an object that contains a two-dimensional array of strings. The strings contain all the key settings in the specified section plus their corresponding values.
 *
 * @exception ArgumentException   User is not logged in.
 *
 * @example
 * This example first uses the SaveSetting statement to make entries in the Windows registry for the application specified as AppName, then uses the GetAllSettings function to display the settings. Note that application names and Section names can't be retrieved with GetAllSettings. Finally, the DeleteSetting statement removes the application's entries.
 *
 * <PRE>
 * ' Object to hold 2-dimensional array returned by GetAllSettings.
 * ' Integer to hold counter.
 * Dim MySettings(,) As String
 * Dim intSettings As Integer
 * ' Place some settings in the registry.
 * SaveSetting("MyApp", "Startup", "Top", "75")
 * SaveSetting("MyApp", "Startup", "Left", "50")
 * ' Retrieve the settings.
 * MySettings = GetAllSettings("MyApp", "Startup")
 * For intSettings = LBound(MySettings, 1) To UBound(MySettings, 1)
 *   Debug.WriteLine(MySettings(intSettings, 0))
 *   Debug.WriteLine(MySettings(intSettings, 1))
 * Next intSettings
 * DeleteSetting("MyApp")
 * </PRE>
 *
 * @see DeleteSetting DeleteSetting Function
 * @see GetSetting GetSetting Function
 * @see SaveSetting SaveSetting Function
 */
function String/*(,)*/ GetAllSettings(
   ByVal AppName As String,
   ByVal Section As String
);

/**
 * Returns a FileAttribute value representing the attributes of a file, directory, or folder.
 *
 * <b>Remarks</b>
 * <P>
 * To determine which attributes are set, use the And operator to perform a bitwise comparison of the value returned by the GetAttr function and the value of the individual file attribute you want. If the result is not zero, that attribute is set for the named file. For example, the return value of the following And expression is zero if the Archive attribute is not set:
 *
 * <PRE>
 * Result = GetAttr(FName) And vbArchive
 * </PRE>
 * A nonzero value is returned if the Archive attribute is set.
 *
 *
 *
 * @param PathName  Required. String expression that specifies a file, directory, or folder name. PathName may include the directory or folder, and the drive.
 *
 * @exception IOException   Pathname is invalid or contains wildcards.
 * @exception FileNotFoundException   Target file does not exist.
 *
 * @return
 * The value returned by GetAttr is the sum of the following enumeration values:
 * <p>
 *
 * <pre>
 * Value     Constant     Description
 * Normal    VbNormal     Normal.
 * ReadOnly  VbReadOnly   Read-only.
 * Hidden    VbHidden     Hidden.
 * System    VbSystem     System file.
 * Directory VbDirectory  Directory or folder.
 * Archive   VbArchive    File has changed since last backup.
 * Alias     VbAlias      File has a different name.
 * </pre>
 *
 * <P>
 * Note   These enumerations are specified by the Visual Basic language. The names can be used anywhere in your code in place of the actual values.
 *
 * @example
 * This example uses the GetAttr function to determine the attributes of a file and directory or folder.
 *
 * <PRE>
 * Dim MyAttr As FileAttribute
 * ' Assume file TESTFILE is normal and readonly.
 * MyAttr = GetAttr("C:\TESTFILE.txt")   ' Returns VbNormal.
 *
 * ' Test for normal.
 * If (MyAttr And FileAttribute.Normal) = FileAttribute.Normal Then
 * MsgBox("This file is normal.")
 * End If
 *
 * ' Test for normal and readonly.
 * Dim normalReadonly As FileAttribute
 * normalReadonly = FileAttribute.Normal Or FileAttribute.ReadOnly
 * If (MyAttr And normalReadonly) = normalReadonly Then
 * MsgBox("This file is normal and readonly.")
 * End If
 *
 * ' Assume MYDIR is a directory or folder.
 * MyAttr = GetAttr("C:\MYDIR")
 * If (MyAttr And FileAttribute.Directory) = FileAttribute.Directory Then
 * MsgBox("MYDIR is a directory")
 * End If
 * </PRE>
 *
 * @see FileAttr FileAttr Function
 * @see SetAttr SetAttr Function
 */
function FileAttribute GetAttr(ByVal PathName As String);


/**
 * Returns a Char value representing the character from the specified index in the supplied string.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If Index is less than 1 or greater than the index of the last character in Str, an ArgumentException is thrown.
 *
 * @param Str Required. Any valid String expression.
 * @param Index   Required. Integer expression. The (1-based) index of the character in Str to be returned.
 *
 * @exception ArgumentException 5 Str is Nothing, Index < 1, or Index is greater than index of last character of Str.
 *
 * @example
 * <P>
 * This example shows how to use the GetChar function to return a character from a specified index in a String.
 *
 * <PRE>
 * Dim myString As String = "ABCDE"
 * Dim myChar As Char
 * myChar = GetChar(myString, 4)   ' myChar = "D"
 * </PRE>
 *
 * @see Mid Function
 */
function Char GetChar(
   ByVal Str As String,
   ByVal Index As Integer
);

/**
 * Returns the exception representing the error that occurred.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The GetException function is available only from the Err object class. It works with the Exception property of the Err object to display the error that has occurred.
 *
 * @example
 * <P>
 * The following code displays the message assigned to the exception in the Err object:
 *
 * <PRE>
 * On Error Resume Next
 * Dim myError As System.Exception
 * ' Generate an overflow exception.
 * Err.Raise(6)
 * ' Assigns the exception from the Err object to myError.
 * myError = Err.GetException()
 * ' Displays the message associated with the exception.
 * MsgBox(myError.Message)
 * </PRE>
 */
function Exception GetException();


/**
 * Returns a reference to an object provided by a COM component.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * Use the GetObject function to load an instance of a COM component >from a file. For example:
 * <P>
 *
 * <PRE>
 * Dim CADObject As Object
 * CADObject = GetObject("C:\CAD\SCHEMA.CAD")
 * </PRE>
 *
 * <P>
 * When this code is executed, the application associated with the specified pathname is started and the object in the specified file is activated.
 * <P>
 * If PathName is a zero-length string (""), GetObject returns a new object instance of the specified type. If the PathName argument is omitted, GetObject returns a currently active object of the specified type. If no object of the specified type exists, an error occurs.
 * <P>
 * Some applications allow you to activate a sub-object associated with a file. Add an exclamation point (!) to the end of the file name and follow it with a string that identifies the part of the file you want to activate. For information on how to create this string, see the documentation for the application that created the object.
 * <P>
 * For example, in a drawing application you might have multiple layers to a drawing stored in a file. You could use the following code to activate a layer within a drawing called SCHEMA.CAD:
 *
 * <PRE>
 * LayerObject = GetObject("C:\CAD\SCHEMA.CAD!Layer3")
 * </PRE>
 *
 * <P>
 * If you don't specify the object's Class, Automation determines the application to start and the object to activate, based on the file name you provide. Some files, however, may support more than one class of object. For example, a drawing might support three different types of objects: an Application object, a Drawing object, and a Toolbar object, all of which are part of the same file. To specify which object in a file you want to activate, use the optional Class argument. For example:
 *
 * <PRE>
 * Dim MyObject As Object
 * MyObject = GetObject("C:\DRAWINGS\SAMPLE.DRW", "FIGMENT.DRAWING")
 * </PRE>
 *
 * <P>
 * In the example, FIGMENT is the name of a drawing application and DRAWING is one of the object types it supports.
 * <P>
 * Once an object is activated, you reference it in code using the object variable you defined. In the preceding example, you access properties and methods of the new object using the object variable MyObject. For example:
 *
 * <PRE>
 * MyObject.Line (9, 90)
 * MyObject.InsertText (9, 100, "Hello, world.")
 * MyObject.SaveAs ("C:\DRAWINGS\SAMPLE.DRW")
 * </PRE>
 *
 * <P>
 * Note   Use the GetObject function when there is a current instance of the object or if you want to create the object with a file already loaded. If there is no current instance, and you do not want the object started with a file loaded, use the CreateObject function. If an object has registered itself as an Active-X single-instance object, only one instance of the object is created, no matter how many times CreateObject is executed. With a single-instance object, GetObject always returns the same instance when called with the zero-length string ("") syntax, and it causes an error if the PathName argument is omitted. You cannot use GetObject to obtain a reference to a class created with Visual Basic.
 *
 * @param PathName   Optional; String. The full path and name of the file containing the object to retrieve. If pathname is omitted, class is required.
 * @param Class      Optional; String. A string representing the class of the object.
 *
 * <P>
 * The Class argument has the following syntax and parts:
 * <P>
 * appname.objecttype
 *
 * <P>
 * <b>Class Parameters</b>
 * <P>
 *
 * appname Required; String. The name of the application providing the object.
 *
 * <P>
 * objecttype Required; String. The type or class of object to create.
 *
 * @exception Exception   No object with the specified pathname exists.
 * @exception FileNotFoundException   No object of the specified type exists.
 *
 * @example
 * <P>
 * This example uses the GetObject function to get a reference to a specific Microsoft Excel worksheet (MyXL). It uses the worksheet's Application property to make Microsoft Excel visible, to close it, and so on. Using two API calls, the DetectExcel sub procedure looks for Microsoft Excel, and if it is running, enters it in the running object table. The first call to GetObject causes an error if Microsoft Excel isn't already running. In the example, the error causes the ExcelWasNotRunning flag to be set to True. The second call to GetObject specifies a file to open. If Microsoft Excel isn't already running, the second call starts it and returns a reference to the worksheet represented by the specified file, test.xls. The file must exist in the specified location; otherwise, the Visual Basic error Automation error is generated. Next the example code makes both Microsoft Excel and the window containing the specified worksheet visible.
 *
 * <P>
 * Option Strict Off is required because this example uses late binding, where objects are assigned to generic object variables. You can specify Option Strict On and declare objects of specific object types if you add a reference to the Excel type library from the COM tab of the Add Reference dialog box of the Project menu in Visual Studio .NET.
 *
 * <P>
 * <PRE>
 * ' Add Option Strict Off to the top of your program.
 * Option Strict Off
 *  ' Declare necessary API routines:
 *    Declare Function FindWindow Lib "user32" Alias _
 *    "FindWindowA" (ByVal lpClassName As String, _
 *    ByVal lpWindowName As Long) As Long
 *    Declare Function SendMessage Lib "user32" Alias _
 *    "SendMessageA" (ByVal hWnd As Long, ByVal wMsg As Long, _
 *    ByVal wParam As Long, ByVal lParam As Long) As Long
 *
 * Sub GetExcel()
 *   Dim MyXL As Object   ' Variable to hold reference
 *   ' to Microsoft Excel.
 *   Dim ExcelWasNotRunning As Boolean   ' Flag for final release.
 *
 *   ' Test to see if there is a copy of Microsoft Excel already running.
 *   On Error Resume Next   ' Defer error trapping.
 *   ' Getobject function called without the first argument returns a
 *   ' reference to an instance of the application.
 *   ' If the application is not running, an error occurs.
 *   MyXL = GetObject(, "Excel.Application")
 *   If Err().Number <> 0 Then ExcelWasNotRunning = True
 *   Err().Clear() ' Clear Err object in case error occurred.
 *
 *   ' Check for Microsoft Excel. If Microsoft Excel is running,
 *   ' enter it into the Running Object table.
 *   DetectExcel()
 *
 *   ' Set the object variable to reference the file you want to see.
 *   MyXL = GetObject("c:\vb\TEST.XLS")
 *
 *   ' Show Microsoft Excel through its Application property. Then
 *   ' show the actual window containing the file using the Windows
 *   ' collection of the MyXL object reference.
 *   MyXL.Application.Visible = True
 *   MyXL.Parent.Windows(1).Visible = True
 *   '  Do manipulations of your  file here.
 *   '
 * End Sub
 *
 * Sub DetectExcel()
 *   ' Procedure dectects a running Excel and registers it.
 *   Const WM_USER = 1024
 *   Dim hWnd As Long
 *   ' If Excel is running this API call returns its handle.
 *   hWnd = FindWindow("XLMAIN", 0)
 *   If hWnd = 0 Then   ' 0 means Excel not running.
 *     Exit Sub
 *   Else
 *     ' Excel is running so use the SendMessage API
 *     ' function to enter it in the Running Object Table.
 *     SendMessage(hWnd, WM_USER + 18, 0, 0)
 *   End If
 * End Sub
 * </PRE>
 *
 * <P>
 * When you call the GetExcel function, a check is made to see if Excel is already running. If it is not, then an instance of Excel is created.
 *
 * @see CreateObject CreateObject Function
 */
function Object GetObject(
  Optional ByVal PathName As String = Nothing,
  Optional ByVal Class As String = Nothing
);

/**
 * Returns a key setting value from an application's entry in the Windows registry.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If any of the items named in the GetSetting arguments do not exist, GetSetting returns a value of Default.
 * <P>
 * GetSetting requires that a user be logged on since it operates under the HKEY_LOCAL_USER registry key, which is not active until a user logs on interactively.
 * <P>
 * Registry settings that are to be accessed from a non-interactive process (such as mtx.exe) should be stored under either the HKEY_LOCAL_MACHINE\Software\ or the HKEY_USER\DEFAULT\Software registry keys.
 *
 * @param AppName  Required. String expression containing the name of the application or project whose key setting is requested.
 * @param Section  Required. String expression containing the name of the section in which the key setting is found.
 * @param Key      Required. String expression containing the name of the key setting to return.
 * @param Default  Optional. Expression containing the value to return if no value is set in the Key setting. If omitted, Default is assumed to be a zero-length string ("").
 *
 * @exception ArgumentException   One or more arguments are not String expressions, or user is not logged in.
 *
 * @example
 * <P>
 * This example first uses the SaveSetting statement to make entries in the Windows registry for the application specified as AppName, and then uses the GetSetting function to display one of the settings. Because the Default argument is specified, some value is guaranteed to be returned. Note that Section names can't be retrieved with GetSetting. Finally, the DeleteSetting statement removes all the application's entries.
 *
 * <P>
 * <PRE>
 * ' Place some settings in the registry.
 * SaveSetting("MyApp", "Startup", "Top", "75")
 * SaveSetting("MyApp", "Startup", "Left", "50")
 * Console.WriteLine(GetSetting("MyApp", "Startup", "Left", "25"))
 * DeleteSetting("MyApp")
 * </PRE>
 *
 * @see DeleteSetting DeleteSettings Function
 * @see GetAllSettings GetAllSettings Function
 * @see SaveSetting SaveSetting Function
 */
function String GetSetting(
   ByVal AppName As String,
   ByVal Section As String,
   ByVal Key As String,
   Optional ByVal Default As String = ""
);

/**
 * Returns a string representing the hexadecimal value of a number.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If Number is not already a whole number, it is rounded to the nearest whole number before being evaluated.
 *
 * <pre>
 * If Number is             Hex returns
 * Empty                    Zero (0)
 * Any numeric value        Up to sixteen hexadecimal characters
 * </pre>
 *
 * <P>
 * You can represent hexadecimal numbers directly by preceding numbers in the proper range with &H. For example, &H10 represents decimal 16 in hexadecimal notation.
 *
 * @param Number  Required. Any valid numeric expression or String expression.
 *
 * @exception ArgumentNullException   Number is not specified.
 * @exception ArgumentException   Number is not a numeric type.
 *
 * @example
 * <P>
 * This example uses the Hex function to return the hexadecimal value of a number.
 *
 * <PRE>
 * Dim MyHex As String
 * MyHex = Hex(5)   ' Returns 5.
 * MyHex = Hex(10)   ' Returns A.
 * MyHex = Hex(459)   ' Returns 1CB.
 * </PRE>
 *
 * @see Oct Oct Function
 */
function String Hex(ByVal Number As Byte);

/**
 * Returns a string representing the hexadecimal value of a number.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If Number is not already a whole number, it is rounded to the nearest whole number before being evaluated.
 *
 * <pre>
 * If Number is             Hex returns
 * Empty                    Zero (0)
 * Any numeric value        Up to sixteen hexadecimal characters
 * </pre>
 *
 * <P>
 * You can represent hexadecimal numbers directly by preceding numbers in the proper range with &H. For example, &H10 represents decimal 16 in hexadecimal notation.
 *
 * @param Number  Required. Any valid numeric expression or String expression.
 *
 * @exception ArgumentNullException   Number is not specified.
 * @exception ArgumentException   Number is not a numeric type.
 *
 * @example
 * <P>
 * This example uses the Hex function to return the hexadecimal value of a number.
 *
 * <PRE>
 * Dim MyHex As String
 * MyHex = Hex(5)   ' Returns 5.
 * MyHex = Hex(10)   ' Returns A.
 * MyHex = Hex(459)   ' Returns 1CB.
 * </PRE>
 *
 * @see Oct Oct Function
 */
function String Hex(ByVal Number As Short);

/**
 * Returns a string representing the hexadecimal value of a number.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If Number is not already a whole number, it is rounded to the nearest whole number before being evaluated.
 *
 * <pre>
 * If Number is             Hex returns
 * Empty                    Zero (0)
 * Any numeric value        Up to sixteen hexadecimal characters
 * </pre>
 *
 * <P>
 * You can represent hexadecimal numbers directly by preceding numbers in the proper range with &H. For example, &H10 represents decimal 16 in hexadecimal notation.
 *
 * @param Number  Required. Any valid numeric expression or String expression.
 *
 * @exception ArgumentNullException   Number is not specified.
 * @exception ArgumentException   Number is not a numeric type.
 *
 * @example
 * <P>
 * This example uses the Hex function to return the hexadecimal value of a number.
 *
 * <PRE>
 * Dim MyHex As String
 * MyHex = Hex(5)   ' Returns 5.
 * MyHex = Hex(10)   ' Returns A.
 * MyHex = Hex(459)   ' Returns 1CB.
 * </PRE>
 *
 * @see Oct Oct Function
 */
function String Hex(ByVal Number As Integer);

/**
 * Returns a string representing the hexadecimal value of a number.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If Number is not already a whole number, it is rounded to the nearest whole number before being evaluated.
 *
 * <pre>
 * If Number is             Hex returns
 * Empty                    Zero (0)
 * Any numeric value        Up to sixteen hexadecimal characters
 * </pre>
 *
 * <P>
 * You can represent hexadecimal numbers directly by preceding numbers in the proper range with &H. For example, &H10 represents decimal 16 in hexadecimal notation.
 *
 * @param Number  Required. Any valid numeric expression or String expression.
 *
 * @exception ArgumentNullException   Number is not specified.
 * @exception ArgumentException   Number is not a numeric type.
 *
 * @example
 * <P>
 * This example uses the Hex function to return the hexadecimal value of a number.
 *
 * <PRE>
 * Dim MyHex As String
 * MyHex = Hex(5)   ' Returns 5.
 * MyHex = Hex(10)   ' Returns A.
 * MyHex = Hex(459)   ' Returns 1CB.
 * </PRE>
 *
 * @see Oct Oct Function
 */
function String Hex(ByVal Number As Long);

/**
 * Returns a string representing the hexadecimal value of a number.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If Number is not already a whole number, it is rounded to the nearest whole number before being evaluated.
 *
 * <pre>
 * If Number is             Hex returns
 * Empty                    Zero (0)
 * Any numeric value        Up to sixteen hexadecimal characters
 * </pre>
 *
 * <P>
 * You can represent hexadecimal numbers directly by preceding numbers in the proper range with &H. For example, &H10 represents decimal 16 in hexadecimal notation.
 *
 * @param Number  Required. Any valid numeric expression or String expression.
 *
 * @exception ArgumentNullException   Number is not specified.
 * @exception ArgumentException   Number is not a numeric type.
 *
 * @example
 * <P>
 * This example uses the Hex function to return the hexadecimal value of a number.
 *
 * <PRE>
 * Dim MyHex As String
 * MyHex = Hex(5)   ' Returns 5.
 * MyHex = Hex(10)   ' Returns A.
 * MyHex = Hex(459)   ' Returns 1CB.
 * </PRE>
 *
 * @see Oct Oct Function
 */
function String Hex(ByVal Number As Object);

/**
 * Returns an Integer value from 0 through 23 representing the hour of the day.
 *
 * <P>
 * @param TimeValue Required. Date value from which you want to extract the hour.
 *
 * <P>
 * You can also obtain the hour of the day by calling DatePart and specifying DateInterval.Hour for the Interval argument.
 *
 * @example
 * <P>
 * This example uses the Hour function to obtain the hour from a specified time. In the development environment, the time literal is displayed in short time format using the locale settings of your code.
 *
 * <P>
 * <PRE>
 * Dim MyTime As Date
 * Dim MyHour As Integer
 * MyTime = #4:35:17 PM#   ' Assign a time.
 * MyHour = Hour(MyTime)   ' MyHour contains 16.
 * </PRE>
 *
 * @see Day Day Function
 * @see Minute Minute Function
 * @see Second Second Function
 * @see DatePart DatePart Function
 */
function Integer Hour(ByVal TimeValue As DateTime);

/**
 * Returns one of two objects, depending on the evaluation of an expression.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * Note   The expressions in the argument list can include function calls. As part of preparing the argument list for the call to IIf, the Visual Basic compiler calls every function in every expression. This means that you cannot rely on a particular function not being called if the other argument is selected by Expression.
 *
 * @param Expression Required. Boolean. The expression you want to evaluate.
 * @param TruePart Required. Object. Returned if Expression evaluates to True.
 * @param FalsePart Required. Object. Returned if Expression evaluates to False.
 *
 * @example
 * <P>
 * This example uses the IIf function to evaluate the TestMe parameter of the CheckIt procedure and returns the word "Large" if the amount is greater than 1000; otherwise, it returns the word "Small".
 *
 * <P>
 * <PRE>
 * Function CheckIt (ByVal TestMe As Integer) As String
 * CheckIt = IIf(TestMe > 1000, "Large", "Small")
 * End Function
 * </PRE>
 *
 * @see Choose Choose Function
 * @see Switch Switch Function
 */
function Object IIf(
   ByVal Expression As Boolean,
   ByVal TruePart As Object,
   ByVal FalsePart As Object
);

/**
 * Reads data from an open sequential file and assigns the data to variables.
 * <P>
 *
 * <b>Remarks</b>
 * <P>
 * Data read with Input is usually written to a file with Write. Use this function only with files opened in Input or Binary mode.
 * <P>
 * When read, standard string or numeric data is assigned to variables without modification. The following table illustrates how other input data are treated:
 *
 * <Pre>
 * Data                             Value assigned to variable
 * Delimiting comma or blank line   Empty
 * #NULL#                           DBNull
 * #TRUE# or #FALSE#                True or False
 * #yyyy-mm-dd hh:mm:ss#            The date and/or time represented by the expression
 * #ERROR errornumber#              errornumber (variable is an object tagged as an error)
 * </pre>
 *
 * <P>
 * If you reach the end of the file while you are inputting a data item, the input is terminated and an error occurs.
 * <P>
 * Note   The Input function is not localized. For example, in the German version, if you input 3,14159, it will return only 3, since the comma is treated as a variable separator, rather than a decimal point.
 *
 * @exception IOException   FileNumber does not exist.
 * @exception IOException   File mode is invalid.
 *
 * @example
 * <P>
 * This example uses the Input function to read data from a file into two variables. This example assumes that TESTFILE is a file with a few lines of data written to it using the Write function; that is, each line contains a string in quotations and a number separated by a comma, for example, ("Hello", 234).
 *
 * <P>
 * <PRE>
 * FileOpen(1, "TESTFILE", OpenMode.Output)
 * Write(1, "hello")
 * Write(1, 14)
 * FileClose(1)
 *
 * Dim s As String
 * Dim i As Integer
 * FileOpen(1, "TESTFILE", OpenMode.Input)
 * Input(1, s)
 * Debug.WriteLine(s)
 * Input(1, i)
 * Debug.WriteLine(i)
 * FileClose(1)
 * </PRE>
 *
 * @see InputString InputString Function
 * @see FileOpen FileOpen Function
 * @see Print Print Function
 * @see PrintLine PrintLine Function
 * @see Write Write Function
 * @see WriteLine WriteLine Function
 */
procedure Input(
   FileNumber As Integer,
   ByRef Value As Object
);

/**
 * Displays a prompt in a dialog box, waits for the user to input text or click a button, and then returns a string containing the contents of the text box.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * To specify more than the first argument, you must use the InputBox function in an expression. If you omit any positional arguments, you must retain the corresponding comma delimiter.
 *
 * <P>
 * @param Prompt Required. String expression displayed as the message in the dialog box. The maximum length of Prompt is approximately 1024 characters, depending on the width of the characters used. If Prompt consists of more than one line, you can separate the lines using a carriage return character (Chr(13)), a linefeed character (Chr(10)), or a carriage returnlinefeed character combination (Chr(13) & Chr(10)) between each line.
 * @param Title  Optional. String expression displayed in the title bar of the dialog box. If you omit Title, the application name is placed in the title bar.
 * @param DefaultResponse  Optional. String expression displayed in the text box as the default response if no other input is provided. If you omit DefaultResponse, the displayed text box is empty.
 * @param XPos  Optional. Numeric expression that specifies, in twips, the distance of the left edge of the dialog box from the left edge of the screen. If you omit XPos, the dialog box is centered horizontally.
 * @param YPos  Optional. Numeric expression that specifies, in twips, the distance of the upper edge of the dialog box from the top of the screen. If you omit YPos, the dialog box is positioned vertically approximately one-third of the way down the screen.
 *
 * @example
 * <P>
 * This example shows various ways to use the InputBox function to prompt the user to enter a value. If the x and y positions are omitted, the dialog box is automatically centered for the respective axes. The variable MyValue contains the value entered by the user if the user clicks OK or presses the ENTER key. If the user clicks Cancel, a zero-length string is returned.
 *
 * <PRE>
 * Dim message, title, defaultValue As String
 * Dim myValue As Object
 * message = "Enter a value between 1 and 3"   ' Set prompt.
 * title = "InputBox Demo"   ' Set title.
 * DefaultValue = "1"   ' Set default value.
 *
 * ' Display message, title, and default value.
 * myValue = InputBox(message, title, defaultValue)
 *
 * ' Display dialog box at position 100, 100.
 * myValue = InputBox(message, title, defaultValue, 100, 100)
 * </PRE>
 *
 * @see MsgBox MsgBox Function
 * @see Chr Chr Function
 * @see ChrW ChrW Function
 *
 */
function String InputBox(
   ByVal Prompt As String,
   Optional ByVal Title As String = "",
   Optional ByVal DefaultResponse As String = "",
   Optional ByVal XPos As Integer = -1,
   Optional ByVal YPos As Integer = -1
);

/**
 * Returns String value containing characters from a file opened in Input or Binary mode.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * Data read with the InputString function is usually written to a file with Print or FilePut. Use this function only with files opened in Input or Binary mode.
 * <P>
 * Unlike the Input function, the InputString function returns all of the characters it reads, including commas, carriage returns, linefeeds, quotation marks, and leading spaces.
 * <P>
 * With files opened for Binary access, an attempt to read through the file using the InputString function until EOF returns True generates an error. Use the LOF and Loc functions instead of EOF when reading binary files with InputString, or use FileGet when using the EOF function.
 *
 * @param FileNumber Required. Any valid file number.
 * @param CharCount Required. Any valid numeric expression specifying the number of characters to read.
 *
 * @exception IOException   FileNumber does not exist.
 * @exception ArgumentException   CharCount < 0 or > 214.
 *
 * @example
 * <P>
 * This example uses the InputString function to read one character at a time from a file and print it to the Output window. This example assumes that MYFILE is a text file with a few lines of sample data.
 *
 * <P>
 * <PRE>
 * Dim oneChar As Char
 * FileOpen(1,  "MYFILE.TXT", OpenMode.Input) ' Open file.
 * While Not EOF(1)   ' Loop until end of file.
 * oneChar = (InputString(1, 1))   ' Get one character.
 * System.Console.Out.WriteLine(oneChar)   ' Print to the output window.
 * End While
 * FileClose(1)
 * </PRE>
 *
 * @see Input Input Function
 */
function String InputString(
   ByVal FileNumber As Integer,
   ByVal CharCount As Integer
);

/**
 * Returns an integer specifying the start position of the first occurrence of one string within another.
 *
 * <P>
 * <b>Settings</b>
 * <P>
 * The compare argument settings are:
 *
 * <Pre>
 * Constant Value Description
 * Binary     0   Performs a binary comparison
 * Text       1   Performs a text comparison
 * </pre>
 *
 * @param Start Required. Numeric expression that sets the starting position for each search. If omitted, search begins at the first character position. The start index is 1 based.
 * @param String1 Required. String expression being searched.
 * @param String2 Required. String expression sought.
 * @param Compare Optional. Specifies the type of string comparison. If Compare is omitted, the Option Compare setting determines the type of comparison. Specify a valid LCID (LocaleID) to use locale-specific rules in the comparison.
 *
 * @exception ArgumentException   Start < 1.
 *
 * @return
 *
 * <pre>
 * If                                      InStr returns
 * String1 is zero length or Nothing       0
 * String2 is zero length or Nothing       start
 * String2 is not found                    0
 * String2 is found within String1         Position where match begins
 * Start > String2                         0
 * </pre>
 *
 * @example
 * <P>
 * This example uses the InStr function to return the position of the first occurrence of one string within another.
 *
 * <PRE>
 * Dim SearchString, SearchChar As String
 * Dim MyPos As Integer
 *
 * SearchString ="XXpXXpXXPXXP"   ' String to search in.
 * SearchChar = "P"   ' Search for "P".
 *
 * ' A textual comparison starting at position 4. Returns 6.
 * MyPos = InStr(4, SearchString, SearchChar, CompareMethod.Text)
 *
 * ' A binary comparison starting at position 1. Returns 9.
 * MyPos = InStr(1, SearchString, SearchChar, CompareMethod.Binary)
 *
 * ' Comparison is binary by default (last argument is omitted).
 * MyPos = InStr(SearchString, SearchChar)   ' Returns 9.
 *
 * MyPos = InStr(1, SearchString, "W")   ' Returns 0.
 * </PRE>
 *
 * @see InStrRev InStrRev Function
 * @see StrComp StrComp Function
 */
function Integer InStr(
   ByVal Start As Integer,
   ByVal String1 As String,
   ByVal String2 As String,
   Optional ByVal Compare As Microsoft.VisualBasic.CompareMethod
);

/**
 * Returns the position of the first occurrence of one string within another, starting from the right side of the string.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * Note that the syntax for the InStrRev function is not the same as the syntax for the InStr function.
 *
 * <b>Settings</b>
 * <P>
 * The Compare argument can have the following values:
 *
 * <P>
 * Constant Description
 * Binary Performs a binary comparison
 * Text Performs a textual comparison
 *
 * <P>
 * <b>Settings</b>
 * <P>
 * The Compare argument can have the following values:
 * <P>
 *
 * <pre>
 * Constant  Description
 * Binary    Performs a binary comparison
 * Text      Performs a textual comparison
 * </pre>
 *
 * <P>
 * <b>Return Values</b>
 * <P>
 * InStrRev returns the following values:
 * <P>
 *
 *
 * @param StringCheck Required. String expression being searched.
 * @param StringMatch Required. String expression being searched for.
 * @param Start Optional. Numeric expression that sets the one-based starting position for each search, starting from the left side of the string. If Start is omitted, 1 is used, which means that the search begins at the last character position. Search then proceeds from right to left.
 * @param Compare Optional. Numeric value indicating the kind of comparison to use when evaluating substrings. If omitted, a binary comparison is performed. See Settings for values.
 *
 * @exception ArgumentException  Start = 0 or Start < -1.
 *
 * @return
 *
 * <pre>
 * If                                              InStrRev returns
 * StringCheck is zero-length                      0
 * StringMatch is zero-length                      start
 * StringMatch is not found                        0
 * StringMatch is found within StringCheck         Position at which the first match is found, starting with the left side of the string.
 * Start is greater than length of StringMatch     0
 * </pre>
 *
 * @example
 * <P>
 * This example demonstrates the use of the InStrRev function:
 *
 * <P>
 * <PRE>
 * Dim myString As String = "the quick brown fox jumps over the lazy dog"
 * Dim myNumber As Integer
 * MyNumber = InStrRev(myString, "the")   ' Returns 32.
 * MyNumber = InStrRev(myString, "the", 16)   ' Returns 1
 * </PRE>
 *
 * @see InStr InStr Function
 */
function Integer InStrRev(
   ByVal StringCheck As String,
   ByVal StringMatch As String,
   Optional ByVal Start As Integer = -1,
   Optional ByVal Compare As CompareMethod = CompareMethod.Binary
);


/**
 * Returns a Double specifying the interest payment for a given period of an annuity based on periodic, fixed payments and a fixed interest rate.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * An annuity is a series of fixed cash payments made over a period of time. An annuity can be a loan (such as a home mortgage) or an investment (such as a monthly savings plan).
 * <P>
 * The Rate and NPer arguments must be calculated using payment periods expressed in the same units. For example, if Rate is calculated using months, NPer must also be calculated using months.
 * <P>
 * For all arguments, cash paid out (such as deposits to savings) is represented by negative numbers; cash received (such as dividend checks) is represented by positive numbers.
 *
 * @param Rate Required. Double specifying interest rate per period. For example, if you get a car loan at an annual percentage rate (APR) of 10 percent and make monthly payments, the rate per period is 0.1/12, or 0.0083.
 * @param Per Required. Double specifying payment period in the range 1 through NPer.
 * @param NPer Required. Double specifying total number of payment periods in the annuity. For example, if you make monthly payments on a four-year car loan, your loan has a total of 4 * 12 (or 48) payment periods.
 * @param PV Required. Double specifying present value, or value today, of a series of future payments or receipts. For example, when you borrow money to buy a car, the loan amount is the present value to the lender of the monthly car payments you will make.
 * @param FV Optional. Double specifying future value or cash balance you want after you've made the final payment. For example, the future value of a loan is $0 because that's its value after the final payment. However, if you want to save $50,000 over 18 years for your child's education, then $50,000 is the future value. If omitted, 0 is assumed.
 * @param Due Optional. Object of type Microsoft.VisualBasic.DueDate that specifies when payments are due. This argument must be either DueDate.EndOfPeriod if payments are due at the end of the payment period, or DueDate.BegOfPeriod if payments are due at the beginning of the period. If omitted, DueDate.EndOfPeriod is assumed.
 *
 * @exception ArgumentException   Per is invalid.
 *
 * @example
 * <P>
 * This example uses the IPmt function to calculate how much of a payment is interest when all the payments are of equal value. Given are the interest percentage rate per period (APR / 12), the payment period for which the interest portion is desired (Period), the total number of payments (TotPmts), the present value or principal of the loan (PVal), the future value of the loan (FVal), and a number that indicates whether the payment is due at the beginning or end of the payment period (PayType).
 *
 * <P>
 * <PRE>
 * Sub TestIPMT()
 *   Dim Fmt, Msg As String
 *   Dim APR, PVal, Fval, Period, IntPmt, TotInt, TotPmts As Double
 *   Dim PayType As DueDate
 *   Dim Response As MsgBoxResult
 *
 *   Fval = 0   ' Usually 0 for a loan.
 *   Fmt = "###,###,##0.00"   ' Define money format.
 *   PVal = CDbl(InputBox("How much do you want to borrow?"))
 *   APR = CDbl(InputBox("What is the annual percentage rate of your loan?"))
 *   If APR > 1 Then APR = APR / 100 ' Ensure proper form.
 *   TotPmts = CInt(InputBox("How many monthly payments?"))
 *   Response = MsgBox("Do you make payments at end of the month?", MsgBoxStyle.YesNo)
 *   If Response = MsgBoxResult.No Then
 *     PayType = DueDate.BegOfPeriod
 *   Else
 *     PayType = DueDate.EndOfPeriod
 *   End If
 *   For Period = 1 To TotPmts   ' Total all interest.
 *     IntPmt = IPmt(APR / 12, Period, TotPmts, -PVal, Fval, PayType)
 *     TotInt = TotInt + IntPmt
 *   Next Period
 *   Msg = "You'll pay a total of " & Format(TotInt, Fmt)
 *   Msg = Msg & " in interest for this loan."
 *   MsgBox(Msg)    ' Display results.
 * End Sub
 * </PRE>
 *
 * @see DDB DDB Function
 * @see IRR IRR Function
 * @see MIRR MIRR Function
 * @see NPer NPer Function
 * @see NPV NPV Function
 * @see Pmt Pmt Function
 * @see PPmt PPmt Function
 * @see PV PV Function
 * @see Rate Rate Function
 * @see SLN SLN Function
 * @see SYD SYD Function
 */
function Double IPmt(
   ByVal Rate As Double,
   ByVal Per As Double,
   ByVal NPer As Double,
   ByVal PV As Double,
   Optional ByVal FV As Double = 0,
   Optional ByVal Due As DueDate = DueDate.EndOfPeriod
);

/**
 * Returns a Double specifying the internal rate of return for a series of periodic cash flows (payments and receipts).
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The internal rate of return is the interest rate received for an investment consisting of payments and receipts that occur at regular intervals.
 * <P>
 * The IRR function uses the order of values within the array to interpret the order of payments and receipts. Be sure to enter your payment and receipt values in the correct sequence. The cash flow for each period doesn't need to be fixed, as it is for an annuity.
 * <P>
 * IRR is calculated by iteration. Starting with the value of Guess, IRR cycles through the calculation until the result is accurate to within 0.00001 percent. If IRR can't find a result after 20 tries, it fails.
 *
 * <P>
 * @param ValueArray() Required. Array of Double specifying cash flow values. The array must contain at least one negative value (a payment) and one positive value (a receipt).
 * @param Guess Optional. Object specifying value you estimate will be returned by IRR. If omitted, Guess is 0.1 (10 percent).
 *
 * @exception ArgumentException   Array argument values are invalid.
 *
 * @example
 * <P>
 * In this example, the IRR function returns the internal rate of return for a series of 5 cash flows contained in the array Values(). The first array element is a negative cash flow representing business start-up costs. The remaining 4 cash flows represent positive cash flows for the subsequent 4 years. Guess is the estimated internal rate of return.
 *
 * <P>
 * <PRE>
 * Sub TestIRR()
 *   Dim Guess, RetRate, Values(4) As Double
 *   Dim Fmt, Msg As String
 *   Guess = 0.1  ' Guess starts at 10 percent.
 *   Fmt = "#0.00"   ' Define percentage format.
 *   Values(0) = -70000   ' Business start-up costs.
 *   ' Positive cash flows reflecting income for four successive years.
 *   Values(1) = 22000 : Values(2) = 25000
 *   Values(3) = 28000 : Values(4) = 31000
 *   RetRate = IRR(Values, Guess) * 100   ' Calculate internal rate.
 *   Msg = "The internal rate of return for these five cash flows is "
 *   Msg = Msg & Format(RetRate, CStr(Fmt)) & " percent."
 *   MsgBox(Msg)    ' Display internal return rate.
 * End Sub
 * </PRE>
 *
 * @see DDB DDB Function
 * @see IRR IRR Function
 * @see MIRR MIRR Function
 * @see NPer NPer Function
 * @see NPV NPV Function
 * @see Pmt Pmt Function
 * @see PPmt PPmt Function
 * @see PV PV Function
 * @see Rate Rate Function
 * @see SLN SLN Function
 * @see SYD SYD Function
 */
function Double IRR(
    ByRef ValueArray() As Double,
   Optional ByVal Guess As Double = 0.1
);

/**
 * Returns a Boolean value indicating whether a variable points to an array.
 *
 * <P>
 * <b>Remarks</b>
 * IsArray returns True if the variable points to an array; otherwise, it returns False. IsArray is especially useful with objects containing arrays.
 *
 * <P>
 * @param VarName Required. Object variable.
 *
 * @example
 * <P>
 * This example uses the IsArray function to check if several variables refer to an array.
 *
 * <PRE>
 * Dim MyArray(4), YourArray(3) As Integer   ' Declare array variables.
 * Dim MyString As String
 * Dim MyCheck As Boolean
 * MyCheck = IsArray(MyArray)   ' Returns True.
 * MyCheck = IsArray(YourArray)   ' Returns True.
 * MyCheck = IsArray(MyString)   ' Returns False.
 *
 * @see IsDate IsDate Function
 * @see IsDBNull IsDBNull Function
 * @see IsError IsError Function
 * @see IsNothing IsNothing Function
 * @see IsNumeric IsNumeric Function
 * @see IsReference IsReference Function
 * @see TypeName TypeName Function
 */
function Boolean IsArray(ByVal VarName As Object);

/**
 * Returns a Boolean value indicating whether an expression can be converted to a date.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * IsDate returns True if the expression is of type Date or is a string convertible to type Date; otherwise, it returns False.
 *
 * @param Expression  Required. Object expression.
 *
 * @example
 * <P>
 * This example uses the IsDate function to determine if several variables can be converted to dates.
 *
 * <PRE>
 * Dim MyDate, YourDate As Date
 * Dim NoDate As String
 * Dim MyCheck As Boolean
 * MyDate = "February 12, 1969"
 * YourDate = #2/12/1969#
 * NoDate = "Hello"
 * MyCheck = IsDate(MyDate)   ' Returns True.
 * MyCheck = IsDate(YourDate)   ' Returns True.
 * MyCheck = IsDate(NoDate)   ' Returns False.
 * </PRE>
 *
 * @see IsArray IsArray Function
 * @see IsDBNull IsDBNull Function
 * @see IsError IsError Function
 * @see IsNothing IsNothing Function
 * @see IsNumeric IsNumeric Function
 * @see IsReference IsReference Function
 * @see TypeName TypeName Function
 */
function Boolean IsDate(ByVal Expression As Object);

/**
 * Returns a Boolean value indicating whether an expression evaluates to the System.DBNull class.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * IsDBNull returns True if the data type of Expression evaluates to the DBNull type; otherwise, IsDBNull returns False.
 * <P>
 * The System.DBNull value indicates that the Object represents missing or nonexistent data. DBNull is not the same as Nothing, which indicates that a variable has not yet been initialized. It is also not the same as a zero-length string (""), which is sometimes referred to as a null string.
 *
 * @param Expression  Required. Object expression.
 *
 * @example
 * <P>
 * This example uses the IsDBNull function to determine if a variable evaluates to DBNull.
 *
 * <PRE>
 * Dim MyVar As Object
 * Dim MyCheck As Boolean
 * MyCheck = IsDBNull(MyVar)   ' Returns False.
 * MyVar = ""
 * MyCheck = IsDBNull(MyVar)   ' Returns False.
 * MyVar = System.DBNull.Value
 * MyCheck = IsDBNull(MyVar)   ' Returns True.
 * MsgBox(MyCheck)
 * </PRE>
 *
 * @see IsArray IsArray Function
 * @see IsDBNull IsDBNull Function
 * @see IsError IsError Function
 * @see IsNothing IsNothing Function
 * @see IsNumeric IsNumeric Function
 * @see IsReference IsReference Function
 * @see TypeName TypeName Function
 * @see IsDate IsDate Function
 */
function Boolean IsDBNull(ByVal Expression As Object);

/**
 * Returns a Boolean value indicating whether an expression is an exception type.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * IsError returns True if the expression represents an Object variable that derives from the Exception class in the System namespace.
 * <P>
 * An exception that derives from System.Exception can be caught with the Try...Catch...Finally statements.
 *
 * @example
 * <P>
 * This example uses the IsError function to check if an expression represents a system exception.
 *
 * <PRE>
 * Dim ReturnVal As Object
 * Dim BadArg As String   ' Name of out-of-range argument.
 * Dim MyCheck As Boolean
 * ' ...
 * ReturnVal = New System.ArgumentOutOfRangeException(BadArg)
 * ' ...
 * MyCheck = IsError(ReturnVal)   ' Returns True.
 * </PRE>
 *
 * @see IsArray IsArray Function
 * @see IsDBNull IsDBNull Function
 * @see IsNothing IsNothing Function
 * @see IsNumeric IsNumeric Function
 * @see IsReference IsReference Function
 * @see TypeName TypeName Function
 * @see IsDate IsDate Function
 */
function Boolean IsError(ByVal Expression As Object);


/**
 * Returns a Boolean value indicating whether an expression has no object assigned to it.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * IsNothing returns True if the expression represents an Object variable that currently has no object assigned to it; otherwise, it returns False.
 *
 * @param Expression Required. Object expression.
 *
 * @example
 * <P>
 * This example uses the IsNothing function to determine if an object variable is associated with any object instance.
 *
 * <PRE>
 * Dim MyVar As Object   ' No instance assigned to this variable yet.
 * Dim MyCheck As Boolean
 * ' ...
 * MyCheck = IsNothing(MyVar)   ' Returns True.
 * ' ...
 * MyVar = "ABCDEF"   ' Assign a string instance to the variable.
 * MyCheck = IsNothing(MyVar)   ' Returns False.
 * ' ...
 * MyVar = Nothing   ' Disassociate the variable from any instance.
 * MyCheck = IsNothing(MyVar)   ' Returns True.
 * </PRE>
 *
 * @see IsArray IsArray Function
 * @see IsDBNull IsDBNull Function
 * @see IsError IsError Function
 * @see IsNumeric IsNumeric Function
 * @see IsReference IsReference Function
 * @see TypeName TypeName Function
 * @see IsDate IsDate Function
 */
function Boolean IsNothing(ByVal Expression As Object);


/**
 * Returns a Boolean value indicating whether an expression can be evaluated as a number.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * IsNumeric returns True if the entire Expression is recognized as a number; otherwise, it returns False.
 * <P>
 * IsNumeric returns True if the data type of Expression is Short, Integer, Long, Decimal, Single, or Short. It also returns True if Expression is a String that can be successfully converted to a Double. It returns False if Expression is of data type Date.
 *
 * @param Expression Required. Object expression.
 *
 * @example
 * <P>
 * This example uses the IsNumeric function to determine if the contents of a variable can be evaluated as a number.
 *
 * <PRE>
 * Dim MyVar As Object
 * Dim MyCheck As Boolean
 * ' ...
 * MyVar = "53"   ' Assign value.
 * MyCheck = IsNumeric(MyVar)   ' Returns True.
 * ' ...
 * MyVar = "459.95"   ' Assign value.
 * MyCheck = IsNumeric(MyVar)   ' Returns True.
 * ' ...
 * MyVar = "45 Help"   ' Assign value.
 * MyCheck = IsNumeric(MyVar)   ' Returns False.
 * </PRE>
 *
 * @see IsArray IsArray Function
 * @see IsDBNull IsDBNull Function
 * @see IsError IsError Function
 * @see IsNumeric IsNumeric Function
 * @see IsReference IsReference Function
 * @see TypeName TypeName Function
 * @see IsDate IsDate Function
 */
function Boolean IsNumeric(ByVal Expression As Object);



/**
 * Returns a Boolean value indicating whether an expression evaluates to a reference type.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * IsReference returns True if the expression represents a reference type, such as a class instance, a String type, or an array of any type; otherwise, it returns False.
 * <P>
 * A reference type contains a pointer to data stored elsewhere in memory. A value type contains its own data.
 *
 * @param Expression Required. Object expression.
 *
 * @example
 * This example uses the IsReference function to check if several variables refer to reference types.
 *
 * <PRE>
 * Dim MyArray(3) As Boolean
 * Dim MyString As String
 * Dim MyObject As Object
 * Dim MyNumber As Integer
 * MyArray(0) = IsReference(MyArray)   ' Returns True.
 * MyArray(1) = IsReference(MyString)   ' Returns True.
 * MyArray(2) = IsReference(MyObject)   ' Returns True.
 * MyArray(2) = IsReference(MyNumber)   ' Returns False.
 * </PRE>
 *
 * @see IsArray IsArray Function
 * @see IsDBNull IsDBNull Function
 * @see IsError IsError Function
 * @see IsNumeric IsNumeric Function
 * @see IsReference IsReference Function
 * @see TypeName TypeName Function
 * @see IsDate IsDate Function
 */
function Boolean IsReference(ByVal Expression As Object);

/**
 * Returns a string created by joining a number of substrings contained in an array.
 *
 * @param SourceArray() Required. One-dimensional array containing substrings to be joined.
 * @param Delimiter Optional. String used to separate the substrings in the returned string. If omitted, the space character (" ") is used. If Delimiter is a zero-length string (""), all items in the list are concatenated with no delimiters.
 *
 * @exception ArgumentException  SourceArray() is not one dimensional.
 *
 * @example
 * The following example demonstrates use of the Join function.
 *
 * <PRE>
 * Dim myItem(2) As String
 * Dim myShoppingList As String
 * myItem(0) = "Pickle"
 * myItem(1) = "Pineapple"
 * myItem(2) = "Papaya"
 * ' Returns "Pickle, Pineapple, Papaya"
 * myShoppingList = Join(myItem, ", ")
 * </PRE>
 *
 * @see Split Split Function
 */
function String Join(
   ByVal SourceArray() As Object,
   Optional ByVal Delimiter As String = " "
);

/**
 * Returns a string created by joining a number of substrings contained in an array.
 *
 * @param SourceArray() Required. One-dimensional array containing substrings to be joined.
 * @param Delimiter Optional. String used to separate the substrings in the returned string. If omitted, the space character (" ") is used. If Delimiter is a zero-length string (""), all items in the list are concatenated with no delimiters.
 *
 * @exception ArgumentException  SourceArray() is not one dimensional.
 *
 * @example
 * The following example demonstrates use of the Join function.
 *
 * <PRE>
 * Dim myItem(2) As String
 * Dim myShoppingList As String
 * myItem(0) = "Pickle"
 * myItem(1) = "Pineapple"
 * myItem(2) = "Papaya"
 * ' Returns "Pickle, Pineapple, Papaya"
 * myShoppingList = Join(myItem, ", ")
 * </PRE>
 *
 * @see Split Split Function
 */
function String Join(
   ByVal SourceArray() As String,
   Optional ByVal Delimiter As String = " "
);

/**
 * Deletes files from a disk.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * Kill supports the use of multiple-character (*) and single-character (?) wildcards to specify multiple files.
 *
 * @param PathName Required. String expression that specifies one or more file names to be deleted. PathName may include the directory or folder, and the drive.
 *
 * @exception IOException   Target file(s) open.
 * @exception FileNotFoundException   Target file(s) not found.
 *
 * @example
 * This example uses the Kill function to delete a file from a disk.
 *
 * <PRE>
 * ' Assume TESTFILE is a file containing some data.
 * Kill("TestFile")   ' Delete file.
 *
 * ' Delete all *.TXT files in current directory.
 * Kill("*.TXT")
 * </PRE>
 *
 * @see RmDir RmDir Function
 */
procedure Kill(ByVal PathName As String);

/**
 * Returns the lowest available subscript for the indicated dimension of an array.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * Since array subscripts start at 0, the lowest available subscript for every dimension is always 0.
 * <P>
 * For an array with the following dimensions, LBound returns the values in the following table:
 * <PRE>
 * Dim A(100, 5, 4) As Byte
 *
 * Call to LBound Return value
 * LBound(A, 1)   0
 * LBound(A, 2)   0
 * LBound(A, 3)   0
 * </pre>
 *
 * @param Array Required. Array of any data type. The array in which you want to find the lowest possible subscript of a dimension.
 * @param Rank Optional. Integer. The dimension for which the lowest possible subscript is to be returned. Use 1 for the first dimension, 2 for the second, and so on. If Rank is omitted, 1 is assumed.
 *
 * @exception ArgumentNullException   Array is Nothing.
 * @exception RankException   Rank < 1 or Rank is greater than the rank of Array.
 *
 * @example
 * This example uses the LBound function to determine the lowest available subscript for the indicated dimension of an array.
 *
 * <PRE>
 * Dim Lowest, MyArray(10, 15, 20), AnyArray(6) as Integer
 * Lowest = LBound(MyArray, 1)   ' Returns 0.
 * Lowest = LBound(MyArray, 3)   ' Returns 0.
 * Lowest = LBound(AnyArray)   ' Returns 0.
 * </PRE>
 *
 * @see UBound UBound Function
 */
function Integer LBound(
   ByVal Array As System.Array,
   Optional ByVal Rank As Integer = 1
);

/**
 * Returns a string or character converted to lowercase.
 *
 * <P>
 * <b>Remarks<b>
 * <P>
 * Only uppercase letters are converted to lowercase; all lowercase letters and nonletter characters remain unchanged.
 *
 * @param Value  Required. Any valid String or Char expression.
 *
 * @example
 * This example uses the LCase function to return a lowercase version of a string.
 *
 * <PRE>
 * Dim UpperCase, LowerCase As String
 * Uppercase = "Hello World 1234"   ' String to convert.
 * Lowercase = LCase(UpperCase)   ' Returns "hello world 1234".
 * </PRE>
 *
 * @see UCase UCase Function
 */
function Char LCase(ByVal Value As Char);

/**
 * Returns a string or character converted to lowercase.
 *
 * <P>
 * <b>Remarks<b>
 * <P>
 * Only uppercase letters are converted to lowercase; all lowercase letters and nonletter characters remain unchanged.
 *
 * @param Value  Required. Any valid String or Char expression.
 *
 * @example
 * This example uses the LCase function to return a lowercase version of a string.
 *
 * <PRE>
 * Dim UpperCase, LowerCase As String
 * Uppercase = "Hello World 1234"   ' String to convert.
 * Lowercase = LCase(UpperCase)   ' Returns "hello world 1234".
 * </PRE>
 *
 * @see UCase UCase Function
 */
function String LCase(ByVal Value As String);

/**
 * Returns a string containing a specified number of characters from the left side of a string.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * To determine the number of characters in Str, use the Len function. If used in a Windows Form, or any other class that has a Left property, you must fully qualify the function with Microsoft.VisualBasic.Left.
 *
 * @param Str Required. String expression from which the leftmost characters are returned.
 * @param Length Required. Integer expression. Numeric expression indicating how many characters to return. If 0, a zero-length string ("") is returned. If greater than or equal to the number of characters in Str, the entire string is returned.
 *
 * @exception ArgumentException   Length < 0.
 *
 * @example
 * This example demonstrates the use of the Left function to return a substring of a given String. In a class that has a Left property, it may be necessary to fully qualify the Left function.
 *
 * <PRE>
 * Dim myString As String = "Hello World!"
 * Dim subString As String
 * subString = Microsoft.VisualBasic.Left(myString, 5)   ' Returns "Hello
 * </PRE>
 *
 * @see Right Right Function
 * @see Len Len Function
 * @see Mid Mid Function
 */
function String Left(
   ByVal Str As String,
   ByVal Length As Integer
);

/**
 * Returns an integer containing either the number of characters in a string or the number of bytes required to store a variable.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * With user-defined types and Object variables, the Len function returns the size as it will be written to the file. If an Object contains a String, it will return the length of the string. If an Object contains any other type, it will return the size of the object as it will be written to the file.
 * <P>
 * Note   The Len function may not be able to determine the actual number of storage bytes required when used with variable-length strings in user-defined data types.
 *
 * @param Expression Any valid String expression or variable name. If Expression is of type Object, the Len function returns the size as it will be written to the file.
 *
 * @example
 * This example uses Len to return the number of characters in a string.
 *
 * <PRE>
 * Dim MyString As String
 * Dim MyLen As Integer
 * MyString = "Hello World"   ' Initializes variable.
 * MyLen = Len(MyString)   ' Returns 11.
 * </PRE>
 *
 * @see InStr InStr Function
 */
function Integer Len(
   ByVal Expression As Boolean
);

/**
 * Returns an integer containing either the number of characters in a string or the number of bytes required to store a variable.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * With user-defined types and Object variables, the Len function returns the size as it will be written to the file. If an Object contains a String, it will return the length of the string. If an Object contains any other type, it will return the size of the object as it will be written to the file.
 * <P>
 * Note   The Len function may not be able to determine the actual number of storage bytes required when used with variable-length strings in user-defined data types.
 *
 * @param Expression Any valid String expression or variable name. If Expression is of type Object, the Len function returns the size as it will be written to the file.
 *
 * @example
 * This example uses Len to return the number of characters in a string.
 *
 * <PRE>
 * Dim MyString As String
 * Dim MyLen As Integer
 * MyString = "Hello World"   ' Initializes variable.
 * MyLen = Len(MyString)   ' Returns 11.
 * </PRE>
 *
 * @see InStr InStr Function
 */
function Integer Len(
   ByVal Expression As Byte
);

/**
 * Returns an integer containing either the number of characters in a string or the number of bytes required to store a variable.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * With user-defined types and Object variables, the Len function returns the size as it will be written to the file. If an Object contains a String, it will return the length of the string. If an Object contains any other type, it will return the size of the object as it will be written to the file.
 * <P>
 * Note   The Len function may not be able to determine the actual number of storage bytes required when used with variable-length strings in user-defined data types.
 *
 * @param Expression Any valid String expression or variable name. If Expression is of type Object, the Len function returns the size as it will be written to the file.
 *
 * @example
 * This example uses Len to return the number of characters in a string.
 *
 * <PRE>
 * Dim MyString As String
 * Dim MyLen As Integer
 * MyString = "Hello World"   ' Initializes variable.
 * MyLen = Len(MyString)   ' Returns 11.
 * </PRE>
 *
 * @see InStr InStr Function
 */
function Integer Len(
   ByVal Expression As Char
);

/**
 * Returns an integer containing either the number of characters in a string or the number of bytes required to store a variable.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * With user-defined types and Object variables, the Len function returns the size as it will be written to the file. If an Object contains a String, it will return the length of the string. If an Object contains any other type, it will return the size of the object as it will be written to the file.
 * <P>
 * Note   The Len function may not be able to determine the actual number of storage bytes required when used with variable-length strings in user-defined data types.
 *
 * @param Expression Any valid String expression or variable name. If Expression is of type Object, the Len function returns the size as it will be written to the file.
 *
 * @example
 * This example uses Len to return the number of characters in a string.
 *
 * <PRE>
 * Dim MyString As String
 * Dim MyLen As Integer
 * MyString = "Hello World"   ' Initializes variable.
 * MyLen = Len(MyString)   ' Returns 11.
 * </PRE>
 *
 * @see InStr InStr Function
 */
function Integer Len(
   ByVal Expression As Double
);

/**
 * Returns an integer containing either the number of characters in a string or the number of bytes required to store a variable.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * With user-defined types and Object variables, the Len function returns the size as it will be written to the file. If an Object contains a String, it will return the length of the string. If an Object contains any other type, it will return the size of the object as it will be written to the file.
 * <P>
 * Note   The Len function may not be able to determine the actual number of storage bytes required when used with variable-length strings in user-defined data types.
 *
 * @param Expression Any valid String expression or variable name. If Expression is of type Object, the Len function returns the size as it will be written to the file.
 *
 * @example
 * This example uses Len to return the number of characters in a string.
 *
 * <PRE>
 * Dim MyString As String
 * Dim MyLen As Integer
 * MyString = "Hello World"   ' Initializes variable.
 * MyLen = Len(MyString)   ' Returns 11.
 * </PRE>
 *
 * @see InStr InStr Function
 */
function Integer Len(
   ByVal Expression As Integer
);

/**
 * Returns an integer containing either the number of characters in a string or the number of bytes required to store a variable.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * With user-defined types and Object variables, the Len function returns the size as it will be written to the file. If an Object contains a String, it will return the length of the string. If an Object contains any other type, it will return the size of the object as it will be written to the file.
 * <P>
 * Note   The Len function may not be able to determine the actual number of storage bytes required when used with variable-length strings in user-defined data types.
 *
 * @param Expression Any valid String expression or variable name. If Expression is of type Object, the Len function returns the size as it will be written to the file.
 *
 * @example
 * This example uses Len to return the number of characters in a string.
 *
 * <PRE>
 * Dim MyString As String
 * Dim MyLen As Integer
 * MyString = "Hello World"   ' Initializes variable.
 * MyLen = Len(MyString)   ' Returns 11.
 * </PRE>
 *
 * @see InStr InStr Function
 */
function Integer Len(
   ByVal Expression As Long
);

/**
 * Returns an integer containing either the number of characters in a string or the number of bytes required to store a variable.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * With user-defined types and Object variables, the Len function returns the size as it will be written to the file. If an Object contains a String, it will return the length of the string. If an Object contains any other type, it will return the size of the object as it will be written to the file.
 * <P>
 * Note   The Len function may not be able to determine the actual number of storage bytes required when used with variable-length strings in user-defined data types.
 *
 * @param Expression Any valid String expression or variable name. If Expression is of type Object, the Len function returns the size as it will be written to the file.
 *
 * @example
 * This example uses Len to return the number of characters in a string.
 *
 * <PRE>
 * Dim MyString As String
 * Dim MyLen As Integer
 * MyString = "Hello World"   ' Initializes variable.
 * MyLen = Len(MyString)   ' Returns 11.
 * </PRE>
 *
 * @see InStr InStr Function
 */
function Integer Len(
   ByVal Expression As Object
);

/**
 * Returns an integer containing either the number of characters in a string or the number of bytes required to store a variable.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * With user-defined types and Object variables, the Len function returns the size as it will be written to the file. If an Object contains a String, it will return the length of the string. If an Object contains any other type, it will return the size of the object as it will be written to the file.
 * <P>
 * Note   The Len function may not be able to determine the actual number of storage bytes required when used with variable-length strings in user-defined data types.
 *
 * @param Expression Any valid String expression or variable name. If Expression is of type Object, the Len function returns the size as it will be written to the file.
 *
 * @example
 * This example uses Len to return the number of characters in a string.
 *
 * <PRE>
 * Dim MyString As String
 * Dim MyLen As Integer
 * MyString = "Hello World"   ' Initializes variable.
 * MyLen = Len(MyString)   ' Returns 11.
 * </PRE>
 *
 * @see InStr InStr Function
 */
function Integer Len(
   ByVal Expression As Short
);

/**
 * Returns an integer containing either the number of characters in a string or the number of bytes required to store a variable.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * With user-defined types and Object variables, the Len function returns the size as it will be written to the file. If an Object contains a String, it will return the length of the string. If an Object contains any other type, it will return the size of the object as it will be written to the file.
 * <P>
 * Note   The Len function may not be able to determine the actual number of storage bytes required when used with variable-length strings in user-defined data types.
 *
 * @param Expression Any valid String expression or variable name. If Expression is of type Object, the Len function returns the size as it will be written to the file.
 *
 * @example
 * This example uses Len to return the number of characters in a string.
 *
 * <PRE>
 * Dim MyString As String
 * Dim MyLen As Integer
 * MyString = "Hello World"   ' Initializes variable.
 * MyLen = Len(MyString)   ' Returns 11.
 * </PRE>
 *
 * @see InStr
 * @see Data Type Summary
 */
function Integer Len(
   ByVal Expression As Single
);

/**
 * Returns an integer containing either the number of characters in a string or the number of bytes required to store a variable.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * With user-defined types and Object variables, the Len function returns the size as it will be written to the file. If an Object contains a String, it will return the length of the string. If an Object contains any other type, it will return the size of the object as it will be written to the file.
 * <P>
 * Note   The Len function may not be able to determine the actual number of storage bytes required when used with variable-length strings in user-defined data types.
 *
 * @param Expression Any valid String expression or variable name. If Expression is of type Object, the Len function returns the size as it will be written to the file.
 *
 * @example
 * This example uses Len to return the number of characters in a string.
 *
 * <PRE>
 * Dim MyString As String
 * Dim MyLen As Integer
 * MyString = "Hello World"   ' Initializes variable.
 * MyLen = Len(MyString)   ' Returns 11.
 * </PRE>
 *
 * @see InStr InStr Function
 */
function Integer Len(
   ByVal Expression As String
);

/**
 * Returns an integer containing either the number of characters in a string or the number of bytes required to store a variable.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * With user-defined types and Object variables, the Len function returns the size as it will be written to the file. If an Object contains a String, it will return the length of the string. If an Object contains any other type, it will return the size of the object as it will be written to the file.
 * <P>
 * Note   The Len function may not be able to determine the actual number of storage bytes required when used with variable-length strings in user-defined data types.
 *
 * @param Expression Any valid String expression or variable name. If Expression is of type Object, the Len function returns the size as it will be written to the file.
 *
 * @example
 * This example uses Len to return the number of characters in a string.
 *
 * <PRE>
 * Dim MyString As String
 * Dim MyLen As Integer
 * MyString = "Hello World"   ' Initializes variable.
 * MyLen = Len(MyString)   ' Returns 11.
 * </PRE>
 *
 * @see InStr InStr Function
 */
function Integer Len(
   ByVal Expression As DateTime
);

/**
 * Returns an integer containing either the number of characters in a string or the number of bytes required to store a variable.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * With user-defined types and Object variables, the Len function returns the size as it will be written to the file. If an Object contains a String, it will return the length of the string. If an Object contains any other type, it will return the size of the object as it will be written to the file.
 * <P>
 * Note   The Len function may not be able to determine the actual number of storage bytes required when used with variable-length strings in user-defined data types.
 *
 * @param Expression Any valid String expression or variable name. If Expression is of type Object, the Len function returns the size as it will be written to the file.
 *
 * @example
 * This example uses Len to return the number of characters in a string.
 *
 * <PRE>
 * Dim MyString As String
 * Dim MyLen As Integer
 * MyString = "Hello World"   ' Initializes variable.
 * MyLen = Len(MyString)   ' Returns 11.
 * </PRE>
 *
 * @see InStr InStr Function
 */
function Integer Len(
   ByVal Expression As Decimal
);

/**
 * Reads a single line from an open sequential file and assigns it to a String variable.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * Data read with LineInput is usually written to a file with Print.
 * <P>
 * The LineInput function reads from a file one character at a time until it encounters a carriage return (Chr(13)) or carriage returnlinefeed (Chr(13) + Chr(10)) sequence. Carriage returnlinefeed sequences are skipped rather than appended to the character string.
 *
 * @param FileNumber  Required. Any valid file number.
 *
 * @exception EndOfStreamException   End of file reached.
 * @exception IOException   FileNumber does not exist.
 *
 * @example
 * This example uses the LineInput function to read a line from a sequential file and assign it to a variable. This example assumes that TESTFILE is a text file with a few lines of sample data.
 *
 * <PRE>
 * Dim TextLine As String
 * FileOpen(1, "TESTFILE", OpenMode.Input)   ' Open file.
 * While Not EOF(1)   ' Loop until end of file.
 *   TextLine = LineInput(1)   ' Read line into variable.
 *   Debug.WriteLine(TextLine)   ' Print to the console.
 * End While
 * FileClose(1)   ' Close file.
 * </PRE>
 *
 * @see Chr Chr Function
 * @see ChrW ChrW Function
 * @see Input Input Function
 */
function String LineInput(ByVal FileNumber As Integer);

/**
 * Returns a Long value specifying the current read/write position within an open file.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The following describes the return value for each file access mode:
 * <P>
 *
 * <pre>
 * Mode        Return value
 * Random      Number of the last record read from or written to the file.
 * Sequential  Current byte position in the file divided by 128. However, information returned by Loc for sequential files is neither used nor required.
 * Binary      Position of the last byte read or written.
 * </pre>
 *
 * @param FileNumber  Required. Any valid Integer file number.
 *
 * @exception IOException   FileNumber does not exist.
 * @exception IOException   File mode is invalid.
 *
 * @example
 * This example uses the Loc function to return the current read/write position within an open file. This example assumes that MYFILE is a text file with a few lines of sample data.
 *
 * <PRE>
 * Dim location As Long
 * Dim oneLine As String
 * Dim oneChar As Char
 * FileOpen(1, "C:\MYFILE.TXT", OpenMode.Binary)
 * While location < EOF(1)
 *   Input(1, oneChar)
 *   location = Loc(1)
 *   Debug.WriteLine(location & ControlChars.CrLf)
 * End While
 * FileClose(1)
 * </PRE>
 *
 * @see EOF EOF Function
 * @see LOF LOF Function
 * @see Seek Seek Function
 */
function Long Loc(ByVal FileNumber As Integer);

/**
 * Controls access by other processes to all or part of a file opened using the Open function.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The Lock and Unlock functions are used in environments where several processes might need access to the same file.
 * <P>
 * Lock and Unlock functions are always used in pairs. The arguments to Lock and Unlock must match exactly.
 * <P>
 * If FromRecord and ToRecord are not supplied, the lock will be for the entire file. If FromRecord is specified but not ToRecord, the single record will be locked/unlocked.
 * <P>
 * If the file has been opened for sequential input or output, Lock and Unlock affect the entire file, regardless of the range specified by >FromRecord and ToRecord.
 *
 * @param FileNumber  Required. Any valid file number.
 * @param FromRecord  Optional. Number of the first record or byte to lock or unlock.
 * @param ToRecord    Optional. Number of the last record or byte to lock or unlock.
 *
 * @exception IOException   FileNumber does not exist.
 * @exception IOException   File mode is invalid.
 *
 * @example
 * This example illustrates the use of the Lock and Unlock functions. This example assumes that people.txt is a file containing records of the structure Person.
 *
 * <PRE>
 * Structure Person
 *   Dim Name As String
 *   Dim ID As Integer
 * End Structure
 *
 * Sub PutInLockedFile(ByVal index As Integer, ByVal onePerson As Person)
 *   Try
 *     FileOpen(1, "c:\people.txt", OpenMode.Binary)
 *     Lock(1)
 *     FilePut(index, onePerson)
 *     Unlock(1)
 *     FileClose(1)
 *   Catch
 *     ' Error recovery code here.
 *   End Try
 * End Sub
 * </PRE>
 *
 * @see FileOpen FileOpen Function
 */
procedure Lock(ByVal FileNumber As Integer);

/**
 * Controls access by other processes to all or part of a file opened using the Open function.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The Lock and Unlock functions are used in environments where several processes might need access to the same file.
 * <P>
 * Lock and Unlock functions are always used in pairs. The arguments to Lock and Unlock must match exactly.
 * <P>
 * If FromRecord and ToRecord are not supplied, the lock will be for the entire file. If FromRecord is specified but not ToRecord, the single record will be locked/unlocked.
 * <P>
 * If the file has been opened for sequential input or output, Lock and Unlock affect the entire file, regardless of the range specified by >FromRecord and ToRecord.
 *
 * @param FileNumber  Required. Any valid file number.
 * @param FromRecord  Optional. Number of the first record or byte to lock or unlock.
 * @param ToRecord    Optional. Number of the last record or byte to lock or unlock.
 *
 * @exception IOException   FileNumber does not exist.
 * @exception IOException   File mode is invalid.
 *
 * @example
 * This example illustrates the use of the Lock and Unlock functions. This example assumes that people.txt is a file containing records of the structure Person.
 *
 * <PRE>
 * Structure Person
 *   Dim Name As String
 *   Dim ID As Integer
 * End Structure
 *
 * Sub PutInLockedFile(ByVal index As Integer, ByVal onePerson As Person)
 *   Try
 *     FileOpen(1, "c:\people.txt", OpenMode.Binary)
 *     Lock(1)
 *     FilePut(index, onePerson)
 *     Unlock(1)
 *     FileClose(1)
 *   Catch
 *     ' Error recovery code here.
 *   End Try
 * End Sub
 * </PRE>
 *
 * @see FileOpen FileOpen Function
 */
procedure Unlock(ByVal FileNumber As Integer);

/**
 * Controls access by other processes to all or part of a file opened using the Open function.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The Lock and Unlock functions are used in environments where several processes might need access to the same file.
 * <P>
 * Lock and Unlock functions are always used in pairs. The arguments to Lock and Unlock must match exactly.
 * <P>
 * If FromRecord and ToRecord are not supplied, the lock will be for the entire file. If FromRecord is specified but not ToRecord, the single record will be locked/unlocked.
 * <P>
 * If the file has been opened for sequential input or output, Lock and Unlock affect the entire file, regardless of the range specified by >FromRecord and ToRecord.
 *
 * @param FileNumber  Required. Any valid file number.
 * @param FromRecord  Optional. Number of the first record or byte to lock or unlock.
 * @param ToRecord    Optional. Number of the last record or byte to lock or unlock.
 *
 * @exception IOException   FileNumber does not exist.
 * @exception IOException   File mode is invalid.
 *
 * @example
 * This example illustrates the use of the Lock and Unlock functions. This example assumes that people.txt is a file containing records of the structure Person.
 *
 * <PRE>
 * Structure Person
 *   Dim Name As String
 *   Dim ID As Integer
 * End Structure
 *
 * Sub PutInLockedFile(ByVal index As Integer, ByVal onePerson As Person)
 *   Try
 *     FileOpen(1, "c:\people.txt", OpenMode.Binary)
 *     Lock(1)
 *     FilePut(index, onePerson)
 *     Unlock(1)
 *     FileClose(1)
 *   Catch
 *     ' Error recovery code here.
 *   End Try
 * End Sub
 * </PRE>
 *
 * @see FileOpen FileOpen Function
 */
procedure Lock(
   ByVal FileNumber As Integer,
   ByVal FromRecord As Long
);


/**
 * Controls access by other processes to all or part of a file opened using the Open function.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The Lock and Unlock functions are used in environments where several processes might need access to the same file.
 * <P>
 * Lock and Unlock functions are always used in pairs. The arguments to Lock and Unlock must match exactly.
 * <P>
 * If FromRecord and ToRecord are not supplied, the lock will be for the entire file. If FromRecord is specified but not ToRecord, the single record will be locked/unlocked.
 * <P>
 * If the file has been opened for sequential input or output, Lock and Unlock affect the entire file, regardless of the range specified by >FromRecord and ToRecord.
 *
 * @param FileNumber  Required. Any valid file number.
 * @param FromRecord  Optional. Number of the first record or byte to lock or unlock.
 * @param ToRecord    Optional. Number of the last record or byte to lock or unlock.
 *
 * @exception IOException   FileNumber does not exist.
 * @exception IOException   File mode is invalid.
 *
 * @example
 * This example illustrates the use of the Lock and Unlock functions. This example assumes that people.txt is a file containing records of the structure Person.
 *
 * @example
 * This example illustrates the use of the Lock and Unlock functions. This example assumes that people.txt is a file containing records of the structure Person.
 *
 * <PRE>
 * Structure Person
 *   Dim Name As String
 *   Dim ID As Integer
 * End Structure
 *
 * Sub PutInLockedFile(ByVal index As Integer, ByVal onePerson As Person)
 *   Try
 *     FileOpen(1, "c:\people.txt", OpenMode.Binary)
 *     Lock(1)
 *     FilePut(index, onePerson)
 *     Unlock(1)
 *     FileClose(1)
 *   Catch
 *     ' Error recovery code here.
 *   End Try
 * End Sub
 * </PRE>
 *
 * @see FileOpen FileOpen Function
 */
procedure Unlock(
   ByVal FileNumber As Integer,
   ByVal FromRecord As Long
);

/**
 * Controls access by other processes to all or part of a file opened using the Open function.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The Lock and Unlock functions are used in environments where several processes might need access to the same file.
 * <P>
 * Lock and Unlock functions are always used in pairs. The arguments to Lock and Unlock must match exactly.
 * <P>
 * If FromRecord and ToRecord are not supplied, the lock will be for the entire file. If FromRecord is specified but not ToRecord, the single record will be locked/unlocked.
 * <P>
 * If the file has been opened for sequential input or output, Lock and Unlock affect the entire file, regardless of the range specified by >FromRecord and ToRecord.
 *
 * @param FileNumber  Required. Any valid file number.
 * @param FromRecord  Optional. Number of the first record or byte to lock or unlock.
 * @param ToRecord    Optional. Number of the last record or byte to lock or unlock.
 *
 * @exception IOException   FileNumber does not exist.
 * @exception IOException   File mode is invalid.
 *
 * @example
 * This example illustrates the use of the Lock and Unlock functions. This example assumes that people.txt is a file containing records of the structure Person.
 *
 * @example
 * This example illustrates the use of the Lock and Unlock functions. This example assumes that people.txt is a file containing records of the structure Person.
 *
 * <PRE>
 * Structure Person
 *   Dim Name As String
 *   Dim ID As Integer
 * End Structure
 *
 * Sub PutInLockedFile(ByVal index As Integer, ByVal onePerson As Person)
 *   Try
 *     FileOpen(1, "c:\people.txt", OpenMode.Binary)
 *     Lock(1)
 *     FilePut(index, onePerson)
 *     Unlock(1)
 *     FileClose(1)
 *   Catch
 *     ' Error recovery code here.
 *   End Try
 * End Sub
 * </PRE>
 *
 * @see FileOpen FileOpen Function
 */
procedure Lock(
   ByVal FileNumber As Integer,
   ByVal FromRecord As Long,
   ByVal ToRecord As Long
);


/**
 * Controls access by other processes to all or part of a file opened using the Open function.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The Lock and Unlock functions are used in environments where several processes might need access to the same file.
 * <P>
 * Lock and Unlock functions are always used in pairs. The arguments to Lock and Unlock must match exactly.
 * <P>
 * If FromRecord and ToRecord are not supplied, the lock will be for the entire file. If FromRecord is specified but not ToRecord, the single record will be locked/unlocked.
 * <P>
 * If the file has been opened for sequential input or output, Lock and Unlock affect the entire file, regardless of the range specified by >FromRecord and ToRecord.
 *
 * @param FileNumber  Required. Any valid file number.
 * @param FromRecord  Optional. Number of the first record or byte to lock or unlock.
 * @param ToRecord    Optional. Number of the last record or byte to lock or unlock.
 *
 * @exception IOException   FileNumber does not exist.
 * @exception IOException   File mode is invalid.
 *
 * @example
 * This example illustrates the use of the Lock and Unlock functions. This example assumes that people.txt is a file containing records of the structure Person.
 *
 * <PRE>
 * Structure Person
 *   Dim Name As String
 *   Dim ID As Integer
 * End Structure
 *
 * Sub PutInLockedFile(ByVal index As Integer, ByVal onePerson As Person)
 *   Try
 *     FileOpen(1, "c:\people.txt", OpenMode.Binary)
 *     Lock(1)
 *     FilePut(index, onePerson)
 *     Unlock(1)
 *     FileClose(1)
 *   Catch
 *     ' Error recovery code here.
 *   End Try
 * End Sub
 * </PRE>
 *
 * @see FileOpen FileOpen Function
 */
procedure Unlock(
   ByVal FileNumber As Integer,
   ByVal FromRecord As Long,
   ByVal ToRecord As Long
);

/**
 * Returns a Long representing the size, in bytes, of a file opened using the FileOpen function.
 *
 * <b>Remarks</b>
 * <P>
 * Use the FileLen function to obtain the length of a file that is not open.
 *
 * @param FileNumber   Required. An Integer containing a valid file number.
 *
 * @exception IOException   FileNumber does not exist.
 * @exception IOException   File mode is invalid.
 *
 * @example
 * This example uses the LOF function to determine the size of an open file. This example assumes that TESTFILE is a text file containing sample data.
 *
 * <PRE>
 * Dim length As Integer
 * FileOpen(1, "C:\TESTFILE.TXT", OpenMode.Input) ' Open file.
 * length = LOF(1)   ' Get length of file.
 * Debug.WriteLine(length)
 * FileClose(1)   ' Close file.
 * </PRE>
 *
 * @see EOF EOF Function
 * @see FileLen FileLen Function
 * @see Loc Loc Function
 * @see FileOpen FileOpen Function
 */
function Long LOF(ByVal FileNumber As Integer);


/**
 * Returns the natural (base e) logarithm of a specified number.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * Parameter d is specified as a base 10 number.
 *
 * <P>
 * @param d  A number whose logarithm is to be found.
 *
 * @return
 *
 * <DL>
 * <DT>Sign of d<DD>Returns
 * <DT>Positive<DD>The natural logarithm of d; that is, ln d, or loge d
 * <DT>Zero<DD>PositiveInfinity
 * <DT>Negative<DD>NaN
 * </DL>
 *
 * @see E E Function
 * @see Exp Exp Function
 *
 */
function Double Log(ByVal d As Double);

/**
 * Returns the logarithm of a specified number in a specified base.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * Parameters a and newBase are specified as base 10 numbers.
 *
 * @param a        A number whose logarithm is to be found.
 * @param newBase  The base of the logarithm.
 *
 * @return
 * <PRE>
 * Sign of a    Returns
 * Positive     The logarithm of a, in base, newBase; that is, lognewBase a.
 * Zero         PositiveInfinity
 * Negative     NaN
 * </PRE>
 * <P>
 * If a is equal to PositiveInfinity and newBase is not equal to PositiveInfinity, NegativeInfinity, or NaN, this method returns PositiveInfinity. If newBase is equal to PositiveInfinity and a is not equal to PositiveInfinity, NegativeInfinity, or NaN, this method returns 0. If both a and newBase are equal to PositiveInfinity, or a or newBase is equal to NaN or NegativeInfinity, this method returns NaN.
 *
 * @see E E Function
 * @see Exp Exp Function
 */
function Double Log(
   ByVal a As Double,
   ByVal newBase As Double
);

/**
 * Returns a left-aligned string containing the specified string adjusted to the specified length.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If the specified string is longer than the specified length, the returned string is shortened to the specified length. If the specified string is shorter than the specified length, spaces are added to the right end of the returned string to produce the appropriate length.
 *
 * @param Source Required. String expression. Name of string variable.
 * @param Length Required. Integer expression. Length of returned string.
 *
 * @example
 * <P>
 * This example demonstrates the use of the LSet function.
 * <P>
 *
 * <pre>
 * Dim myString As String = "Left"
 * Dim lString As String
 * LString = LSet(myString, 10)   ' Returns "Left      "
 * </pre>
 *
 * @see RSet RSet Function

 */
function String LSet(
   ByVal Source As String,
   ByVal Length As Integer
);

/**
 * Returns a string containing a copy of a specified string with no leading spaces (LTrim), no trailing spaces (RTrim), or no leading or trailing spaces (Trim).
 *
 * @param Str Required. Any valid String expression.
 *
 * @example
 * This example uses the LTrim function to strip leading spaces and the RTrim function to strip trailing spaces from a string variable. It uses the Trim function to strip both types of spaces.
 * <P>
 *
 * <pre>
 * Dim MyString, TrimString As String
 * MyString = "  <-Trim->  "   ' Initializes string.
 * TrimString = LTrim(MyString)   ' TrimString = "<-Trim->  ".
 * TrimString = RTrim(MyString)   ' TrimString = "  <-Trim->".
 * TrimString = LTrim(RTrim(MyString))   ' TrimString = "<-Trim->".
 * ' Using the Trim function alone achieves the same result.
 * TrimString = Trim(MyString)   ' TrimString = "<-Trim->".
 * </pre>
 *
 * @see Left Left Function
 * @see Right Right Function
 */
function String LTrim(ByVal Str As String);

/**
 * Returns a string containing a copy of a specified string with no leading spaces (LTrim), no trailing spaces (RTrim), or no leading or trailing spaces (Trim).
 *
 * @param Str Required. Any valid String expression.
 *
 * @example
 * This example uses the LTrim function to strip leading spaces and the RTrim function to strip trailing spaces from a string variable. It uses the Trim function to strip both types of spaces.
 * <P>
 *
 * <pre>
 * Dim MyString, TrimString As String
 * MyString = "  <-Trim->  "   ' Initializes string.
 * TrimString = LTrim(MyString)   ' TrimString = "<-Trim->  ".
 * TrimString = RTrim(MyString)   ' TrimString = "  <-Trim->".
 * TrimString = LTrim(RTrim(MyString))   ' TrimString = "<-Trim->".
 * ' Using the Trim function alone achieves the same result.
 * TrimString = Trim(MyString)   ' TrimString = "<-Trim->".
 * </pre>
 *
 * @see Left Left Function
 * @see Right Right Function
 */
function String RTrim(ByVal Str As String);

/**
 * Returns a string containing a copy of a specified string with no leading spaces (LTrim), no trailing spaces (RTrim), or no leading or trailing spaces (Trim).
 *
 * @param Str Required. Any valid String expression.
 *
 * @example
 * This example uses the LTrim function to strip leading spaces and the RTrim function to strip trailing spaces from a string variable. It uses the Trim function to strip both types of spaces.
 * <P>
 *
 * <pre>
 * Dim MyString, TrimString As String
 * MyString = "  <-Trim->  "   ' Initializes string.
 * TrimString = LTrim(MyString)   ' TrimString = "<-Trim->  ".
 * TrimString = RTrim(MyString)   ' TrimString = "  <-Trim->".
 * TrimString = LTrim(RTrim(MyString))   ' TrimString = "<-Trim->".
 * ' Using the Trim function alone achieves the same result.
 * TrimString = Trim(MyString)   ' TrimString = "<-Trim->".
 * </pre>
 *
 * @see Left Left Function
 * @see Right Right Function
 */
function String Trim(ByVal Str As String);

/**
 * Returns a string containing a specified number of characters from a string.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * To determine the number of characters in Str, use the Len function.
 *
 * @param Str    Required. String expression from which characters are returned.
 * @param Start  Required. Integer expression. Character position in Str at which the part to be taken starts. If Start is greater than the number of characters in Str, the Mid function returns a zero-length string (""). Start is one based.
 * @param Length Optional. Integer expression. Number of characters to return. If omitted or if there are fewer than Length characters in the text (including the character at position Start), all characters from the start position to the end of the string are returned.
 *
 * @exception ArgumentException   Start <= 0 or Length < 0.
 *
 * @example
 * This example uses the Mid function to return a specified number of characters from a string.
 *
 * <P>
 * <pre>
 * Dim MyString, FirstWord, LastWord, MidWords As String
 * MyString = "Mid Function Demo"   ' Creates text string.
 * FirstWord = Mid(MyString, 1, 3)   ' Returns "Mid".
 * LastWord = Mid(MyString, 14, 4)   ' Returns "Demo".
 * MidWords = Mid(MyString, 5)   ' Returns "Function Demo".
 * </pre>
 *
 * @see Left Left Function
 * @see Len Len Function
 * @see LTrim LTrim Function
 * @see RTrim RTrim Function
 * @see Trim Trim Function
 * @see Right Right Function
 */
function String Mid(
   ByVal Str As String,
   ByVal Start As Integer,
   Optional ByVal Length As Integer
);

/**
 * Returns an Integer value from 0 through 59 representing the minute of the hour.
 *
 * @param TimeValue Required. Date value from which you want to extract the minute.
 * <P>
 * You can also obtain the minute of the hour by calling DatePart and specifying DateInterval.Minute for the Interval argument.
 *
 * @example
 * <P>
 * This example uses the Minute function to obtain the minute of the hour from a specified time. In the development environment, the time literal is displayed in short time format using the locale settings of your code.
 *
 * <pre>
 * Dim MyTime As Date
 * Dim MyMinute As Integer
 * MyTime = #4:35:17 PM#   ' Assign a time.
 * MyMinute = Minute(MyTime)   ' MyMinute contains 35.
 * </pre>
 *
 * @see Day Day Function
 * @see Hour Hour Function
 * @see Now Property
 * @see Second Second Function
 * @see DatePart DatePart Function
 */
function Integer Minute(ByVal TimeValue As DateTime);

/**
 * Returns a Double specifying the modified internal rate of return for a series of periodic cash flows (payments and receipts).
 * <P>
 *
 * <b>Remarks</b>
 * <P>
 * The modified internal rate of return is the internal rate of return when payments and receipts are financed at different rates. The MIRR function takes into account both the cost of the investment (FinanceRate) and the interest rate received on reinvestment of cash (ReinvestRate).
 * <P>
 * The FinanceRate and ReinvestRatearguments are percentages expressed as decimal values. For example, 12 percent is expressed as 0.12.
 * <P>
 * The MIRR function uses the order of values within the array to interpret the order of payments and receipts. Be sure to enter your payment and receipt values in the correct sequence.
 *
 * @param ValueArray() Required. Array of Double specifying cash flow values. The array must contain at least one negative value (a payment) and one positive value (a receipt).
 * @param FinanceRate  Required. Double specifying interest rate paid as the cost of financing.
 * @param ReinvestRate Required. Double specifying interest rate received on gains from cash reinvestment.
 *
 * @exception ArgumentException   Rank of ValueArray does not equal 1.
 * @exception ArgumentException   FinanceRate = -1
 * @exception ArgumentException   ReinvestRate = -1
 * @exception DivideByZeroException  Division by zero has occurred.
 *
 * @example
 * This example uses the MIRR function to return the modified internal rate of return for a series of cash flows contained in the array Values(). LoanAPR represents the financing interest, and InvAPR represents the interest rate received on reinvestment.
 *
 * <pre>
 * Sub TestMIRR()
 *   Dim LoanAPR, InvAPR, RetRate, Values(4) As Double
 *   Dim Msg, Fmt As String
 *   LoanAPR = 0.1  ' Loan rate.
 *   InvAPR = 0.12  ' Reinvestment rate.
 *   Fmt = "#0.00"   ' Define money format.
 *   Values(0) = -70000   ' Business start-up costs.
 *   ' Positive cash flows reflecting income for four successive years.
 *   Values(1) = 22000 : Values(2) = 25000
 *   Values(3) = 28000 : Values(4) = 31000
 *   RetRate = MIRR(Values, LoanAPR, InvAPR)   ' Calculate internal rate.
 *   Msg = "The modified internal rate of return for these five cash flows is "
 *   Msg = Msg & Format(Math.Abs(RetRate) * 100, CStr(Fmt)) & "%."
 *   MsgBox(Msg)    ' Display internal return rate.
 * End Sub
 * </pre>
 *
 * @see DDB DDB Function
 * @see IRR IRR Function
 * @see MIRR MIRR Function
 * @see NPer NPer Function
 * @see NPV NPV Function
 * @see Pmt Pmt Function
 * @see PPmt PPmt Function
 * @see PV PV Function
 * @see Rate Rate Function
 * @see SLN SLN Function
 * @see SYD SYD Function
 */
function Double MIRR(
   ByRef ValueArray() As Double,
   ByVal FinanceRate As Double,
   ByVal ReinvestRate As Double
);

/**
 * Creates a new directory or folder.
 *
 * @param Path  Required. String expression that identifies the directory or folder to be created. The Path may include the drive. If no drive is specified, MkDir creates the new directory or folder on the current drive.
 *
 * @exception ArgumentException   Path is not specified or is empty.
 * @exception IOException   Directory already exists.
 *
 * @example
 * This example uses the MkDir function to create a directory or folder. If the drive is not specified, the new directory or folder is created on the current drive.
 *
 * <pre>
 * MkDir("C:\MYDIR")   ' Make new directory or folder.
 * </pre>
 *
 * @see ChDir ChDir Function
 * @see CurDir CurDir Function
 * @see RmDir RmDir Function
 */
procedure MkDir(ByVal Path As String);


/**
 * Returns an Integer value from 1 through 12 representing the month of the year.
 *
 * @param DateValue  Required. Date value from which you want to extract the month.
 * <P>
 * You can also obtain the month of the year by calling DatePart and specifying DateInterval.Month for the Interval argument.
 *
 * @example
 * This example uses the Month function to obtain the month from a specified date. In the development environment, the date literal is displayed in short date format using the locale settings of your code.
 *
 * <pre>
 * Dim MyDate As Date
 * Dim MyMonth As Integer
 * MyDate = #2/12/1969#   ' Assign a date.
 * MyMonth = Month(MyDate)   ' MyMonth contains 2.
 * </pre>
 *
 * @see Day Day Function
 * @see Weekday Weekday Function
 * @see Year Year Function
 * @see DatePart DatePart Function
 */
function Integer Month(ByVal DateValue As DateTime);

/**
 * Returns a String value containing the name of the specified month.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The string returned by MonthName depends not only on the input arguments, but also on the Regional Options settings specified in the Windows Control Panel.
 * <P>
 * If Month is less than 1 or more than 13, an ArgumentException error occurs.
 * <P>
 * Note   MonthName uses the current calendar setting from the CurrentCulture property of the CultureInfo class in the System.Globalization namespace. The default CurrentCulture values are determined by Control Panel settings.
 *
 * @param Month Required. Integer. The numeric designation of the month, >from 1 through 13; 1 indicates January and 12 indicates December. You can use the value 13 with a 13-month calendar. If your system is using a 12-month calendar and Month is 13, MonthName returns an empty string.
 * @param Abbreviate Optional. Boolean value that indicates if the month name is to be abbreviated. If omitted, the default is False, which means the month name is not abbreviated.
 *
 * @exception ArgumentException   Month is less than 1 or greater than 13.
 *
 * @example
 * This example uses the MonthName function to determine the name of the month, by the integer given. The Boolean value will determine whether the full name (False) or the abbreviated name (True) will be displayed.
 *
 * <pre>
 * Dim MyMonth As Integer
 * Dim Name As String
 * MyMonth = 4
 * Name = MonthName(MyMonth, True)   ' "True" returns an abbreviated name.
 * Msgbox(Name)   ' Name contains "Apr".
 * </pre>
 *
 * @see WeekdayName WeekdayName Function
 */
function String MonthName(
   ByVal Month As Integer,
   Optional ByVal Abbreviate As Boolean = False
);

/**
 * Displays a message in a dialog box, waits for the user to click a button, and then returns an integer indicating which button the user clicked.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If the dialog box displays a Cancel button, pressing the ESC key has the same effect as clicking Cancel. If the dialog box contains a Help button, context-sensitive Help is provided for the dialog box. However, no value is returned until one of the other buttons is clicked.
 * <P>
 * Note   To specify more than the first argument, you must use the MsgBox function in an expression. If you omit any positional arguments, you must retain the corresponding comma delimiter.
 *
 * <pre>
 * <b>Settings</b>
 *
 * The MsgBoxStyle enumeration values are listed in the following table.
 *
 * Enumeration          Value        Description
 * OKOnly                 0          Displays OK button only.
 * OKCancel               1          Displays OK and Cancel buttons.
 * AbortRetryIgnore       2          Displays Abort, Retry, and Ignore buttons.
 * YesNoCancel            3          Displays Yes, No, and Cancel buttons.
 * YesNo                  4          Displays Yes and No buttons.
 * RetryCancel            5          Displays Retry and Cancel buttons.
 * Critical               16         Displays Critical Message icon.
 * Question               32         Displays Warning Query icon.
 * Exclamation            48         Displays Warning Message icon.
 * Information            64         Displays Information Message icon.
 * DefaultButton1         0          First button is default.
 * DefaultButton2        256         Second button is default.
 * DefaultButton3        512         Third button is default.
 * ApplicationModal       0          Application is modal. The user must respond to the message box before continuing work in the current application.
 * SystemModal           4096        System is modal. All applications are suspended until the user responds to the message box.
 * MsgBoxSetForeground  65536        Specifies the message box window as the foreground window.
 * MsgBoxRight          524288       Text is right-aligned.
 * MsgBoxRtlReading    1048576       Specifies text should appear as right-to-left reading on Hebrew and Arabic systems.
 *
 * The first group of values (05) describes the number and type of buttons displayed in the dialog box; the second group (16, 32, 48, 64) describes the icon style; the third group (0, 256, 512) determines which button is the default; the fourth group (0, 4096) determines the modality of the message box, and the fifth group specifies whether or not the message box window is the foreground window, along with the alignment and direction of the text. When adding numbers to create a final value for the Buttons argument, use only one number from each group.
 * </pre>
 *
 * @param Prompt Required. String expression displayed as the message in the dialog box. The maximum length of Prompt is approximately 1024 characters, depending on the width of the characters used. If Prompt consists of more than one line, you can separate the lines using a carriage return character (Chr(13)), a linefeed character (Chr(10)), or a carriage return/linefeed character combination (Chr(13) & Chr(10)) between each line.
 * @param Buttons Optional. Numeric expression that is the sum of values specifying the number and type of buttons to display, the icon style to use, the identity of the default button, and the modality of the message box. If you omit Buttons, the default value is zero.
 * @param Title Optional. String expression displayed in the title bar of the dialog box. If you omit Title, the application name is placed in the title bar.
 *
 * @return
 *
 * <pre>
 * Constant   Value
 * OK         1
 * Cancel     2
 * Abort      3
 * Retry      4
 * Ignore     5
 * Yes        6
 * No         7
 * </pre>
 *
 * @exception ArgumentException   Prompt is not a String expression, or Title is invalid.
 * @exception InvalidOperationException   Process is not running in User Interactive mode.
 * @exception InvalidEnumArgumentException   One or more parameters not a member of MsgBoxResult or MsgBoxStyle enumerations.
 *
 * @example
 * This example uses the MsgBox function to display a critical-error message in a dialog box with Yes and No buttons. The No button is specified as the default response. This is done by combining the MsgBox constant values into one numeric expression. In this case, adding 4 (the Yes/No button combination) and 16 (the Critical Message window) and 256 (the second button as default button) gives a total of 276. The value returned by the MsgBox function depends on the button chosen by the user: Yes returns a value of 6; No returns a value of 7.
 *
 * <pre>
 * Dim msg As String
 * Dim title As String
 * Dim style As MsgBoxStyle
 * Dim response As MsgBoxResult
 * msg = "Do you want to continue?"   ' Define message.
 * style = MsgBoxStyle.DefaultButton2 Or _
 *   MsgBoxStyle.Critical Or MsgBoxStyle.YesNo
 * title = "MsgBox Demonstration"   ' Define title.
 * ' Display message.
 * response = MsgBox(msg, style, title)
 * If response = MsgBoxResult.Yes Then   ' User chose Yes.
 *   ' Perform some action.
 * Else
 *   ' Perform some other action.
 * End If
 * </pre>
 *
 * @see InputBox InputBox Function
 *
 */
function MsgBoxResult MsgBox(
   ByVal Prompt As Object,
   Optional ByVal Buttons As MsgBoxStyle = MsgBoxStyle.OKOnly,
   Optional ByVal Title As Object = Nothing
);

/**
 * Returns a Double specifying the number of periods for an annuity based on periodic, fixed payments and a fixed interest rate.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * An annuity is a series of fixed cash payments made over a period of time. An annuity can be a loan (such as a home mortgage) or an investment (such as a monthly savings plan).
 * <P>
 * For all arguments, cash paid out (such as deposits to savings) is represented by negative numbers; cash received (such as dividend checks) is represented by positive numbers.
 *
 * @param Rate Required. Double specifying interest rate per period. For example, if you get a car loan at an annual percentage rate (APR) of 10 percent and make monthly payments, the rate per period is 0.1/12, or 0.0083.
 * @param Pmt  Required. Double specifying payment to be made each period. Payments usually contain principal and interest that doesn't change over the life of the annuity.
 * @param PV   Required. Double specifying present value, or value today, of a series of future payments or receipts. For example, when you borrow money to buy a car, the loan amount is the present value to the lender of the monthly car payments you will make.
 * @param FV   Optional. Double specifying future value or cash balance you want after you've made the final payment. For example, the future value of a loan is $0 because that's its value after the final payment. However, if you want to save $50,000 over 18 years for your child's education, then $50,000 is the future value. If omitted, 0 is assumed.
 * @param Due  Optional. Object of type Microsoft.VisualBasic.DueDate that specifies when payments are due. This argument must be either DueDate.EndOfPeriod if payments are due at the end of the payment period, or DueDate.BegOfPeriod if payments are due at the beginning of the period. If omitted, DueDate.EndOfPeriod is assumed.
 *
 * @exception ArgumentException   Rate <= -1.
 * @exception ArgumentException   Rate = 0 and Pmt = 0
 *
 * @example
 * This example uses the NPer function to return the number of periods during which payments must be made to pay off a loan whose value is contained in PVal. Also provided are the interest percentage rate per period (APR / 12), the payment (Payment), the future value of the loan (FVal), and a number that indicates whether the payment is due at the beginning or end of the payment period (PayType).
 *
 * <pre>
 * Sub TestNPer()
 *   Dim FVal, TotPmts As Double
 *   Dim PVal, APR, Payment As Double
 *   Dim PayType As DueDate
 *   Dim Response As MsgBoxResult
 *   FVal = 0   ' Usually 0 for a loan.
 *   PVal = CDbl(InputBox("How much do you want to borrow?"))
 *   APR = CDbl(InputBox("What is the annual percentage rate of your loan?"))
 *   If APR > 1 Then APR = APR / 100 ' Ensure proper form.
 *   Payment = CDbl(InputBox("How much do you want to pay each month?"))
 *   Response = MsgBox("Do you make payments at the end of month?", MsgBoxStyle.YesNo)
 *   If Response = MsgBoxResult.No Then
 *     PayType = DueDate.BegOfPeriod
 *   Else
 *     PayType = DueDate.EndOfPeriod
 *   End If
 *   TotPmts = NPer(APR / 12, -Payment, PVal, FVal, PayType)
 *   If Int(TotPmts) <> TotPmts Then TotPmts = Int(TotPmts) + 1
 *     MsgBox("It will take you " & TotPmts & " months to pay off your loan.")
 * End Sub
 * </pre>
 *
 * @see DDB DDB Function
 * @see IRR IRR Function
 * @see MIRR MIRR Function
 * @see NPer NPer Function
 * @see NPV NPV Function
 * @see Pmt Pmt Function
 * @see PPmt PPmt Function
 * @see PV PV Function
 * @see Rate Rate Function
 * @see SLN SLN Function
 * @see SYD SYD Function
 */
function Double NPer( _
    ByVal Rate As Double,
   ByVal Pmt As Double,
   ByVal PV As Double,
   Optional ByVal FV As Double = 0,
   Optional ByVal Due As DueDate = DueDate.EndOfPeriod
);

/**
 * Returns a Double specifying the net present value of an investment based on a series of periodic cash flows (payments and receipts) and a discount rate.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The net present value of an investment is the current value of a future series of payments and receipts.
 * <P>
 * The NPV function uses the order of values within the array to interpret the order of payments and receipts. Be sure to enter your payment and receipt values in the correct sequence.
 * <P>
 * The NPV investment begins one period before the date of the first cash flow value and ends with the last cash flow value in the array.
 * <P>
 * The net present value calculation is based on future cash flows. If your first cash flow occurs at the beginning of the first period, the first value must be added to the value returned by NPV and must not be included in the cash flow values of ValueArray().
 * <P>
 * The NPV function is similar to the PV function (present value) except that the PV function allows cash flows to begin either at the end or the beginning of a period. Unlike the variable NPV cash flow values, PV cash flows must be fixed throughout the investment.
 *
 * @param Rate   Required. Double specifying discount rate over the length of the period, expressed as a decimal.
 * @param ValueArray()   Required. Array of Double specifying cash flow values. The array must contain at least one negative value (a payment) and one positive value (a receipt).
 *
 * @exception ArgumentException   ValueArray is Nothing, rank of ValueArray <> 1, or Rate = -1
 *
 * @example
 * This example uses the NPV function to return the net present value for a series of cash flows contained in the array Values(). RetRate represents the fixed internal rate of return.
 *
 * <pre>
 * Sub TestNPV()
 *   Dim Guess, RetRate, NetPVal, values(4) As Double
 *   Dim Fmt, Msg As String
 *   Fmt = "###,##0.00"   ' Define money format.
 *   Guess = 0.1  ' Guess starts at 10 percent.
 *   RetRate = 0.0625  ' Set fixed internal rate.
 *   values(0) = -70000   ' Business start-up costs.
 *   ' Positive cash flows reflecting income for four successive years.
 *   values(1) = 22000 : values(2) = 25000
 *   values(3) = 28000 : values(4) = 31000
 *   NetPVal = NPV(RetRate, values)   ' Calculate net present value.
 *   Msg = "The net present value of these cash flows is "
 *   Msg = Msg & Format(NetPVal, Fmt) & "."
 *   MsgBox(Msg)    ' Display net present value.
 * End Sub
 * </pre>
 *
 * @see DDB DDB Function
 * @see IRR IRR Function
 * @see MIRR MIRR Function
 * @see NPer NPer Function
 * @see Pmt Pmt Function
 * @see PPmt PPmt Function
 * @see PV PV Function
 * @see Rate Rate Function
 * @see SLN SLN Function
 * @see SYD SYD Function
 */
function Double NPV(
   ByVal Rate As Double,
   ByRef ValueArray() As Double
);

/**
 * Returns a string representing the octal value of a number.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If Number is not already a whole number, it is rounded to the nearest whole number before being evaluated.
 *
 * <Pre>
 * If Number is       Oct returns
 * Empty              Zero (0)
 * Any other number   Up to 22 octal characters
 *
 * You can represent octal numbers directly by preceding numbers in the proper range with &O. For example, &O10 is the octal notation for decimal 8.
 * </pre>
 *
 * @example
 * This example uses the Oct function to return the octal value of a number.
 *
 * <pre>
 * Dim MyOct As String
 * MyOct = Oct(4)    ' Returns 4.
 * MyOct = Oct(8)   ' Returns 10.
 * MyOct = Oct(459)   ' Returns 713.
 * </pre>
 *
 * @see Hex Hex Function
 */
function String Oct(
   ByVal Number As Byte
);

/**
 * Returns a string representing the octal value of a number.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If Number is not already a whole number, it is rounded to the nearest whole number before being evaluated.
 *
 * <Pre>
 * If Number is       Oct returns
 * Empty              Zero (0)
 * Any other number   Up to 22 octal characters
 *
 * You can represent octal numbers directly by preceding numbers in the proper range with &O. For example, &O10 is the octal notation for decimal 8.
 * </pre>
 *
 * @example
 * This example uses the Oct function to return the octal value of a number.
 *
 * <pre>
 * Dim MyOct As String
 * MyOct = Oct(4)    ' Returns 4.
 * MyOct = Oct(8)   ' Returns 10.
 * MyOct = Oct(459)   ' Returns 713.
 * </pre>
 *
 */
function String Oct(
   ByVal Number As Short
);

/**
 * Returns a string representing the octal value of a number.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If Number is not already a whole number, it is rounded to the nearest whole number before being evaluated.
 *
 * <Pre>
 * If Number is       Oct returns
 * Empty              Zero (0)
 * Any other number   Up to 22 octal characters
 *
 * You can represent octal numbers directly by preceding numbers in the proper range with &O. For example, &O10 is the octal notation for decimal 8.
 * </pre>
 *
 * @example
 * This example uses the Oct function to return the octal value of a number.
 *
 * <pre>
 * Dim MyOct As String
 * MyOct = Oct(4)    ' Returns 4.
 * MyOct = Oct(8)   ' Returns 10.
 * MyOct = Oct(459)   ' Returns 713.
 * </pre>
 *
 * @see Hex Hex Function
 */
function String Oct(
   ByVal Number As Integer
);

/**
 * Returns a string representing the octal value of a number.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If Number is not already a whole number, it is rounded to the nearest whole number before being evaluated.
 *
 * <Pre>
 * If Number is       Oct returns
 * Empty              Zero (0)
 * Any other number   Up to 22 octal characters
 *
 * You can represent octal numbers directly by preceding numbers in the proper range with &O. For example, &O10 is the octal notation for decimal 8.
 * </pre>
 *
 * @example
 * This example uses the Oct function to return the octal value of a number.
 *
 * <pre>
 * Dim MyOct As String
 * MyOct = Oct(4)    ' Returns 4.
 * MyOct = Oct(8)   ' Returns 10.
 * MyOct = Oct(459)   ' Returns 713.
 * </pre>
 *
 * @see Hex Hex Function
 */
function String Oct(
   ByVal Number As Long
);

/**
 * Returns a string representing the octal value of a number.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If Number is not already a whole number, it is rounded to the nearest whole number before being evaluated.
 *
 * <Pre>
 * If Number is       Oct returns
 * Empty              Zero (0)
 * Any other number   Up to 22 octal characters
 *
 * You can represent octal numbers directly by preceding numbers in the proper range with &O. For example, &O10 is the octal notation for decimal 8.
 * </pre>
 *
 * @example
 * This example uses the Oct function to return the octal value of a number.
 *
 * <pre>
 * Dim MyOct As String
 * MyOct = Oct(4)    ' Returns 4.
 * MyOct = Oct(8)   ' Returns 10.
 * MyOct = Oct(459)   ' Returns 713.
 * </pre>
 *
 * @see Hex Hex Function
 */
function String Oct(
   ByVal Number As Object
);

/**
 * Returns a string representing the calculated range that contains a number.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The Partition function calculates a set of numeric ranges, each containing the number of values specified by Interval. The first range begins at Start, and the last range ends at Stop. The Partition function then identifies which range contains Number and returns a string describing that range. The range is represented in the string as "lowervalue:uppervalue", where the low end of the range (lowervalue) is separated from the high end (uppervalue) by a colon (:).
 * <P>
 * If necessary, the Partition function inserts leading spaces before lowervalue and uppervalue so that they both have the same number of characters as the string representation of the value (Stop + 1). This ensures that if you use the output of the Partition function with several values of Number, the resulting text will be handled properly during any subsequent sort operation.
 * <P>
 * The following table shows some sample strings for ranges calculated using three sets of Start, Stop, and Interval. The "First range" and "Last range" columns show the lowest and highest ranges possible given the values of Start and Stop. The "Before first range" and "After last range" columns show the strings returned for values of Number less than Start and greater than Stop, respectively.
 * <pre>
 *
 * Start Stop Interval Before first range  First range  Last range  After last range
 * 0      99     5       "   : -1"          " 0: 4"      " 95: 99"   "100:   "
 * 20    199    10       "   : 19"         " 20: 29"     "190:199"   "200:   "
 * 100   1010   20       "    : 99"       " 100: 119"  "1000:1010"   "1011:    "
 *
 * </pre>
 * <P>
 * In the preceding table, the third line shows the result when Start and Stop define a set of numbers that cannot be evenly divided by Interval. The last range ends at Stop, making it only 11 numbers long, even though Interval is 20.
 * <P>
 * If Interval is 1, the range is "Number:Number", regardless of the Start and Stop arguments. For example, if Number is 267, Stop is 1000, and Interval is 1, Partition returns " 267: 267".
 * <P>
 * Partition is useful in database queries. You can create a select query that shows how many orders occur within various value ranges, for example with invoice values from 1 to 1000, 1001 to 2000, and so on.
 *
 * @param Number Required. Long. Whole number that you want to locate within one of the calculated ranges.
 * @param Start  Required. Long. Whole number that indicates the start of the set of calculated ranges. Start cannot be less than 0.
 * @param Stop   Required. Long. Whole number that indicates the end of the set of calculated ranges. Stop cannot be less than or equal to Start.
 * @param Interval    Required. Long. Whole number that indicates the size of each range calculated between Start and Stop. Interval cannot be less than 1.
 *
 * @example
 * This example assumes you have an Orders table that contains a Freight field. It creates a SELECT procedure that counts the number of orders for which freight cost is within each of several ranges. The Partition function first establishes these ranges, and then the SQL Count function counts the number of orders in each range. In this example, the arguments to the Partition function are Start = 0, Stop = 500, Interval = 50. The first range is therefore 0:49, and so on up to 450:499 and 500:500.
 *
 * <pre>
 * SELECT DISTINCTROW Partition([Freight],0, 500, 50) As Range,
 * Count(Orders.Freight) As Count
 * FROM Orders
 * GROUP BY Partition([Freight],0,500,50);
 * </pre>
 */
function String Partition(
   ByVal Number As Long,
   ByVal Start As Long,
   ByVal Stop As Long,
   ByVal Interval As Long
);

/**
 * Returns a Double specifying the payment for an annuity based on periodic, fixed payments and a fixed interest rate.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * An annuity is a series of fixed cash payments made over a period of time. An annuity can be a loan (such as a home mortgage) or an investment (such as a monthly savings plan).
 * <P>
 * The Rate and NPer arguments must be calculated using payment periods expressed in the same units. For example, if Rate is calculated using months, NPer must also be calculated using months.
 * <P>
 * For all arguments, cash paid out (such as deposits to savings) is represented by negative numbers; cash received (such as dividend checks) is represented by positive numbers.
 *
 * @param Rate  Required. Double specifying interest rate per period. For example, if you get a car loan at an annual percentage rate (APR) of 10 percent and make monthly payments, the rate per period is 0.1/12, or 0.0083.
 * @param NPer  Required. Double specifying total number of payment periods in the annuity. For example, if you make monthly payments on a four-year car loan, your loan has a total of 4 * 12 (or 48) payment periods.
 * @param PV    Required. Double specifying present value (or lump sum) that a series of payments to be paid in the future is worth now. For example, when you borrow money to buy a car, the loan amount is the present value to the lender of the monthly car payments you will make.
 * @param FV    Optional. Double specifying future value or cash balance you want after you've made the final payment. For example, the future value of a loan is $0 because that's its value after the final payment. However, if you want to save $50,000 over 18 years for your child's education, then $50,000 is the future value. If omitted, 0 is assumed.
 * @param Due   Optional. Object of type Microsoft.VisualBasic.DueDate that specifies when payments are due. This argument must be either DueDate.EndOfPeriod if payments are due at the end of the payment period, or DueDate.BegOfPeriod if payments are due at the beginning of the period. If omitted, DueDate.EndOfPeriod is assumed.
 *
 * @exception ArgumentException   NPer = 0.
 *
 * @example
 * This example uses the Pmt function to return the monthly payment for a loan over a fixed period. Given are the interest percentage rate per period (APR / 12), the total number of payments (TotPmts), the present value or principal of the loan (PVal), the future value of the loan (FVal), and a number that indicates whether the payment is due at the beginning or end of the payment period (PayType).
 *
 * <pre>
 * Sub TestPMT()
 *   Dim PVal, APR, FVal, Payment, TotPmts As Double
 *   Dim PayType As DueDate
 *   Dim Fmt As String
 *   Dim Response As MsgBoxResult
 *   Fmt = "###,###,##0.00" ' Define money format.
 *   FVal = 0 ' Usually 0 for a loan.
 *   PVal = CDbl(InputBox("How much do you want to borrow?"))
 *   APR = CDbl(InputBox("What is the annual percentage rate of your loan?"))
 *   If APR > 1 Then APR = APR / 100 ' Ensure proper form.
 *     TotPmts = CDbl(InputBox("How many monthly payments will you make?"))
 *     Response = MsgBox("Do you make payments at the end of month?", MsgBoxStyle.YesNo)
 *     If Response = MsgBoxResult.No Then
 *       PayType = DueDate.BegOfPeriod
 *   Else
 *     PayType = DueDate.BegOfPeriod
 *   End If
 *   Payment = Pmt(APR / 12, TotPmts, -PVal, FVal, PayType)
 *   MsgBox("Your payment will be " & Format(Payment, Fmt) & " per month.")
 * End Sub
 * </pre>
 *
 * @see DDB DDB Function
 * @see IRR IRR Function
 * @see MIRR MIRR Function
 * @see NPer NPer Function
 * @see NPV NPV Function
 * @see PPmt PPmt Function
 * @see PV PV Function
 * @see Rate Rate Function
 * @see SLN SLN Function
 * @see SYD SYD Function
 */
function Double Pmt(
   ByVal Rate As Double,
   ByVal NPer As Double,
   ByVal PV As Double,
   Optional ByVal FV As Double = 0,
   Optional ByVal Due As DueDate = DueDate.EndOfPeriod
);

/**
 * Returns a Double specifying the principal payment for a given period of an annuity based on periodic, fixed payments and a fixed interest rate.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * An annuity is a series of fixed cash payments made over a period of time. An annuity can be a loan (such as a home mortgage) or an investment (such as a monthly savings plan).
 * <P>
 * The Rate and NPer arguments must be calculated using payment periods expressed in the same units. For example, if Rate is calculated using months, NPer must also be calculated using months.
 * <P>
 * For all arguments, cash paid out (such as deposits to savings) is represented by negative numbers; cash received (such as dividend checks) is represented by positive numbers.
 *
 * @param Rate  Required. Double specifying interest rate per period. For example, if you get a car loan at an annual percentage rate (APR) of 10 percent and make monthly payments, the rate per period is 0.1/12, or 0.0083.
 * @param Per   Required. Double specifying payment period in the range 1 through NPer.
 * @param NPer  Required. Double specifying total number of payment periods in the annuity. For example, if you make monthly payments on a four-year car loan, your loan has a total of 4 * 12 (or 48) payment periods.
 * @param PV    Required. Double specifying present value, or value today, of a series of future payments or receipts. For example, when you borrow money to buy a car, the loan amount is the present value to the lender of the monthly car payments you will make.
 * @param FV    Optional. Double specifying future value or cash balance you want after you've made the final payment. For example, the future value of a loan is $0 because that's its value after the final payment. However, if you want to save $50,000 over 18 years for your child's education, then $50,000 is the future value. If omitted, 0 is assumed.
 * @param Due   Optional. Object of type Microsoft.VisualBasic.DueDate that specifies when payments are due. This argument must be either DueDate.EndOfPeriod if payments are due at the end of the payment period, or DueDate.BegOfPeriod if payments are due at the beginning of the period. If omitted, DueDate.EndOfPeriod is assumed.
 *
 * @exception ArgumentException   Per value invalid: must be > 1 and < NPer.
 *
 * @example
 * This example uses the PPmt function to calculate how much of a payment for a specific period is principal when all the payments are of equal value. Given are the interest percentage rate per period (APR / 12), the payment period for which the principal portion is desired (Period), the total number of payments (TotPmts), the present value or principal of the loan (PVal), the future value of the loan (FVal), and a number that indicates whether the payment is due at the beginning or end of the payment period (PayType).
 *
 * <pre>
 * Sub TestPPMT()
 *   Dim PVal, APR, TotPmts, MakeChart, FVal, Payment, Period, P, I As Double
 *   Dim PayType As DueDate
 *   Dim Msg, Fmt As String
 *   Dim Response As MsgBoxResult
 *
 *   Fmt = "###,###,##0.00"   ' Define money format.
 *   FVal = 0   ' Usually 0 for a loan.
 *   PVal = CDbl(InputBox("How much do you want to borrow?"))
 *   APR = CDbl(InputBox("What is the annual percentage rate of your loan?"))
 *   If APR > 1 Then APR = APR / 100 ' Ensure proper form.
 *   TotPmts = CDbl(InputBox("How many monthly payments do you have to make?"))
 *   Response = MsgBox("Do you make payments at the end of month?", MsgBoxStyle.YesNo)
 *   If Response = MsgBoxResult.No Then
 *     PayType = DueDate.BegOfPeriod
 *   Else
 *     PayType = DueDate.EndOfPeriod
 *   End If
 *   Payment = Math.Abs(-Pmt(APR / 12, TotPmts, PVal, FVal, PayType))
 *   Msg = "Your monthly payment is " & Format(Payment, Fmt) & ". "
 *   Msg = Msg & "Would you like a breakdown of your principal and "
 *   Msg = Msg & "interest per period?"
 *   MakeChart = MsgBox(Msg, MsgBoxStyle.YesNo)   ' See if chart is desired.
 *   If Response <> MsgBoxResult.No Then
 *     If TotPmts > 12 Then MsgBox("Only first year will be shown.")
 *     Msg = "Month  Payment  Principal  Interest" & vbNewLine
 *     For Period = 1 To TotPmts
 *       If Period > 12 Then Exit For ' Show only first 12.
 *       P = PPmt(APR / 12, Period, TotPmts, -PVal, FVal, PayType)
 *       P = (Int((P + 0.005) * 100) / 100)  ' Round principal.
 *       I = Payment - P
 *       I = (Int((I + 0.005) * 100) / 100)  ' Round interest.
 *       Msg = Msg & Period & vbTab & Format(Payment, Fmt)
 *       Msg = Msg & vbTab & Format(P, Fmt) & vbTab & Format(I, Fmt) & vbNewLine
 *     Next Period
 *     MsgBox(Msg)    ' Display amortization table.
 *   End If
 * End Sub
 * </pre>
 *
 * @see DDB DDB Function
 * @see IRR IRR Function
 * @see MIRR MIRR Function
 * @see NPer NPer Function
 * @see NPV NPV Function
 * @see PPmt PPmt Function
 * @see PV PV Function
 * @see Rate Rate Function
 * @see SLN SLN Function
 * @see SYD SYD Function
 */
function Double PPmt(
   ByVal Rate As Double,
   ByVal Per As Double,
   ByVal NPer As Double,
   ByVal PV As Double,
   Optional ByVal FV As Double = 0,
   Optional ByVal Due As DueDate = DueDate.EndOfPeriod
);

/**
 * Writes display-formatted data to a sequential file.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * Print will not include a linefeed at the end of a line; PrintLine, however, will include a linefeed.
 * <P>
 * Data written with Print is usually read from a file with LineInput or Input.
 * <P>
 * If you omit Output for PrintLine, a blank line is printed to the file; for Print, nothing is output. Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and TAB may result in inconsistent results.
 * <P>
 * For Boolean data, either True or False is printed. The True and False keywords are not translated, regardless of the locale.
 * <P>
 * Date data is written to the file using the standard short date format recognized by your system. When either the date or the time component is missing or zero, only the part provided is written to the file.
 * <P>
 * Nothing is written to the file if Output data is empty. However, if Output list data is DBNull, Null is written to the file.
 * <P>
 * For Error data, the output appears as Error errorcode. The Error keyword is not translated regardless of the locale.
 * <P>
 * All data written to the file using Print is internationally aware; that is, the data is properly formatted using the appropriate decimal separator. If the user wishes to output data for use by multiple locales, then Write should be used.
 *
 * <P>
 * <b>Output argument settings</b>
 * <P>
 * The Output argument settings are:
 * <P>
 * <pre>
 * Setting        Description
 * SPC(n)         Used to insert space characters in the output, where n is the number of space characters to insert.
 * TAB(n)         Used to position the insertion point to an absolute column number, where n is the column number. Use TAB with no argument to position the insertion point at the beginning of the next print zone.
 * expression     Numeric expressions or string expressions to print.
 * </pre>
 *
 * @param FileNumber  Required. Any valid file number.
 * @param Output      Optional. One or more comma-delimited expressions to write to a file.
 *
 * @exception IOException   File mode is invalid.
 * @exception IOException   FileNumber does not exist.
 *
 * @example
 * This example uses the Print and PrintLine functions to write data to a file.
 *
 * <pre>
 * FileOpen(1, "c:\trash.txt", OpenMode.Output)   ' Open file for output.
 * Print(1, "This is a test.")   ' Print text to file.
 * PrintLine(1)   ' Print blank line to file.
 * PrintLine(1, "Zone 1", TAB(), "Zone 2")   ' Print in two print zones.
 * PrintLine(1, "Hello", " ", "World")   ' Separate strings with space.
 * PrintLine(1, SPC(5), "5 leading spaces ")   ' Print five leading spaces.
 * PrintLine(1, TAB(10), "Hello")   ' Print word at column 10.
 *
 * ' Assign Boolean, Date, and Error values.
 * Dim aBool As Boolean
 * Dim aDate As DateTime
 * aBool = False
 * aDate = DateTime.Parse("February 12, 1969")
 *
 * ' Dates and booleans are translated using locale settings of your system.
 * PrintLine(1, aBool, " is a Boolean value")
 * PrintLine(1, aDate, " is a date")
 * FileClose(1)   ' Close file.
 * </pre>
 *
 * @see FileOpen FileOpen Function
 * @see SPC SPC Function
 * @see TAB TAB Function
 * @see Write Write Function
 * @see WriteLine WriteLine Function
 */
procedure Print(
   ByVal FileNumber As Integer,
   ByVal ParamArray Output() As Object
);

/**
 * Writes display-formatted data to a sequential file.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * Print will not include a linefeed at the end of a line; PrintLine, however, will include a linefeed.
 * <P>
 * Data written with Print is usually read from a file with LineInput or Input.
 * <P>
 * If you omit Output for PrintLine, a blank line is printed to the file; for Print, nothing is output. Multiple expressions separated with a comma will be aligned on tab boundaries, but mixing commas and TAB may result in inconsistent results.
 * <P>
 * For Boolean data, either True or False is printed. The True and False keywords are not translated, regardless of the locale.
 * <P>
 * Date data is written to the file using the standard short date format recognized by your system. When either the date or the time component is missing or zero, only the part provided is written to the file.
 * <P>
 * Nothing is written to the file if Output data is empty. However, if Output list data is DBNull, Null is written to the file.
 * <P>
 * For Error data, the output appears as Error errorcode. The Error keyword is not translated regardless of the locale.
 * <P>
 * All data written to the file using Print is internationally aware; that is, the data is properly formatted using the appropriate decimal separator. If the user wishes to output data for use by multiple locales, then Write should be used.
 *
 * <P>
 * <b>Output argument settings</b>
 * <P>
 * The Output argument settings are:
 * <P>
 * <pre>
 * Setting        Description
 * SPC(n)         Used to insert space characters in the output, where n is the number of space characters to insert.
 * TAB(n)         Used to position the insertion point to an absolute column number, where n is the column number. Use TAB with no argument to position the insertion point at the beginning of the next print zone.
 * expression     Numeric expressions or string expressions to print.
 * </pre>
 *
 * @param FileNumber  Required. Any valid file number.
 * @param Output      Optional. One or more comma-delimited expressions to write to a file.
 *
 * @exception IOException   File mode is invalid.
 * @exception IOException   FileNumber does not exist.
 *
 * @example
 * This example uses the Print and PrintLine functions to write data to a file.
 *
 * <pre>
 * FileOpen(1, "c:\trash.txt", OpenMode.Output)   ' Open file for output.
 * Print(1, "This is a test.")   ' Print text to file.
 * PrintLine(1)   ' Print blank line to file.
 * PrintLine(1, "Zone 1", TAB(), "Zone 2")   ' Print in two print zones.
 * PrintLine(1, "Hello", " ", "World")   ' Separate strings with space.
 * PrintLine(1, SPC(5), "5 leading spaces ")   ' Print five leading spaces.
 * PrintLine(1, TAB(10), "Hello")   ' Print word at column 10.
 *
 * ' Assign Boolean, Date, and Error values.
 * Dim aBool As Boolean
 * Dim aDate As DateTime
 * aBool = False
 * aDate = DateTime.Parse("February 12, 1969")
 *
 * ' Dates and booleans are translated using locale settings of your system.
 * PrintLine(1, aBool, " is a Boolean value")
 * PrintLine(1, aDate, " is a date")
 * FileClose(1)   ' Close file.
 * </pre>
 *
 * @see FileOpen FileOpen Function
 * @see SPC SPC Function
 * @see TAB TAB Function
 * @see Write Write Function
 * @see WriteLine WriteLine Function
 */
procedure PrintLine(
   ByVal FileNumber As Integer,
   ByVal ParamArray Output() As Object
);

/**
 * Returns a Double specifying the present value of an annuity based on periodic, fixed payments to be paid in the future and a fixed interest rate.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * An annuity is a series of fixed cash payments made over a period of time. An annuity can be a loan (such as a home mortgage) or an investment (such as a monthly savings plan).
 * <P>
 * The Rate and NPer arguments must be calculated using payment periods expressed in the same units. For example, if Rate is calculated using months, NPer must also be calculated using months.
 * <P>
 * For all arguments, cash paid out (such as deposits to savings) is represented by negative numbers; cash received (such as dividend checks) is represented by positive numbers.
 *
 * @param Rate   Required. Double specifying interest rate per period. For example, if you get a car loan at an annual percentage rate (APR) of 10 percent and make monthly payments, the rate per period is 0.1/12, or 0.0083.
 * @param NPer   Required. Double specifying total number of payment periods in the annuity. For example, if you make monthly payments on a four-year car loan, your loan has a total of 4 * 12 (or 48) payment periods.
 * @param Pmt    Required. Double specifying payment to be made each period. Payments usually contain principal and interest that doesn't change over the life of the annuity.
 * @param FV     Optional. Double specifying future value or cash balance you want after you've made the final payment. For example, the future value of a loan is $0 because that's its value after the final payment. However, if you want to save $50,000 over 18 years for your child's education, then $50,000 is the future value. If omitted, 0 is assumed.
 * @param Due    Optional. Object of type Microsoft.VisualBasic.DueDate that specifies when payments are due. This argument must be either DueDate.EndOfPeriod if payments are due at the end of the payment period, or DueDate.BegOfPeriod if payments are due at the beginning of the period. If omitted, DueDate.EndOfPeriod is assumed.
 *
 * @example
 * In this example, the PV function returns the present value of an $1,000,000 annuity that will provide $50,000 a year for the next 20 years. Provided are the expected annual percentage rate (APR), the total number of payments (TotPmts), the amount of each payment (YrIncome), the total future value of the investment (FVal), and a number that indicates whether each payment is made at the beginning or end of the payment period (PayType). Note that YrIncome is a negative number because it represents cash paid out from the annuity each year.
 *
 * <pre>
 * Sub TestPV()
 *   Dim Fmt As String = "###,##0.00"    ' Define money format.
 *   Dim APR, TotPmts, YrIncome, FVal, PVal As Double
 *   Dim PayType As DueDate
 *   APR = 0.0825  ' Annual percentage rate.
 *   TotPmts = 20   ' Total number of payments.
 *   YrIncome = 50000   ' Yearly income.
 *   FVal = 1000000   ' Future value.
 *   PayType = DueDate.BegOfPeriod   ' Payment at beginning of month.
 *   PVal = PV(APR, TotPmts, -YrIncome, FVal, PayType)
 *   MsgBox("The present value is " & Format(PVal, Fmt) & ".")
 * End Sub
 * </pre>
 *
 * @see DDB DDB Function
 * @see IRR IRR Function
 * @see MIRR MIRR Function
 * @see NPer NPer Function
 * @see NPV NPV Function
 * @see PPmt PPmt Function
 * @see Rate Rate Function
 * @see SLN SLN Function
 * @see SYD SYD Function
 */
function Double PV(
   ByVal Rate As Double,
   ByVal NPer As Double,
   ByVal Pmt As Double,
   Optional ByVal FV As Double = 0,
   Optional ByVal Due As DueDate = DueDate.EndOfPeriod
);

/**
 * Returns an Integer value representing the RGB color code corresponding to the specified color number.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * Starting with the least-significant byte, the returned value specifies the red, green, and blue values used to set the appropriate color in the RGB system used by the Visual Basic language.
 *
 * <P>
 * <b>Settings</b>
 * <P>
 * The color argument has these settings:
 *
 * <pre>
 * Number   Color   Number     Color
 *   0      Black     8       Gray
 *   1      Blue      9     Light blue
 *   2      Green    10     Light green
 *   3      Cyan     11     Light cyan
 *   4       Red     12     Light red
 *   5     Magenta   13    Light magenta
 *   6     Yellow    14    Light yellow
 *   7      White    15    Bright white
 * </pre>
 *
 * @param Color  Required. A whole number in the range 015.
 *
 * @exception ArgumentException   Color is outside of range 0 to 15, inclusive.
 *
 * @example
 * This example uses the QBColor function to change to the color indicated by colorInteger. QBColor accepts integer values between 0 and 15.
 *
 * <pre>
 * Dim colorInteger As Integer
 * ' Use 4 for red.
 * colorInteger = QBColor(4)
 * </pre>
 *
 * @see RGB RGB Function
 */
function Integer QBColor(Color);

/**
 * Returns a Double specifying the interest rate per period for an annuity.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * An annuity is a series of fixed cash payments made over a period of time. An annuity can be a loan (such as a home mortgage) or an investment (such as a monthly savings plan).
 * <P>
 * For all arguments, cash paid out (such as deposits to savings) is represented by negative numbers; cash received (such as dividend checks) is represented by positive numbers.
 * <P>
 * Rate is calculated by iteration. Starting with the value of Guess, Rate cycles through the calculation until the result is accurate to within 0.00001 percent. If Rate can't find a result after 20 tries, it fails. If your guess is 10 percent and Rate fails, try a different value for Guess.
 *
 * @param NPer  Required. Double specifying total number of payment periods in the annuity. For example, if you make monthly payments on a four-year car loan, your loan has a total of 4 * 12 (or 48) payment periods.
 * @param Pmt   Required. Double specifying payment to be made each period. Payments usually contain principal and interest that doesn't change over the life of the annuity.
 * @param PV    Required. Double specifying present value, or value today, of a series of future payments or receipts. For example, when you borrow money to buy a car, the loan amount is the present value to the lender of the monthly car payments you will make.
 * @param FV    Optional. Double specifying future value or cash balance you want after you make the final payment. For example, the future value of a loan is $0 because that's its value after the final payment. However, if you want to save $50,000 over 18 years for your child's education, then $50,000 is the future value. If omitted, 0 is assumed.
 * @param Due   Optional. Object of type Microsoft.VisualBasic.DueDate that specifies when payments are due. This argument must be either DueDate.EndOfPeriod if payments are due at the end of the payment period, or DueDate.BegOfPeriod if payments are due at the beginning of the period. If omitted, DueDate.EndOfPeriod is assumed.
 * @param Guess Optional. Double specifying value you estimate will be returned by Rate. If omitted, Guess is 0.1 (10 percent).
 *
 * @exception ArgumentException   NPer <= 0.
 *
 * @example
 * This example uses the Rate function to calculate the interest rate of a loan given the total number of payments (TotPmts), the amount of the loan payment (Payment), the present value or principal of the loan (PVal), the future value of the loan (FVal), a number that indicates whether the payment is due at the beginning or end of the payment period (PayType), and an approximation of the expected interest rate (Guess).
 *
 * <pre>
 * Sub TestRate()
 *   Dim PVal, Payment, TotPmts, FVal, Guess, APR As Double
 *   Dim PayType As DueDate
 *   Dim Fmt As String = "##0.00"   ' Define percentage format.
 *   Dim Response As MsgBoxResult
 *   FVal = 0   ' Usually 0 for a loan.
 *   Guess = 0.1  ' Guess of 10 percent.
 *   PVal = CDbl(InputBox("How much did you borrow?"))
 *   Payment = CDbl(InputBox("What's your monthly payment?"))
 *   TotPmts = CDbl(InputBox("How many monthly payments do you have to make?"))
 *   Response = MsgBox("Do you make payments at the end of the month?", MsgBoxStyle.YesNo)
 *   If Response = MsgBoxResult.No Then
 *     PayType = DueDate.BegOfPeriod
 *   Else
 *     PayType = DueDate.EndOfPeriod
 *   End If
 *   APR = (Rate(TotPmts, -Payment, PVal, FVal, PayType, Guess) * 12) * 100
 *   MsgBox("Your interest rate is " & Format(CInt(APR), Fmt) & " percent.")
 * End Sub
 * </pre>
 *
 * @see DDB DDB Function
 * @see IRR IRR Function
 * @see MIRR MIRR Function
 * @see NPer NPer Function
 * @see NPV NPV Function
 * @see PPmt PPmt Function
 * @see PV PV Function
 * @see SLN SLN Function
 * @see SYD SYD Function
 */
function Double Rate(
   ByVal NPer As Double,
   ByVal Pmt As Double,
   ByVal PV As Double,
   Optional ByVal FV As Double = 0,
   Optional ByVal Due As DueDate = DueDate.EndOfPeriod,
   Optional ByVal Guess As Double = 0.1
);

/**
 * Renames a disk file, directory, or folder.
 *
 * <P>
 * <B>Remarks</b>
 * <P>
 * The Rename function renames a file and moves it to a different directory or folder, if necessary. The Rename function can move a file across drives, but it can only rename an existing directory or folder when both NewPath and OldPath are located on the same drive. Name cannot create a new file, directory, or folder.
 * <P>
 * Using the Rename function on an open file produces an error. You must close an open file before renaming it. Rename arguments cannot include multiple-character (*) and single-character (?) wildcards.
 *
 * @param OldPath  Required. String expression that specifies the existing file name and location. OldPath may include the directory or folder, and drive, of the file.
 * @param NewPath  Required. String expression that specifies the new file name and location. NewPath may include directory or folder, and drive of the destination location. The file name specified by NewPath can't already exist.
 *
 * @exception ArgumentException   Pathname is invalid .
 * @exception FileNotFoundException   OldPath file does not exist.
 * @exception IOException   NewPath file already exists.
 * @exception IOException   Access is invalid.
 * @exception IOException   Cannot rename to different device.
 *
 * @example
 * This example uses the Rename function to rename a file. For purposes of this example, assume that the directories or folders that are specified already exist.
 *
 * <pre>
 * Dim OldName, NewName As String
 * OldName = "OLDFILE"
 * NewName = "NEWFILE" ' Define file names.
 * Rename(OldName, NewName)   ' Rename file.
 *
 * OldName = "C:\MYDIR\OLDFILE"
 * NewName = "C:\YOURDIR\NEWFILE"
 * Rename(OldName, NewName)   ' Move and rename file.
 * </pre>
 *
 * @see Kill Kill Function
 */
procedure Rename(
   ByVal OldPath As String,
   ByVal NewPath As String
);

/**
 * Returns a string in which a specified substring has been replaced with another substring a specified number of times.
 *
 * <P>
 * <b>Settings</b>
 * <P>
 * The Compare argument can have the following values:
 *
 * <pre>
 * Constant    Description
 * Binary      Performs a binary comparison
 * Text        Performs a textual comparison
 * </pre>
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The return value of the Replace function is a string that begins at the position specified by Start and concludes at the end of the Expression string, with the substitutions made as specified by the Find and Replace values.
 *
 * @param Expression  Required. String expression containing substring to replace.
 * @param Find        Required. Substring being searched for.
 * @param Replacement Required. Replacement substring.
 * @param Start       Optional. Position within Expression where substring search is to begin. If omitted, 1 is assumed.
 * @param Count       Optional. Number of substring substitutions to perform. If omitted, the default value is 1, which means make all possible substitutions.
 * @param Compare     Optional. Numeric value indicating the kind of comparison to use when evaluating substrings. See Settings for values.
 *
 * @return
 *
 * <pre>
 * If                                          Replace returns
 * Expression is zero-length                   Zero-length string ("")
 * Find is zero-length                         Copy of Expression
 * Replace is zero-length                      Copy of Expression with no occurrences of Find
 * Start is greater than length of expression  Zero-length string
 * Count is 0                                  Copy of Expression
 * </pre>
 *
 * @exception ArgumentException   Count < -1 or Start <= 0.
 *
 * @example
 * This example demonstrates the Replace function.
 *
 * <pre>
 * Dim myString As String = "Shopping List"
 * Dim aString As String
 * ' Returns "Shipping List".
 * aString = Replace(myString, "o", "i")
 * </pre>
 *
 * @see Filter Filter Function
 */
function String Replace(
   ByVal Expression As String,
   ByVal Find As String,
   ByVal Replacement As String,
   Optional ByVal Start As Integer = 1,
   Optional ByVal Count As Integer = -1,
   Optional ByVal Compare As CompareMethod = CompareMethod.Binary
);

/**
 * Closes all disk files opened using the FileOpen function.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The Reset function closes all active files opened by the FileOpen function and has the same function as FileClose() without any parameters.
 *
 * @example
 * This example uses the Reset function to close all open files and write the contents of all file buffers to disk. Note the use of the Object variable FileNumber as both a string and a number.
 *
 * <pre>
 * ' Open 5 files named TEST1, TEST2, etc.
 * Dim fileNumber As Integer
 * For fileNumber = 1 To 5    ' Open 5 files.
 *   FileOpen(fileNumber, "TEST" & fileNumber, OpenMode.Output)
 *   PrintLine(fileNumber, "Hello World")
 * Next fileNumber
 * Reset()   ' Close files and write contents to disk.
 * </pre>
 *
 * @see FileClose Function
 * @see FileOpen Function
 */
procedure Reset();

/**
 * Returns an Integer value representing an RGB color value from a set of red, green and blue color components.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * Application methods and properties that accept a color specification expect that specification to be a number representing an RGB color value. An RGB color value specifies the relative intensity of red, green, and blue to cause a specific color to be displayed.
 * <P>
 * If the value for any argument to RGB is greater than 255, 255 is used.
 * <P>
 * The following table lists some standard colors and the red, green, and blue values they include:
 *
 * <pre>
 * Color   Red value   Green value   Blue value
 * Black      0             0            0
 * Blue       0             0           255
 * Green      0            255           0
 * Cyan       0            255          255
 * Red       255            0            0
 * Magenta   255            0           255
 * Yellow    255           255           0
 * White     255           255          255
 * </pre>
 *
 * @param Red     Required. Integer in the range 0255, inclusive, that represents the intensity of the red component of the color.
 * @param Green   Required. Integer in the range 0255, inclusive, that represents the intensity of the green component of the color.
 * @param Blue    Required. Integer in the range 0255, inclusive, that represents the intensity of the blue component of the color.
 *
 * @example
 * This example shows how the RGB function is used to return a whole number representing an RGB color value.
 *
 * <pre>
 * Dim red, rgbValue As Integer
 * Dim i As Integer = 75
 * red = RGB(255, 0, 0)   ' Return the value for red.
 * rgbValue = RGB(i, 64 + i, 128 + i)    ' Same as RGB(75, 139, 203).
 * </pre>
 *
 */
function Integer RGB(
   Red As Integer,
   Green As Integer,
   Blue As Integer
);

/**
 * Returns a string containing a specified number of characters from the right side of a string.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * To determine the number of characters in Str, use the Len function. If used in a Windows Form, or any other class that has a Right property, you must fully qualify the function with Microsoft.VisualBasic.Right.
 *
 * @param Str      Required. String expression from which the rightmost characters are returned.
 * @param Length   Required. Integer. Numeric expression indicating how many characters to return. If 0, a zero-length string ("") is returned. If greater than or equal to the number of characters in Str, the entire string is returned.
 *
 * @exception ArgumentException   Length < 0.
 *
 * @example
 * This example demonstrates the use of the Right function to return a substring of a given String. In a class that has a Right property, it may be necessary to fully qualify the Right function.
 *
 * <pre>
 * Dim myString As String = "Hello World!"
 * Dim subString As String
 * subString = Microsoft.VisualBasic.Right(myString, 6)   ' Returns "World!"
 * </pre>
 *
 * @see Left Left Function
 * @see Len Len Function
 * @see Mid Mid Function
 *
 */
function String Right(
   ByVal Str As String,
   ByVal Length As Integer
);

/**
 * Removes an existing directory or folder.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * An error occurs if you try to use RmDir on a directory or folder containing files. Use the Kill function to delete all files before attempting to remove a directory or folder.
 *
 * @param Path Required. String expression that identifies the directory or folder to be removed. Path may include the drive. If no drive is specified, RmDir removes the directory or folder on the current drive.
 *
 * @exception ArgumentException   Path is not specified or is empty.
 * @exception IOException   Target directory contains files.
 * @exception FileNotFoundException  Directory does not exist.
 *
 * @example
 * This example uses the RmDir function to remove an existing directory or folder.
 *
 * <pre>
 * ' Assume that MYDIR is an empty directory or folder.
 * RmDir ("MYDIR")   ' Remove MYDIR.
 * </pre>
 *
 * @see ChDir ChDir Function
 * @see CurDir CurDir Function
 * @see Kill Kill Function
 * @see MkDir MkDir Function
 */
procedure RmDir(ByVal Path As String);

/**
 * Returns a random number of type Single.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The Rnd function returns a value less than 1, but greater than or equal to zero.
 * <P>
 * The value of number determines how Rnd generates a random number:
 * <P>
 * For any given initial seed, the same number sequence is generated because each successive call to the Rnd function uses the previously generated number as a seed for the next number in the sequence.
 * <P>
 * Before calling Rnd, use the Randomize statement without an argument to initialize the random-number generator with a seed based on the system timer.
 * <P>
 * To produce random integers in a given range, use this formula:
 *
 * <pre>
 * Int((upperbound - lowerbound + 1) * Rnd + lowerbound)
 * </pre>
 *
 * Here, upperbound is the highest number in the range, and lowerbound is the lowest number in the range.
 * <P>
 * Note   To repeat sequences of random numbers, call Rnd with a negative argument immediately before using Randomize with a numeric argument. Using Randomize with the same value for number does not repeat the previous sequence.
 *
 * @param number Optional. A Single value or any valid Single expression.
 *
 * @return
 *
 * If number is         Rnd generates
 * Less than zero       The same number every time, using number as the seed.
 * Greater than zero    The next random number in the sequence.
 * Equal to zero        The most recently generated number.
 * Not supplied         The next random number in the sequence.
 *
 * @example
 * This example uses the Rnd function to generate a random integer value >from 1 to 6.
 *
 * <pre>
 * Dim MyValue As Integer
 * MyValue = CInt(Int((6 * Rnd()) + 1)) ' Generate random value between 1 and 6.
 * </pre>
 */
function Single Rnd(number);

/**
 * Returns the whole number nearest the specified value.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The behavior of this method follows IEEE Standard 754, section 4. This kind of rounding is sometimes called rounding to nearest, or banker's rounding.
 *
 * @param d  A Decimal number to be rounded.
 *
 * @return The whole number nearest parameter d. If d is halfway between two whole numbers, one of which by definition is even and the other odd, then the even number is returned.
 *
 * @example
 * The following code example demonstrates rounding to nearest.
 *
 * <pre>
 * Math.Round(4.4) 'Returns 4.0.
 * Math.Round(4.5) 'Returns 4.0.
 * Math.Round(4.6) 'Returns 5.0.
 * </pre>
 *
 */
function Decimal Round(
   ByVal d As Decimal
);

/**
 * Returns the whole number nearest the specified value.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The behavior of this method follows IEEE Standard 754, section 4. This kind of rounding is sometimes called rounding to nearest, or banker's rounding.
 *
 * @param a A double-precision floating-point number to be rounded.
 *
 * @return The whole number nearest a. If a is halfway between two whole numbers, one of which by definition is even and the other odd, then the even number is returned.
 *
 * @example
 * The following code example demonstrates rounding to nearest.
 *
 * <pre>
 * Math.Round(4.4) 'Returns 4.0.
 * Math.Round(4.5) 'Returns 4.0.
 * Math.Round(4.6) 'Returns 5.0.
 * </pre>
 */
function Double Round(
   ByVal d As Double
);

/**
 * Returns the number with the specified precision nearest the specified value.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The decimals parameter specifies the number of significant fractional digits in the return value and ranges from 0 to 28. If decimals is zero, then a whole number is returned.
 * <P>
 * The behavior of this method follows IEEE Standard 754, section 4. This kind of rounding is sometimes called rounding to nearest, or banker's rounding. If decimals is zero, this kind of rounding is sometimes called rounding toward zero.
 *
 * @param d           A Decimal number to be rounded.
 * @param decimals    The number of significant fractional digits (precision) in the return value.
 *
 * @return The number nearest d with precision equal to decimals. If d is halfway between two numbers, one of which is even and the other odd, then the even number is returned. If the precision of d is less than decimals, then d is returned unchanged.
 *
 * @example
 * The following code example demonstrates rounding to nearest.
 *
 * <pre>
 * Math.Round(3.44, 1) 'Returns 3.4.
 * Math.Round(3.45, 1) 'Returns 3.4.
 * Math.Round(3.46, 1) 'Returns 3.5.
 * </pre>
 *
 */
function Decimal Round(
   ByVal d As Decimal,
   ByVal decimals As Integer
);

/**
 * Returns the number with the specified precision nearest the specified value.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The digits parameter specifies the number of significant fractional digits in the return value and ranges from 0 to 15. If digits is zero, then a whole number is returned.
 * <P>
 * The behavior of this method follows IEEE Standard 754, section 4. This kind of rounding is sometimes called rounding to nearest, or banker's rounding. If digits is zero, this kind of rounding is sometimes called rounding toward zero.
 *
 * @param value   A double-precision floating-point number to be rounded.
 * @param digits  The number of significant fractional digits (precision) in the return value.
 *
 * @return The number nearest value with precision equal to digits. If value is halfway between two numbers, one of which is even and the other odd, then the even number is returned. If the precision of value is less than digits, then value is returned unchanged.
 *
 * @example
 * The following code example demonstrates rounding to nearest.
 *
 * <pre>
 * Math.Round(3.44, 1) 'Returns 3.4.
 * Math.Round(3.45, 1) 'Returns 3.4.
 * Math.Round(3.46, 1) 'Returns 3.5.
 * </pre>
 */
function Double Round(
   ByVal value As Double,
   ByVal digits As Integer
);

/**
 * Returns a right-aligned string containing the specified string adjusted to the specified length.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If Source is longer than Length, RSet places only the leftmost characters, up to the length of Source, in the returned string. If the specified string is shorter than the specified length, spaces are added to the left end of the string to produce the appropriate length. If the specified string is longer than the specified length, it is shortened to the specified length.
 *
 * @param Source  Required. String expression. Name of string variable.
 * @param Length  Required. Integer expression. Length of returned string.
 *
 * @example
 * This example demonstrates the use of the RSet function.
 *
 * <pre>
 * Dim myString As String = "Right"
 * Dim rString As String
 * rString = RSet(myString, 11)   ' Returns "      Right"
 * </pre>
 *
 * @see LSet LSet Function
 */
function String RSet(
   ByVal Source As String,
   ByVal Length As Integer
);

/**
 * Saves or creates an application entry in the Windows registry.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If the key setting can't be saved for any reason, an error occurs.
 * <P>
 * SaveSetting requires that a user be logged on since it operates under the HKEY_LOCAL_USER registry key, which is not active until a user logs on interactively.
 * <P>
 * Registry settings that are to be accessed from a non-interactive process (such as mtx.exe) should be stored under either the HKEY_LOCAL_MACHINE\Software\ or the HKEY_USER\DEFAULT\Software registry keys.
 *
 * @param AppName  Required. String expression containing the name of the application or project to which the setting applies.
 * @param Section  Required. String expression containing the name of the section in which the key setting is being saved.
 * @param Key      Required. String expression containing the name of the key setting being saved.
 * @param Setting  Required. Expression containing the value to which Key is being set.
 *
 * @exception ArgumentException  Key registry could not be created, or user is not logged in.
 *
 * @example
 * The following example first uses the SaveSetting statement to make entries in the Windows registry for the MyApp application, and then uses the DeleteSetting statement to remove them.
 *
 * <pre>
 * ' Place some settings in the registry.
 * SaveSetting("MyApp", "Startup", "Top", "75")
 * SaveSetting("MyApp","Startup", "Left", "50")
 * ' Remove Startup section and all its settings from registry.
 * DeleteSetting ("MyApp", "Startup")
 * ' Remove MyApp from the registry.
 * DeleteSetting ("MyApp")
 * </pre>
 *
 * @see DeleteSetting DeleteSetting Function
 * @see GetAllSettings GetAllSettings Function
 * @see GetSetting GetSetting Function
 *
 */
procedure SaveSetting(
   ByVal AppName As String,
   ByVal Section As String,
   ByVal Key As String,
   ByVal Setting As String
);

/**
 * Returns an Integer value from 0 through 59 representing the second of the minute.
 *
 * @param TimeValue Required. Date value from which you want to extract the second.
 * <P>
 * You can also obtain the second of the minute by calling DatePart and specifying DateInterval.Second for the Interval argument.
 *
 * @example
 * This example uses the Second function to obtain the second of the minute from a specified time. In the development environment, the time literal is displayed in short time format using the locale settings of your code.
 *
 * <pre>
 * Dim MyTime As Date
 * Dim MySecond As Integer
 * MyTime = #4:35:17 PM#   ' Assign a time.
 * MySecond = Second(MyTime)   ' MySecond contains 17.
 * </pre>
 *
 * @see Day Day Function
 * @see Hour Hour Function
 * @see Minute Minute Function
 * @see DatePart DatePart Function
 */
function Integer Second(ByVal TimeValue As DateTime);

/**
 * Returns a Long specifying the current read/write position within a file opened using the FileOpen function or sets the position for the next read/write operation within a file opened using the FileOpen function.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * Seek returns a value between 1 and 2,147,483,647 (equivalent to 2^31  1), inclusive.
 * <P>
 * The following describes the return values for each file access mode:
 *
 * <pre>
 * Mode                           Return Value
 * Random                         Number of the next record read or written
 * Binary, Input, Output, Append    Byte position at which the next operation takes place. The first byte in a file is at position 1, the second byte is at position 2, and so on.
 * </pre>
 *
 * @param FileNumber  Required. An Integer containing a valid file number.
 * @param Position    Required. Number in the range 1  2,147,483,647, inclusive, that indicates where the next read/write operation should occur.
 *
 * @exception IOException   FileNumber does not exist.
 * @exception IOException   File mode is invalid.
 *
 * @example
 * This example uses the Seek function to return the current file position. The example assumes TESTFILE is a file containing records of the structure Record.
 *
 * <pre>
 * Structure Record   ' Define user-defined type.
 *   ID As Integer
 *   Name As String
 * End Structure
 * </pre>
 * <P>
 * For files opened in Random mode, Seek returns the number of next record.
 *
 * <pre>
 * Dim MyRecord As Record
 * FileOpen(1, "TESTFILE", OpenMode.Random)
 * Do While Not EOF(1)
 *   Debug.WriteLine(Seek(1))   ' Print record number.
 *   FileGet(1, MyRecord)   ' Read next record.
 * Loop
 * FileClose(1)
 * </pre>
 * <P>
 *
 * For files opened in modes other than Random mode, Seek returns the byte position at which the next operation takes place. Assume TESTFILE is a file containing a few lines of text.
 *
 * <pre>
 * ' Print character position at beginning of each line.
 * Dim TextLine As String
 * FileOpen(1, "TESTFILE", OpenMode.Input)   ' Open file for reading.
 * While Not EOF(1)
 *   TextLine = LineInput(1)   ' Read next line.
 *   Debug.WriteLine(Seek(1))   ' Position of next line.
 * End While
 * FileClose(1)
 * </pre>
 * <P>
 *
 * This example uses the Seek function to set the position for the next read or write within a file. This example assumes people.txt is a file containing records of the structure Record.
 *
 * <pre>
 * Structure Record
 *   Dim Name As String
 *   Dim ID As Integer
 * End Structure
 * </pre>
 * <P>
 *
 * For files opened in Random mode, Seek sets the next record.
 *
 * <pre>
 * Public Sub SeekAPerson(ByVal index As Integer)
 *   Try
 *     FileOpen(1, "c:\people.txt", OpenMode.Random)
 *     Dim onePerson As Record
 *     Seek(1, index)
 *     FileGet(1, onePerson)
 *     FileClose(1)
 *     Console.WriteLine(onePerson.Name & " " & onePerson.ID)
 *   Catch
 *     ' Error recovery code here.
 *   End Try
 * End Sub
 * </pre>
 * <P>
 *
 * For files opened in modes other than Random mode, Seek sets the byte position at which the next operation takes place. Assume TESTFILE is a file containing a few lines of text.
 *
 * <pre>
 * Dim someText As String
 * FileOpen(1, "TESTFILE", OpenMode.Input)   ' Open file for output.
 * Seek(1, 3)   ' Move to the third character.
 * Input(1, someText)
 * Console.WriteLine(someText)
 * FileClose(1)
 * </pre>
 *
 * @see FileGet FileGet Function
 * @see Loc Loc Function
 * @see FileOpen FileOpen Function
 * @see FilePut FilePut Function
 */
function Long Seek(ByVal FileNumber As Integer);

/**
 * Sets attribute information for a file.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * A run-time error occurs if you try to set the attributes of an open file.
 *
 * <P>
 * <b>Settings</b>
 * <P>
 * The Attributes argument enumeration values are:
 *
 * <pre>
 * Value     Constant    Description
 * Normal    VbNormal    Normal (default).
 * ReadOnly  VbReadOnly  Read-only.
 * Hidden    VbHidden    Hidden.
 * System    VbSystem    System file.
 * Volume    VbVolume    Volume label
 * Directory VbDirectory Directory or folder.
 * Archive   VbArchive   File has changed since last backup.
 * Alias     VbAlias     File has a different name.
 * </pre>
 *
 * @param PathName    Required. String expression that specifies a file name. PathName may include directory or folder, and drive.
 * @param Attributes  Required. Constant or numeric expression, whose sum specifies file attributes.
 *
 * @example
 * This example uses the SetAttr function to set attributes for a file.
 *
 * <pre>
 * SetAttr("TESTFILE", vbHidden)   ' Set hidden attribute.
 * SetAttr("TESTFILE", vbHidden Or vbReadOnly)   ' Set hidden and read-only
 * ' attributes.
 * </pre>
 *
 * @see FileAttr FileAttr Function
 * @see GetAttr GetAttr Function
 */
procedure SetAttr(
   ByVal PathName As String,
   ByVal Attributes As FileAttribute
);

/**
 * Returns the sine of the specified angle.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The angle, a, must be in radians. Multiply by p/180 to convert degrees to radians.
 *
 * @param a  An angle, measured in radians.
 *
 * @return The sine of a. If a is equal to NaN, NegativeInfinity, or PositiveInfinity, this method returns NaN.
 */
function Double Sin(ByVal a As Double);

/**
 * Returns a value indicating the sign of a decimal number.
 *
 * @param value  A signed Decimal number.
 *
 * @return A number indicating the sign of value.
 *
 * <pre>
 * Number    Description
 * -1        value is less than zero.
 * 0         value is equal to zero.
 * 1         value is greater than zero.
 * </pre>
 */
function Integer Sign(ByVal value As Decimal);

/**
 * Returns a value indicating the sign of a double-precision floating-point number.
 *
 * @param value  A signed number.
 *
 * @return A number indicating the sign of value.
 *
 * <pre>
 * Number    Description
 * -1        value is less than zero.
 * 0         value is equal to zero.
 * 1         value is greater than zero.
 * </pre>
 *
 * @exception ArithmeticException  value is equal to NaN.
 */
function Integer Sign(ByVal value As Double);

/**
 * Returns a value indicating the sign of a 16-bit signed integer.
 *
 * @param value  A signed number.
 *
 * @return A number indicating the sign of value.
 *
 * <pre>
 * Number    Description
 * -1        value is less than zero.
 * 0         value is equal to zero.
 * 1         value is greater than zero.
 * </pre>
 */
function Integer Sign(ByVal value As Short);

/**
 * Returns a value indicating the sign of a 32-bit signed integer.
 *
 * @param value  A signed number.
 *
 * @return A number indicating the sign of value.
 *
 * <pre>
 * Number    Description
 * -1        value is less than zero.
 * 0         value is equal to zero.
 * 1         value is greater than zero.
 * </pre>
 */
function Integer Sign(ByVal value As Integer);

/**
 * Returns a value indicating the sign of a 64-bit signed integer.
 *
 * @param value  A signed number.
 *
 * @return A number indicating the sign of value.
 *
 * <pre>
 * Number    Description
 * -1        value is less than zero.
 * 0         value is equal to zero.
 * 1         value is greater than zero.
 * </pre>
 */
function Integer Sign(ByVal value As Long);

/**
 * Returns a value indicating the sign of an 8-bit signed integer.
 * <P>
 * This method is not CLS-compliant. For more information about CLS compliance, see What is the Common Language Specification.
 *
 * @param value  A signed number.
 *
 * @return A number indicating the sign of value.
 *
 * <pre>
 * Number    Description
 * -1        value is less than zero.
 * 0         value is equal to zero.
 * 1         value is greater than zero.
 * </pre>
 */
function Integer Sign(ByVal value As SByte);

/**
 * Returns a value indicating the sign of a single-precision floating-point number.
 *
 * @param value  A signed number.
 *
 * @return A number indicating the sign of value.
 *
 * <pre>
 * Number    Description
 * -1        value is less than zero.
 * 0         value is equal to zero.
 * 1         value is greater than zero.
 * </pre>
 *
 * @exception ArithmeticException  value is equal to NaN.
 */
function Integer Sign(ByVal value As Single);

/**
 * Runs an executable program and returns an integer containing the program's process ID if it is still running.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The return value of the Shell function depends on whether the program named in Pathname is still executing when Shell returns. If you set Wait to True and the program finishes before the timeout expires, Shell returns zero. If the timeout expires, or if you omit Wait or set it to False, Shell returns the process ID of the program. The process ID is a unique number that identifies the running program.
 * <P>
 * If the Shell function cannot start the named program, a System.IO.FileNotFoundException error occurs. This can happen, for example, when you attempt to run a 16-bit program, such as command.com, >from an application using System.Windows.Forms. For a workaround, you can run a 32-bit program that calls the desired 16-bit program. In the case of command.com, you can run cmd.exe as an alternative.
 * <P>
 * By default, the Shell function runs the program asynchronously. This means that a program started with the Shell function might not finish executing before the statements following the Shell function are executed. If you want to wait for the program to finish before you continue, set Wait to True.
 * <P>
 * If the Pathname argument supplies the directory path as well as the file name, it is a good idea to enclose the entire specification in quotes, as the following example shows:
 *
 * <pre>
 * ID = Shell("""C:\Program Files\MyFile.exe"" -a -q", , True, 100000)
 * </pre>
 *
 * Each pair of adjacent double quotes ("") within the string literal is interpreted as one double quote character in the string. Therefore, the preceding example presents the following string to the Shell function:
 *
 * <pre>
 * "C:\Program Files\MyFile.exe" -a -q
 * </pre>
 *
 * If you did not have the path enclosed in quotes, Windows would look for a file called Program.exe in the C:\ directory. If such a program had been installed at that location, for example by illicit tampering, it would be executed instead of MyFile.exe in the C:\Program Files directory.
 *
 * @param Pathname Required. String. Name of the program to execute, together with any required arguments and command-line switches. Pathname can also include the drive and the directory path or folder.
 * @param Style    Optional. AppWinStyle. A value chosen from the AppWinStyle enumeration corresponding to the style of the window in which the program is to be run. If Style is omitted, Shell uses AppWinStyle.MinimizedFocus, which starts the program minimized and with focus.
 *
 * <P>
 * The Style argument can have one of the following settings:
 *
 * <pre>
 * Enumeration value               Description
 * AppWinStyle.Hide                The window is hidden and focus is given to the hidden window.
 * AppWinStyle.NormalFocus         The window is given focus and displayed in its most recent size and position.
 * AppWinStyle.MinimizedFocus      The window is given focus and displayed as an icon.
 * AppWinStyle.MaximizedFocus      The window is given focus and displayed using the entire screen.
 * AppWinStyle.NormalNoFocus       The window is set to its most recent size and position. The currently active window remains in focus.
 * AppWinStyle.MinimizedNoFocus    The window is displayed as an icon. The currently active window remains in focus.
 * </pre>
 *
 * @param Wait     Optional. Boolean. A value indicating whether the Shell function should wait for completion of the program. If Wait is omitted, Shell uses False.
 * @param Timeout  Optional. Integer. The number of milliseconds to wait for completion if Wait is True. If Timeout is omitted, Shell uses -1, which means there is no timeout and Shell does not return until the program completes. Therefore, if you omit Timeout or set it to -1, it is possible that Shell might never return control to your program.
 *
 * @exception ArgumentException       Style is not within range 0 through 9, inclusive.
 * @exception FileNotFoundException   Shell cannot start the named program.
 *
 * @example
 * This example uses the Shell function to run an application specified by the user. Specifying AppWinStyle.NormalFocus as the second argument opens the application in normal size and gives it the focus.
 *
 * <pre>
 * Dim ProcID As Integer
 * ' Run Calculator.
 * ProcID = Shell("C:\WINDOWS\CALC.EXE", AppWinStyle.NormalFocus)
 * </pre>
 *
 * @see AppActivate AppActivate Function
 */
function Integer Shell(
   ByVal Pathname As String,
   Optional ByVal Style As AppWinStyle = AppWinStyle.MinimizedFocus,
   Optional ByVal Wait As Boolean = False,
   Optional ByVal Timeout As Integer = -1
);

/**
 * Returns a Double specifying the straight-line depreciation of an asset for a single period.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The depreciation period must be expressed in the same unit as the Life argument. All arguments must be positive numbers.
 *
 * @param Cost     Required. Double specifying initial cost of the asset.
 * @param Salvage  Required. Double specifying value of the asset at the end of its useful life.
 * @param Life     Required. Double specifying length of the useful life of the asset.
 *
 * @exception ArgumentException    Life = 0.
 *
 * @example
 * This example uses the SLN function to return the straight-line depreciation of an asset for a single period given the asset's initial cost (InitCost), the salvage value at the end of the asset's useful life (SalvageVal), and the total life of the asset in years (LifeTime).
 *
 * <pre>
 * Sub TestSLN()
 *   Dim InitCost, SalvageVal, MonthLife As Double
 *   Dim LifeTime, Pdepr As Double
 *   Dim Fmt As String = "###,##0.00"   ' Define money format.
 *   Const YEARMONTHS As Integer = 12  ' Number of months in a year.
 *
 *   InitCost = CDbl(InputBox("What's the initial cost of the asset?"))
 *   SalvageVal = CDbl(InputBox("What's the asset's value at the end of its useful life?"))
 *   MonthLife = CDbl(InputBox("What's the asset's useful life in months?"))
 *   Do While MonthLife < YEARMONTHS   ' Ensure period is >= 1 year.
 *     MsgBox("Asset life must be a year or more.")
 *     MonthLife = CDbl(InputBox("What's the asset's useful life in months?"))
 *   Loop
 *   LifeTime = MonthLife / YEARMONTHS   ' Convert months to years.
 *   If LifeTime <> Int(MonthLife / YEARMONTHS) Then
 *     LifeTime = Int(LifeTime + 1)   ' Round up to nearest year.
 *   End If
 *   Pdepr = SLN(InitCost, SalvageVal, LifeTime)
 *   MsgBox("The depreciation is " & Format(Pdepr, Fmt) & " per year.")
 * End Sub
 * </pre>
 *
 * @see DDB DDB Function
 * @see IRR IRR Function
 * @see MIRR MIRR Function
 * @see NPer NPer Function
 * @see NPV NPV Function
 * @see PPmt PPmt Function
 * @see Rate Rate Function
 * @see SLN SLN Function
 * @see SYD SYD Function
 */
function Double SLN(
   ByVal Cost As Double,
   ByVal Salvage As Double,
   ByVal Life As Double
);

/**
 * Returns a string consisting of the specified number of spaces.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The Space function is useful for formatting output and clearing data in fixed-length strings.
 *
 * @exception ArgumentException   Number < 0.
 *
 * @example
 * This example uses the Space function to return a string consisting of a specified number of spaces.
 *
 * <pre>
 * Dim MyString As String
 * ' Returns a string with 10 spaces.
 * MyString = Space(10)
 * ' Inserts 10 spaces between two strings.
 * MyString = "Hello" & Space(10) & "World"
 * </pre>
 *
 * @see SPC SPC Function
 */
function String Space(ByVal Number As Integer);

/**
 * Used with the Print or PrintLine functions to position output.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If Count is less than the output line width, the next print position immediately follows the number of spaces printed. If Count is greater than the output line width, SPC calculates the next print position using the formula:
 *
 * <pre>
 * currentprintposition + (Count Mod width)
 * </pre>
 *
 * <P>
 * For example, if the current print position is 24, the output line width is 80, and you specify SPC(90), the next print will start at position 34 (current print position + the remainder of 90/80). If the difference between the current print position and the output line width is less than Count (or Count Mod width), the SPC function skips to the beginning of the next line and generates spaces equal to Count  (width  currentprintposition).
 * <P>
 * Note   Make sure your tabular columns are wide enough to accommodate wide letters.
 *
 * @example
 * This example uses the SPC function to position output in a file and in the Output window.
 *
 * <pre>
 * ' The SPC function can be used with the Print function.
 * FileOpen(1, "TESTFILE", OpenMode.Output)   ' Open file for output.
 * Print(1, "10 spaces between here", SPC(10), "and here.")
 * FileClose(1)   ' Close file.
 * </pre>
 *
 * The following statement causes the text to be printed in the Output window (using the WriteLine method), preceded by 30 spaces.
 *
 * <pre>
 * Debug.WriteLine(SPC(30), "Thirty spaces later...")
 * </pre>
 *
 * @see Print Print Function
 * @see PrintLine PrintLine Function
 * @see Space Space Function
 * @see TAB TAB Function
 * @see FileWidth FileWidth Function
 */
function SPCInfo SPC(ByVal Count As Short);

/**
 * Returns a zero-based, one-dimensional array containing a specified number of substrings.
 *
 * <P>
 * <b>Settings</b>
 * <P>
 * The Compare argument can have the following values:
 *
 * <pre>
 * Constant   Description
 * Binary     Performs a binary comparison
 * Text       Performs a textual comparison
 * </pre>
 *
 * @param Expression   Required. String expression containing substrings and delimiters. If Expression is a zero-length string (""), the Split function returns an array with no elements and no data.
 * @param Delimiter    Optional. Single character used to identify substring limits. If Delimiter is omitted, the space character (" ") is assumed to be the delimiter. If Delimiter is a zero-length string, a single-element array containing the entire Expression string is returned.
 * @param Limit        Optional. Number of substrings to be returned; the default, 1, indicates that all substrings are returned.
 * @param Compare      Optional. Numeric value indicating the comparison to use when evaluating substrings. See Settings for values.
 *
 * @example
 * The following example demonstrates the Split function:
 *
 * <pre>
 * Dim myString As String = "Look at these!"
 * ' Returns ["Look", "at", "these!"]
 * Dim myArray() As String = Split(myString)
 * </pre>
 *
 * @see Join Function
 */
function Array Split(
   ByVal Expression As String,
   Optional ByVal Delimiter As String = " ",
   Optional ByVal Limit As Integer = -1,
   Optional ByVal Compare As CompareMethod = CompareMethod.Binary
);

/**
 * Returns the square root of a specified number.
 *
 * @param d   A number.
 *
 * @return
 *
 * <pre>
 * Value of d           Returns
 * Zero, or positive    The positive square root of d.
 * Negative             NaN
 * </pre>
 *
 * If d is equal to NaN or PositiveInfinity, that value is returned.
 */
function Double Sqrt(ByVal d As Double);

/**
 * Returns a String representation of a number.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * When numbers are converted to strings, a leading space is always reserved for the sign of Number. If Number is positive, the returned string contains a leading space, and the plus sign is implied. A negative number will include the minus sign (-) and no leading space.
 * <P>
 * Use the Format function to convert numeric values you want formatted as dates, times, or currency or in other user-defined formats. Unlike the Str function, the Format function doesn't include a leading space for the sign of Number.
 * <P>
 * Note   The Str function recognizes only the period (.) as a valid decimal separator. If different decimal separators are used (for example, in international applications), use the CStr function to convert a number to a string.
 *
 * @param Number   Required. An Object containing any valid numeric expression.
 *
 * @exception ArgumentNullException   Number is not specified.
 * @exception InvalidCastException    Number is not a numeric type.
 *
 * @example
 * This example uses the Str function to return a String representation of a number. When a positive number is converted to a string, a leading space is always reserved for its sign.
 *
 * <pre>
 * Dim MyString As String
 * MyString = Str(459)   ' Returns " 459".
 * MyString = Str(-459.65)   ' Returns "-459.65".
 * MyString = Str(459.001)   ' Returns " 459.001".
 * </pre>
 *
 * @see Format Format Function
 * @see Val Val Function
 */
function String Str(ByVal Number As Object);

/**
 * Returns -1, 0, or 1, based on the result of a string comparison.
 *
 * <P>
 * <b>Settings</b>
 * <P>
 * The Compare argument settings are:
 *
 * <pre>
 * Constant Description
 * Binary   Performs a binary comparison, based on a sort order derived >from the internal binary representations of the characters.
 * Text     Performs a text comparison, based on a case-insensitive text sort order determined by your system's LocaleID value.
 * </pre>
 *
 * <b>Remarks</b>
 * <P>
 * The strings are compared by alphanumeric sort values begining with the first character. For further information on binary comparisons, textual comparisons, and sort order, see Option Compare Statement.
 *
 * @param String1  Required. Any valid String expression.
 * @param String2  Required. Any valid String expression.
 * @param Compare  Optional. Specifies the type of string comparison. If compare is omitted, the Option Compare setting determines the type of comparison.
 *
 * @return
 *
 * The StrComp function has the following return values:
 *
 * <pre>
 * If                                StrComp returns
 * String1 sorts ahead of String2    -1
 * String1 is equal to String2       0
 * String1 sorts after String2       1
 * </pre>
 *
 * @exception ArgumentException   Compare value is invalid .
 *
 * @example
 * This example uses the StrComp function to return the results of a string comparison. If the third argument is omitted, a binary comparison is performed.
 *
 * <pre>
 * Dim MyStr1, MyStr2 As String
 * Dim MyComp As Integer
 * MyStr1 = "ABCD"
 * MyStr2 = "abcd"   ' Defines variables.
 * ' The two strings sort equally. Returns 0
 * MyComp = StrComp(MyStr1, MyStr2, CompareMethod.Text)
 * ' MyStr1 sorts after MyStr2. Returns -1.
 * MyComp = StrComp(MyStr1, MyStr2, CompareMethod.Binary)
 * ' MyStr2 sorts before MyStr1. Returns 1.
 * MyComp = StrComp(MyStr2, MyStr1)
 * </pre>
 *
 * @see InStr InStr Function
 */
function Integer StrComp(
   ByVal String1 As String,
   ByVal String2 As String,
   <Microsoft.VisualBasic.OptionCompareAttribute>
   Optional ByVal Compare As Microsoft.VisualBasic.CompareMethod
);

/**
 * Returns a string converted as specified.
 *
 * <P>
 * <b>Settings</b>
 * <P>
 * The Conversion argument settings are:
 *
 * <pre>
 * Enumeration member               Description
 * VbStrConv.None                   Performs no conversion
 * VbStrConv.LinguisticCasing       Uses linguistic rules for casing, rather than File System (default). Valid with UpperCase and LowerCase only.
 * VbStrConv.UpperCase              Converts the string to uppercase characters.
 * VbStrConv.LowerCase              Converts the string to lowercase characters.
 * VbStrConv.ProperCase             Converts the first letter of every word in string to uppercase.
 * VbStrConv.Wide*                  Converts narrow (half-width) characters in the string to wide (full-width) characters.
 * VbStrConv.Narrow*                Converts wide (full-width) characters in the string to narrow (half-width) characters.
 * VbStrConv.Katakana**             Converts Hiragana characters in the string to Katakana characters.
 * VbStrConv.Hiragana**             Converts Katakana characters in the string to Hiragana characters.
 * VbStrConv.SimplifiedChinese*     Converts Traditional Chinese characters to Simplified Chinese.
 * VbStrConv.TraditionalChinese*    Converts Simplified Chinese characters to Traditional Chinese.
 *
 * *   Applies to Asian locales.
 * **   Applies to Japan only.
 * </pre>
 *
 * Note   These constants are specified in the .NET common language runtime. As a result, they may be used anywhere in your code in place of the actual values. Most can be combined, for example, UpperCase + Wide, except when they are mutually exclusive, for example, VbStrConv.Wide + VbStrConv.Narrow.
 * <P>
 * The following are valid word separators for proper casing: Null (Chr$(0)), horizontal tab (Chr$(9)), linefeed (Chr$(10)), vertical tab (Chr$(11)), form feed (Chr$(12)), carriage return (Chr$(13)), space (single-byte character set) (Chr$(32)). The actual value for a space varies by country/region for the double-byte character set.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The constants VbStrConv.Wide, VbStrConv.Narrow, VbStrConv.Simplified Chinese, VbStrConv.Traditional Chinese, VbStrConv.Katakana, and VbStrConv.Hiragana can cause run-time errors when used in locales where they do not apply, but not always: the constants VbStrConv.Katakana and VbStrConv.Hiragana can be used in a non-Japanese system with the Japanese Language Pack installed. In addition, use of the constants VbStrConv.Wide and VbStrConv.Narrow is supported on any system with a double-byte character set (DBCS) language installed.
 *
 * @param Str         Required. String expression to be converted.
 * @param Conversion  Required. Microsoft.VisualBasic.VbStrConv member. The enumeration value specifying the type of conversion to perform.
 * @param LocaleID    Optional. The LocaleID value, if different from the system LocaleID value. (The system LocaleID value is the default.)
 *
 * @exception ArgumentException   Unsupported LocaleID, Conversion < 0 or > 2048, or unsupported conversion for specified locale.
 *
 * @example
 * This example converts text into all lowercase letters.
 *
 * <pre>
 * Dim sText, sNewText As String
 * sText = "Hello World"
 * sNewText = StrConv(sText, VbStrConv.LowerCase)
 * Debug.WriteLine (sNewText)   ' Outputs "hello world".
 * </pre>
 *
 * @see Chr Chr Function
 * @see ChrW ChrW Function
 */
function String StrConv(
   ByVal Str As String,
   ByVal Conversion As Microsoft.VisualBasic.VbStrConv,
   Optional ByVal LocaleID As Integer,
);

/**
 * Returns a string or object consisting of the specified character repeated the specified number of times.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * This function returns a String made up of repeated characters. The character that makes up the string is the first character in the Character argument, and it is duplicated Number number of times.
 *
 * @param Number      Required. Integer expression. The length to the string to be returned.
 * @param Character   Required. Any valid Char, String, or Object expression. Only the first character of the expression will be used. If Character is of type Object, it must contain either a Char or a String value.
 *
 * @exception ArgumentException   Number < 0 or Character type is invalid.
 * @exception ArgumentNullException   Character is Nothing.
 *
 * @example
 * This example uses the StrDup function to return a string of duplicated characters.
 *
 * <pre>
 * Dim aString As String = "Wow! What a string!"
 * Dim aObject As New Object()
 * Dim myString As String
 * aObject = "This is a String contained within an Object"
 * myString = StrDup(5, "P")   ' Returns "PPPPP"
 * myString = StrDup(10, aString)   ' Returns "WWWWWWWWWW"
 * myString = StrDup(6, aObject)   ' Returns "TTTTTT"
 * </pre>
 *
 * @see SPC SPC Function
 */
function String StrDup(
   ByVal Number As Integer,
   ByVal Character As Char
);

/**
 * Returns a string or object consisting of the specified character repeated the specified number of times.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * This function returns a String made up of repeated characters. The character that makes up the string is the first character in the Character argument, and it is duplicated Number number of times.
 *
 * @param Number      Required. Integer expression. The length to the string to be returned.
 * @param Character   Required. Any valid Char, String, or Object expression. Only the first character of the expression will be used. If Character is of type Object, it must contain either a Char or a String value.
 *
 * @exception ArgumentException   Number < 0 or Character type is invalid.
 * @exception ArgumentNullException   Character is Nothing.
 *
 * @example
 * This example uses the StrDup function to return a string of duplicated characters.
 *
 * <pre>
 * Dim aString As String = "Wow! What a string!"
 * Dim aObject As New Object()
 * Dim myString As String
 * aObject = "This is a String contained within an Object"
 * myString = StrDup(5, "P")   ' Returns "PPPPP"
 * myString = StrDup(10, aString)   ' Returns "WWWWWWWWWW"
 * myString = StrDup(6, aObject)   ' Returns "TTTTTT"
 * </pre>
 *
 * @see SPC SPC Function
 */
function String StrDup(
   ByVal Number As Integer,
   ByVal Character As String
);

/**
 * Returns a string or object consisting of the specified character repeated the specified number of times.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * This function returns a String made up of repeated characters. The character that makes up the string is the first character in the Character argument, and it is duplicated Number number of times.
 *
 * @param Number      Required. Integer expression. The length to the string to be returned.
 * @param Character   Required. Any valid Char, String, or Object expression. Only the first character of the expression will be used. If Character is of type Object, it must contain either a Char or a String value.
 *
 * @exception ArgumentException   Number < 0 or Character type is invalid.
 * @exception ArgumentNullException   Character is Nothing.
 *
 * @example
 * This example uses the StrDup function to return a string of duplicated characters.
 *
 * <pre>
 * Dim aString As String = "Wow! What a string!"
 * Dim aObject As New Object()
 * Dim myString As String
 * aObject = "This is a String contained within an Object"
 * myString = StrDup(5, "P")   ' Returns "PPPPP"
 * myString = StrDup(10, aString)   ' Returns "WWWWWWWWWW"
 * myString = StrDup(6, aObject)   ' Returns "TTTTTT"
 * </pre>
 *
 * @see SPC SPC Function
 */
function Object StrDup(
   ByVal Number As Integer,
   ByVal Character As Object
);

/**
 * Returns a string in which the character order of a specified string is reversed.
 *
 * @param Expression   Required. String expression whose characters are to be reversed. If Expression is a zero-length string (""), a zero-length string is returned.
 *
 * @example
 *
 * <pre>
 * Dim myString As String = "ABCDEFG"
 * Dim revString As String
 * ' Returns "GFEDCBA"
 * revString = StrReverse(myString)
 * </pre>
 *
 * @see InStrRev InStrRev Function
 */
function String StrReverse(ByVal Expression As String);

/**
 * Evaluates a list of expressions and returns an Object value of an expression associated with the first expression in the list that is True.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The Switch function argument VarExpr consists of paired expressions and values. The Switch function evaluates the expressions from lowest to highest subscript in VarExpr, and returns the value associated with the first expression that evaluates to True. For example, if VarExpr(0) is True, Switch returns VarExpr(1), and if VarExpr(0) is False but VarExpr(2) is True, Switch returns VarExpr(3), and so on.
 * <P>
 * If you do not supply the VarExpr argument, Switch returns Nothing. If the number of elements in VarExpr is not divisible by two, an ArgumentException error occurs.
 * <P>
 * Note   The expressions in the argument list can include function calls. As part of preparing the argument list for the call to Switch, the Visual Basic compiler calls every function in every expression. This means that you cannot rely on a particular function not being called if an expression earlier in the argument list is True.
 *
 * @param VarExpr()  Required. Object parameter array. Must have an even number of elements. You can supply a list of Object variables or expressions separated by commas, or a single-dimensional array of Object elements.
 *
 * @exception ArgumentException   Number of arguments is odd.
 *
 * @example
 * This example uses the Switch function to return the name of a language that matches the name of a city. It requires that Option Strict be Off.
 *
 * <pre>
 * Function MatchUp (CityName As String) As String
 *   Return Microsoft.VisualBasic.Switch(CityName = "London", "English", _
 *     CityName = "Rome", "Italian", CityName = "Paris", "French")
 * End Function
 * </pre>
 *
 * Since the System.Diagnostics namespace contains a class called Switch, a call to the Switch function must be qualified with the Microsoft.VisualBasic namespace.
 *
 * @see Choose Choose Function
 * @see IIf IIf Function
 */
function Object Switch(ByVal ParamArray VarExpr() As Object);

/**
 * Returns a Double specifying the sum-of-years digits depreciation of an asset for a specified period.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The Life and Period arguments must be expressed in the same units. For example, if Life is given in months, Period must also be given in months. All arguments must be positive numbers.
 *
 * @param Cost    Required. Double specifying initial cost of the asset.
 * @param Salvage Required. Double specifying value of the asset at the end of its useful life.
 * @param Life    Required. Double specifying length of the useful life of the asset.
 * @param Period  Required. Double specifying period for which asset depreciation is calculated.
 *
 * @exception ArgumentException   Salvage < 0, Period > Life, or Period <=0.
 *
 * @example
 * This example uses the SYD function to return the depreciation of an asset for a specified period given the asset's initial cost (InitCost), the salvage value at the end of the asset's useful life (SalvageVal), and the total life of the asset in years (LifeTime). The period in years for which the depreciation is calculated is PDepr.
 *
 * <pre>
 * Sub TestSYD()
 *   Dim InitCost, SalvageVal, MonthLife, DepYear, LifeTime, Pdepr As Double
 *   Dim Fmt As String = "###,##0.00"   ' Define money format.
 *   Const YEARMONTHS As Integer = 12  ' Number of months in a year.
 *   InitCost = CDbl(InputBox("What's the initial cost of the asset?"))
 *   SalvageVal = CDbl(InputBox("What's the asset's value at the end of its life?"))
 *   MonthLife = CDbl(InputBox("What's the asset's useful life in months?"))
 *   Do While MonthLife < YEARMONTHS   ' Ensure period is >= 1 year.
 *     MsgBox("Asset life must be a year or more.")
 *     MonthLife = CDbl(InputBox("What's the asset's useful life in months?"))
 *   Loop
 *   LifeTime = MonthLife / YEARMONTHS   ' Convert months to years.
 *   If LifeTime <> Int(MonthLife / YEARMONTHS) Then
 *     LifeTime = Int(LifeTime + 1)   ' Round up to nearest year.
 *   End If
 *   DepYear = CInt(InputBox("For which year do you want depreciation?"))
 *   Do While DepYear < 1 Or DepYear > LifeTime
 *     MsgBox("You must enter at least 1 but not more than " & LifeTime)
 *     DepYear = CInt(InputBox("For what year do you want depreciation?"))
 *   Loop
 *   Pdepr = SYD(InitCost, SalvageVal, LifeTime, DepYear)
 *   MsgBox("The depreciation for year " & DepYear & " is " & Format(Pdepr, Fmt) & ".")
 * End Sub
 * </pre>
 *
 * @see DDB DDB Function
 * @see IRR IRR Function
 * @see MIRR MIRR Function
 * @see NPer NPer Function
 * @see NPV NPV Function
 * @see PPmt PPmt Function
 * @see Rate Rate Function
 * @see SLN SLN Function
 */
function Double SYD(
   ByVal Cost As Double,
   ByVal Salvage As Double,
   ByVal Life As Double,
   ByVal Period As Double
);

/**
 * Returns a String value containing the system data type name of a variable.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * SystemTypeName returns the fully qualified common language runtime type name corresponding to the Visual Basic type name. For example, if VbName contains "Date", SystemTypeName returns "System.DateTime". If SystemTypeName does not recognize the value of VbName, it returns Nothing (not the string "Nothing").
 *
 * @example
 * This example uses the SystemTypeName function to return data type names for several variables.
 *
 * <pre>
 * Dim VbLongName As String = "Long"
 * Dim VbDateName As String = "Date"
 * Dim VbBadName As String = "Number"
 * Dim MySysName As String
 * MySysName = SystemTypeName(VbLongName)   ' Returns "System.Int64".
 * MySysName = SystemTypeName(VbDateName)   ' Returns "System.DateTime".
 * MySysName = SystemTypeName(VbBadName)   ' Returns Nothing.
 * </pre>
 *
 */
function String SystemTypeName(ByVal VbName As String);

/**
 * Used with the Print or PrintLine functions to position output.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If the current print position on the current line is greater than Column, TAB skips to the column value equal to Column on the next output line. If Column is less than 1, TAB moves the print position to column 1. If Column is greater than the output line width, TAB calculates the next print position using the formula:
 *
 * <pre>
 * Column Mod width
 * </pre>
 *
 * For example, if width is 80 and you specify TAB(90), the next print will start at column 10 (the remainder of 90/80). If Column is less than the current print position, printing begins on the next line at the calculated print position. If the calculated print position is greater than the current print position, printing begins at the calculated print position on the same line.
 * <P>
 * The leftmost print position on an output line is always 1. When you use the Print or PrintLine functions to print to files, the rightmost print position is the current width of the output file, which you can set using the FileWidth function.
 * <P>
 * Note   Make sure your tabular columns are wide enough to accommodate wide letters.
 *
 * @param Column  Optional. The column number moved to before displaying or printing the next expression in a list. If omitted, TAB moves the insertion point to the beginning of the next print zone.
 *
 * @example
 * This example uses the TAB function to position output in a file and in the Output window.
 *
 * <pre>
 * FileOpen(1, "TESTFILE", OpenMode.Output) ' Open file for output.
 * ' The second word prints at column 20.
 * Print(1, "Hello", TAB(20), "World.")
 * ' If the argument is omitted, cursor is moved to the next print zone.
 * Print(1, "Hello", TAB(), "World")
 * FileClose(1)
 * </pre>
 *
 * The TAB function can also be used with the WriteLine method. The following statement prints text starting at column 10.
 *
 * <pre>
 * Debug.WriteLine(TAB(10), "10 columns from start.")
 * </pre>
 *
 * @see Print Print Function
 * @see PrintLine PrintLine Function
 * @see Space Space Function
 * @see SPC SPC Function
 * @see FileWidth FileWidth Function
 */
function TABInfo TAB();

/**
 * Used with the Print or PrintLine functions to position output.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If the current print position on the current line is greater than Column, TAB skips to the column value equal to Column on the next output line. If Column is less than 1, TAB moves the print position to column 1. If Column is greater than the output line width, TAB calculates the next print position using the formula:
 *
 * <pre>
 * Column Mod width
 * </pre>
 *
 * For example, if width is 80 and you specify TAB(90), the next print will start at column 10 (the remainder of 90/80). If Column is less than the current print position, printing begins on the next line at the calculated print position. If the calculated print position is greater than the current print position, printing begins at the calculated print position on the same line.
 * <P>
 * The leftmost print position on an output line is always 1. When you use the Print or PrintLine functions to print to files, the rightmost print position is the current width of the output file, which you can set using the FileWidth function.
 * <P>
 * Note   Make sure your tabular columns are wide enough to accommodate wide letters.
 *
 * @param Column  Optional. The column number moved to before displaying or printing the next expression in a list. If omitted, TAB moves the insertion point to the beginning of the next print zone.
 *
 * @example
 * This example uses the TAB function to position output in a file and in the Output window.
 *
 * <pre>
 * FileOpen(1, "TESTFILE", OpenMode.Output) ' Open file for output.
 * ' The second word prints at column 20.
 * Print(1, "Hello", TAB(20), "World.")
 * ' If the argument is omitted, cursor is moved to the next print zone.
 * Print(1, "Hello", TAB(), "World")
 * FileClose(1)
 * </pre>
 *
 * The TAB function can also be used with the WriteLine method. The following statement prints text starting at column 10.
 *
 * <pre>
 * Debug.WriteLine(TAB(10), "10 columns from start.")
 * </pre>
 *
 * @see Print Print Function
 * @see PrintLine PrintLine Function
 * @see Space Space Function
 * @see SPC SPC Function
 * @see FileWidth FileWidth Function
 */
function TABInfo TAB(ByVal Column As Short);

/**
 * Returns the tangent of the specified angle.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The angle, a, must be in radians. Multiply by p/180 to convert degrees to radians.
 *
 * @param a  An angle, measured in radians.
 *
 * @return The tangent of a. If a is equal to NaN, NegativeInfinity, or PositiveInfinity, this method returns NaN.
 */
function Double Tan(ByVal a As Double);

/**
 * Returns a Date value representing a specified hour, minute, and second, with the date information set relative to January 1 of the year 1.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The following example demonstrates negative, zero, and positive argument values. Here, the TimeSerial function returns a time representing 15 minutes before three hours before noon, or 8:45:00 A.M.:
 *
 * <pre>
 * Dim AlarmTime As Date = TimeSerial(12 - 3, -15, 0)
 * </pre>
 *
 * If either Minute or Second exceeds its normal range, it is applied to the next larger unit as appropriate. For example, if you specify 75 minutes, it is evaluated as one hour and 15 minutes. If any argument is outside the range -2,147,483,648 through 2,147,483,647, an ArgumentException error occurs.
 * <P>
 * TimeSerial reduces the total seconds modulo 86,400, which is the number of seconds in a day. Therefore, the returned time is always between 00:00:00 and 23:59:59.
 * <P>
 * The Date data type includes date components. TimeSerial sets all of these to 1, so the returned value represents the first day of the year 1. However, if the values of the arguments cause the calculated time to exceed 24 hours, the day is incremented as necessary. In the following example, the values of Hour and Minute result in a combined time of more than 24 hours.
 *
 * <pre>
 * MsgBox(TimeSerial(23, 75, 0))  ' Displays "1/2/0001 12:15:00 AM"
 * </pre>
 *
 * If the values of the arguments result in a negative calculated time, the date information is set to 1/1/0001 and the time information is adjusted to be between 00:00:00 and 23:59:59. However, if the calculated time is less than negative 24 hours, an ArgumentOutOfRangeException error occurs.
 * <P>
 * Since every Date value is supported by a DateTime structure, its methods give you additional options in assembling a Date value. For example, you can employ one of the overloaded DateTime constructors to populate a Date variable using the desired combination of components. The following example sets NewDateTime to May 6, 1978 at one tenth of a second before 8:30 in the morning:
 *
 * <pre>
 * Dim NewDateTime As Date = New Date(1978, 5, 6, 8, 29, 59, 900)
 * </pre>
 *
 * @param Hour      Required. Integer expression from 0 through 23. However, values outside this range are also accepted.
 * @param Minute    Required. Integer expression from 0 through 59. However, values outside this range are also accepted. The value of Minute is added to the calculated hour, so a negative value specifies minutes before that hour.
 * @param Second    Required. Integer expression from 0 through 59. However, values outside this range are also accepted. The value of Second is added to the calculated minute, so a negative value specifies seconds before that minute.
 *
 * @exception ArgumentException   Argument is outside the range -2,147,483,648 through 2,147,483,647
 * @exception ArgumentOutOfRangeException   Calculated time is less than negative 24 hours.
 *
 * @example
 * This example uses the TimeSerial function to return a time for the specified hour, minute, and second.
 *
 * <pre>
 * Dim MyTime As Date
 * MyTime = TimeSerial(16, 35, 17)   ' Return the time in a Date data type.
 * </pre>
 *
 * @see DateSerial DateSerial Function
 * @see DateValue DateValue Function
 * @see Hour Hour Function
 * @see Minute Minute Function
 * @see Second Second Function
 * @see TimeValue TimeValue Function
 */
function DateTime TimeSerial(
   ByVal Hour As Integer,
   ByVal Minute As Integer,
   ByVal Second As Integer
);

/**
 * Returns a Date value containing the time information represented by a string, with the date information set to January 1 of the year 1.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * You can enter valid times using a 12-hour or 24-hour clock. For example, "2:24 P.M." and "14:24" are both valid StringTime arguments.
 * <P>
 * If the StringTime argument includes date information, TimeValue does not include it in the returned value. However, if StringTime includes invalid time information such as "January 32," an InvalidCastException error occurs.
 *
 * @example
 * This example uses the TimeValue function to convert a string to a time. You can also use date literals to directly assign a time to a Date variable.
 *
 * <pre>
 * Dim MyTime As Date
 * MyTime = TimeValue("4:35:17 PM")   ' Return the time in a Date data type.
 * MyTime = TimeValue(#4:35:17 PM#)   ' Return the time in a Date data type.
 * </pre>
 *
 * @see DateSerial DateSerial Function
 * @see DateValue DateValue Function
 * @see Hour Hour Function
 * @see Minute Minute Function
 * @see Second Second Function
 * @see TimeSerial TimeSerial Function
 */
function DateTime TimeValue(ByVal StringTime As String);

/**
 * Returns a String value containing data type information about a variable.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The following table shows the String values returned by TypeName for different contents of VarName.
 *
 * <pre>
 * VarName contents                                         String returned
 * 16-bit True or False value type                          "Boolean"
 * 8-bit binary value type                                  "Byte"
 * 16-bit character value type                              "Char"
 * 64-bit date and time value type                          "Date"
 * Reference type indicating missing or nonexistent data    "DBNull"
 * 128-bit fixed point numeric value type                   "Decimal"
 * 64-bit floating point numeric value type                 "Double"
 * 32-bit integer value type                                "Integer"
 * Reference type pointing to an unspecialized object       "Object"
 * Reference type pointing to a specialized object created  "<objectclass>"
 * from class <objectclass>
 * 64-bit integer value type                                "Long"
 * Reference type with no object currently assigned to it   "Nothing"
 * 16-bit integer value type                                "Short"
 * 32-bit floating point numeric value type                 "Single"
 * Reference type pointing to a string of 16-bit characters "String"
 * </pre>
 *
 * <P>
 * If VarName is an array, the returned string can be any one of the strings in the preceding table with empty parentheses appended. For example, if VarName points to an array of integers, TypeName returns "Integer()".
 * <P>
 * When TypeName returns the name of a reference type such as a class, it only returns the simple name, not the qualified name. For example, if VarName points to an object of class System.Drawing.Printing.PaperSource, TypeName returns "PaperSource".
 *
 * @param VarName  Required. Object variable. If Option Strict is Off, you can pass a variable of any data type except a structure.
 *
 * @example
 * This example uses the TypeName function to return data type information about several variables.
 *
 * <pre>
 * Dim MyType As String
 * Dim StrVar As String = "MyString"
 * Dim DecVar As Decimal
 * Dim IntVar, ArrayVar(5) As Integer
 * MyType = TypeName(StrVar)   ' Returns "String".
 * MyType = TypeName(IntVar)   ' Returns "Integer".
 * MyType = TypeName(ArrayVar)   ' Returns "Integer()".
 * </pre>
 *
 * @see IsArray IsArray Function
 * @see IsDate IsDate Function
 * @see IsDBNull IsDBNull Function
 * @see IsError IsError Function
 * @see IsNothing IsNothing Function
 * @see IsNumeric IsNumeric Function
 * @see IsReference IsReference Function
 */
function String TypeName(ByVal VarName As Object);

/**
 * Returns the highest available subscript for the indicated dimension of an array.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * Since array subscripts start at 0, the length of a dimension is greater by one than the highest available subscript for that dimension.
 * <P>
 * For an array with the following dimensions, UBound returns the values in the following table:
 *
 * <pre>
 * Dim A(100, 5, 4) As Byte
 *
 * Call to UBound     Return value
 * UBound(A, 1)       100
 * UBound(A, 2)       5
 * UBound(A, 3)       4
 * </pre>
 *
 * You can use UBound to determine the total number of elements in an array, but you must adjust the value it returns to account for the fact that the subscripts start at 0. The following example calculates the total size of the array A in the preceding example:
 *
 * <pre>
 * Dim Total As Integer
 * Total = (UBound(A, 1) + 1) * (UBound(A, 2) + 1) * (UBound(A, 3) + 1)
 * </pre>
 *
 * The value calculated for Total is 3030, which is 101 * 6 * 5.
 *
 * @param Array  Required. Array of any data type. The array in which you want to find the highest possible subscript of a dimension.
 * @param Rank   Optional. Integer. The dimension for which the highest possible subscript is to be returned. Use 1 for the first dimension, 2 for the second, and so on. If Rank is omitted, 1 is assumed.
 *
 * @exception ArgumentNullException   Array is Nothing
 * @exception RankException   Rank is less than 1 or Rank is greater than the rank of array
 *
 * @see LBound LBound Function
 */
function Integer UBound(
   ByVal Array As System.Array,
   Optional ByVal Rank As Integer = 1
);

/**
 * Returns a string or character containing the specified string converted to uppercase.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * Only lowercase letters are converted to uppercase; all uppercase letters and nonletter characters remain unchanged.
 *
 * @param Value  Required. Any valid String or Char expression.
 *
 * @example
 * This example uses the UCase function to return an uppercase version of a string.
 *
 * <pre>
 * Dim LowerCase, UpperCase As String
 * LowerCase = "Hello World 1234"   ' String to convert.
 * UpperCase = UCase(LowerCase)   ' Returns "HELLO WORLD 1234".
 * </pre>
 *
 * @see LCase LCase Function
 */
function Char UCase(ByVal Value As Char);

/**
 * Returns a string or character containing the specified string converted to uppercase.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * Only lowercase letters are converted to uppercase; all uppercase letters and nonletter characters remain unchanged.
 *
 * @param Value  Required. Any valid String or Char expression.
 *
 * @example
 * This example uses the UCase function to return an uppercase version of a string.
 *
 * <pre>
 * Dim LowerCase, UpperCase As String
 * LowerCase = "Hello World 1234"   ' String to convert.
 * UpperCase = UCase(LowerCase)   ' Returns "HELLO WORLD 1234".
 * </pre>
 *
 * @see LCase LCase Function
 */
function String UCase(ByVal Value As String);

/**
 * Returns the numbers contained in a string as a numeric value of appropriate type.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The Val function stops reading the string at the first character it cannot recognize as part of a number. Symbols and characters that are often considered parts of numeric values, such as dollar signs and commas, are not recognized. However, the function recognizes the radix prefixes &O (for octal) and &H (for hexadecimal). Blanks, tabs, and linefeed characters are stripped from the argument.
 * <P>
 * The following returns the value 1615198:
 *
 * <pre>
 * Val(" 1615 198th Street N.E.")
 * </pre>
 *
 * In the code below, Val returns the decimal value -1 for the hexadecimal value shown:
 *
 * <pre>
 * Val("&HFFFF")
 * </pre>
 *
 * Note   The Val function recognizes only the period (.) as a valid decimal separator. When different decimal separators are used, as in international applications, use CDbl or CInt instead to convert a string to a number.
 *
 * @param Expression  Required. Any valid String expression, Object variable, or Char value. If Expression is of type Object, its value must be convertible to String or an ArgumentException error occurs.
 *
 * @exception OverflowException   InputStr is too large.
 * @exception InvalidCastException   Number is badly formed.
 * @exception ArgumentException   Object type expression not convertible to String.
 *
 * @example
 * This example uses the Val function to return the numbers contained in each string. Val stops converting at the first character that cannot be interpreted as a numeric digit, numeric modifier, numeric punctuation, or white space.
 *
 * <pre>
 * Dim ValResult As Double
 * ValResult = Val("2457")    ' ValResult is set to 2457.
 * ValResult = Val(" 2 45 7")    ' ValResult is set to 2457.
 * ValResult = Val("24 and 57")    ' ValResult is set to 24.
 * </pre>
 *
 * @see Str Str Function
 */
function Double Val(ByVal Expression As String);

/**
 * Returns the numbers contained in a string as a numeric value of appropriate type.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The Val function stops reading the string at the first character it cannot recognize as part of a number. Symbols and characters that are often considered parts of numeric values, such as dollar signs and commas, are not recognized. However, the function recognizes the radix prefixes &O (for octal) and &H (for hexadecimal). Blanks, tabs, and linefeed characters are stripped from the argument.
 * <P>
 * The following returns the value 1615198:
 *
 * <pre>
 * Val(" 1615 198th Street N.E.")
 * </pre>
 *
 * In the code below, Val returns the decimal value -1 for the hexadecimal value shown:
 *
 * <pre>
 * Val("&HFFFF")
 * </pre>
 *
 * Note   The Val function recognizes only the period (.) as a valid decimal separator. When different decimal separators are used, as in international applications, use CDbl or CInt instead to convert a string to a number.
 *
 * @param Expression  Required. Any valid String expression, Object variable, or Char value. If Expression is of type Object, its value must be convertible to String or an ArgumentException error occurs.
 *
 * @exception OverflowException   InputStr is too large.
 * @exception InvalidCastException   Number is badly formed.
 * @exception ArgumentException   Object type expression not convertible to String.
 *
 * @example
 * This example uses the Val function to return the numbers contained in each string. Val stops converting at the first character that cannot be interpreted as a numeric digit, numeric modifier, numeric punctuation, or white space.
 *
 * <pre>
 * Dim ValResult As Double
 * ValResult = Val("2457")    ' ValResult is set to 2457.
 * ValResult = Val(" 2 45 7")    ' ValResult is set to 2457.
 * ValResult = Val("24 and 57")    ' ValResult is set to 24.
 * </pre>
 *
 * @see Str Str Function
 */
function Double Val(ByVal Expression As Object);

/**
 * Returns the numbers contained in a string as a numeric value of appropriate type.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The Val function stops reading the string at the first character it cannot recognize as part of a number. Symbols and characters that are often considered parts of numeric values, such as dollar signs and commas, are not recognized. However, the function recognizes the radix prefixes &O (for octal) and &H (for hexadecimal). Blanks, tabs, and linefeed characters are stripped from the argument.
 * <P>
 * The following returns the value 1615198:
 *
 * <pre>
 * Val(" 1615 198th Street N.E.")
 * </pre>
 *
 * In the code below, Val returns the decimal value -1 for the hexadecimal value shown:
 *
 * <pre>
 * Val("&HFFFF")
 * </pre>
 *
 * Note   The Val function recognizes only the period (.) as a valid decimal separator. When different decimal separators are used, as in international applications, use CDbl or CInt instead to convert a string to a number.
 *
 * @param Expression  Required. Any valid String expression, Object variable, or Char value. If Expression is of type Object, its value must be convertible to String or an ArgumentException error occurs.
 *
 * @exception OverflowException   InputStr is too large.
 * @exception InvalidCastException   Number is badly formed.
 * @exception ArgumentException   Object type expression not convertible to String.
 *
 * @example
 * This example uses the Val function to return the numbers contained in each string. Val stops converting at the first character that cannot be interpreted as a numeric digit, numeric modifier, numeric punctuation, or white space.
 *
 * <pre>
 * Dim ValResult As Double
 * ValResult = Val("2457")    ' ValResult is set to 2457.
 * ValResult = Val(" 2 45 7")    ' ValResult is set to 2457.
 * ValResult = Val("24 and 57")    ' ValResult is set to 24.
 * </pre>
 *
 * @see Str Str Function
 */
function Integer Val(ByVal Expression As Char);

/**
 * Returns an Integer value containing the data type classification of a variable.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The integer value returned by VarType is a member of the VariantType enumeration.
 * <P>
 * The following table shows the values returned by VarType for special cases of VarName.
 *
 * <pre>
 * Data type represented by VarName          Value returned by VarType
 * Nothing                                   VariantType.Object
 * DBNull                                    VariantType.Null
 * Enumeration                               Underlying data type (Byte, Short, Integer, or Long)
 * Array                                     Bitwise OR of array element type and VariantType.Array
 * Array of arrays                           Bitwise OR of VariantType.Object and VariantType.Array
 * Structure (System.ValueType)              VariantType.UserDefinedType
 * System.Exception                          VariantType.Error
 * Unknown                                   VariantType.Object
 * </pre>
 *
 * @param VarName  Required. Object variable. If Option Strict is Off, you can pass a variable of any data type except a structure.
 *
 * @example
 * This example uses the VarType function to return data type classification information about several variables.
 *
 * <pre>
 * Dim MyString As String = "MyString"
 * Dim MyObject As Object
 * Dim MyNumber, MyArray(5) As Integer
 * Dim MyVarType As VariantType   ' Integer enumeration.
 * MyVarType = VarType(MyVarType)   ' Returns VariantType.Integer.
 * MyVarType = VarType(MyString)   ' Returns VariantType.String.
 * MyVarType = VarType(MyObject)   ' Returns VariantType.Object.
 * MyVarType = VarType(MyArray)   ' Returns the bitwise OR of VariantType.Array and VariantType.Integer.
 * </pre>
 */
function VariantType VarType(ByVal VarName As Object);

/**
 * Returns a String value containing the Visual Basic data type name of a variable.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * VbTypeName returns the Visual Basic .NET type name corresponding to the common language runtime type name. For example, if UrtName contains "Int32" or "System.Int32", VbTypeName returns "Integer". If VbTypeName does not recognize the value of UrtName, it returns Nothing (not the string "Nothing").
 * <P>
 * The type name in UrtName can be obtained from various sources, for example from the Name property of the System.Type class.
 *
 * @example
 * This example uses the VbTypeName function to return data type names for several variables.
 *
 * <pre>
 * Dim SysDateName As String = "System.DateTime"
 * Dim SysShortName As String = "Int16"
 * Dim SysBadName As String = "Nonsense"
 * Dim MyVbName As String
 * MyVbName = VbTypeName(SysDateName)   ' Returns "Date".
 * MyVbName = VbTypeName(SysShortName)   ' Returns "Short".
 * MyVbName = VbTypeName(SysBadName)   ' Returns Nothing.
 * </pre>
 */
function String VbTypeName(ByVal UrtName As String);

/**
 * Returns an Integer value containing a number representing the day of the week.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The value returned by the Weekday function corresponds to the values of the FirstDayOfWeek enumeration; that is, 1 indicates Sunday and 7 indicates Saturday.
 * <P>
 * If DayOfWeek is less than 0 or more than 7, an ArgumentException error occurs.
 * <P>
 * Note   Weekday uses the current calendar setting from the CurrentCulture property of the CultureInfo class in the System.Globalization namespace. The default CurrentCulture values are determined by Control Panel settings.
 *
 * <P>
 * <b>Settings</b>
 * <P>
 * The DayOfWeek argument can have one of the following settings.
 *
 * <pre>
 * Enumeration value         Value  Description
 * FirstDayOfWeek.System       0    First day of week specified in system settings
 * FirstDayOfWeek.Sunday       1    Sunday (default)
 * FirstDayOfWeek.Monday       2    Monday (complies with ISO standard 8601, section 3.17)
 * FirstDayOfWeek.Tuesday      3    Tuesday
 * FirstDayOfWeek.Wednesday    4    Wednesday
 * FirstDayOfWeek.Thursday     5    Thursday
 * FirstDayOfWeek.Friday       6    Friday
 * FirstDayOfWeek.Saturday     7    Saturday
 * </pre>
 *
 * @param DateValue  Required. Date value for which you want to determine the day of the week.
 * @param DayOfWeek  Optional. A value chosen from the FirstDayOfWeek enumeration that specifies the first day of the week. If not specified, FirstDayOfWeek.Sunday is used.
 *
 * @exception ArgumentException   DayOfWeek is less than 0 or more than 7.
 *
 * @example
 * This example uses the Weekday function to obtain the day of the week >from a specified date.
 *
 * <pre>
 * Dim MyDate As Date
 * Dim MyWeekDay As Integer
 * MyDate = #2/12/1969#   ' Assign a date.
 * MyWeekDay = Weekday(MyDate)   ' MyWeekDay contains 4 because
 * ' MyDate represents a Wednesday.
 * </pre>
 *
 * @see Day Day Function
 * @see Month Month Function
 * @see WeekdayName WeekdayName Function
 * @see Year  Year Function
 * @see DatePart DatePart Function
 */
function Integer Weekday(
   ByVal DateValue As DateTime,
   Optional ByVal DayOfWeek As FirstDayOfWeek = FirstDayOfWeek.Sunday
);

/**
 * Returns a String value containing the name of the specified weekday.
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * The string returned by WeekdayName depends not only on the input arguments, but also on the Regional Options settings specified in the Windows Control Panel.
 * <P>
 * If WeekDay is less than 1 or more than 7, or if FirstDayOfWeekValue is less than 0 or more than 7, an ArgumentException error occurs.
 * <P>
 * Note   WeekdayName uses the current calendar setting from the CurrentCulture property of the CultureInfo class in the System.Globalization namespace. The default CurrentCulture values are determined by Control Panel settings.
 *
 * <P>
 * <b>Settings</b>
 * <P>
 * The FirstDayOfWeekValue argument can have one of the following settings.
 *
 * <pre>
 * Enumeration value         Value  Description
 * FirstDayOfWeek.System       0    First day of week specified in system settings (default)
 * FirstDayOfWeek.Sunday       1    Sunday
 * FirstDayOfWeek.Monday       2    Monday (complies with ISO standard 8601, section 3.17)
 * FirstDayOfWeek.Tuesday      3    Tuesday
 * FirstDayOfWeek.Wednesday    4    Wednesday
 * FirstDayOfWeek.Thursday     5    Thursday
 * FirstDayOfWeek.Friday       6    Friday
 * FirstDayOfWeek.Saturday     7    Saturday
 * </pre>
 *
 * @param WeekDay              Required. Integer. The numeric designation for the weekday, from 1 through 7; 1 indicates the first day of the week and 7 indicates the last day of the week. The identities of the first and last days depend on the setting of FirstDayOfWeekValue.
 * @param Abbreviate           Optional. Boolean value that indicates if the weekday name is to be abbreviated. If omitted, the default is False, which means the weekday name is not abbreviated.
 * @param FirstDayOfWeekValue  Optional. A value chosen from the FirstDayOfWeek enumeration that specifies the first day of the week. If not specified, FirstDayOfWeek.System is used.
 *
 * @exception ArgumentException   WeekDay is less than 1 or greater than 7, or FirstDayOfWeekValue is less than 0 or greater than 7.
 *
 * @see MonthName MonthName Function
 */
function String WeekdayName(
   ByVal WeekDay As Integer,
   Optional ByVal Abbreviate As Boolean = False,
   Optional ByVal FirstDayOfWeekValue As FirstDayOfWeek = FirstDayOfWeek.System
);

/**
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If you omit Output, a blank line is printed to the file. Multiple expressions can be separated with a comma.
 * <P>
 * Unlike the Print function, the Write function inserts commas between items and quotation marks around strings as they are written to the file. You don't have to put explicit delimiters in the list. When Write is used to write data to a file, only the following data formats are supported and several universal assumptions are followed so the data can always be read and correctly interpreted using Input, regardless of locale:
 *
 * <UL>
 * <LI>Numeric data is always written using the period as the decimal separator.
 * <LI>For Boolean data, either #TRUE# or #FALSE# is printed. The True and False keywords are not translated, regardless of locale.
 * <LI>Date data is written to the file using the universal date format. When either the date or the time component is missing or zero, only the part provided gets written to the file.
 * <LI>Nothing is written to the file if Output data is empty. However, for null data, #NULL# is written.
 * <LI>For Error data, the output appears as #ERROR errorcode#. The Error keyword is not translated, regardless of locale.
 * <LI>WriteLine inserts a newline character (that is, a carriage returnlinefeed, or Chr(13) + Chr(10)), after it has written the final character in Output to the file.
 * </UL>
 *
 * <b>Note</b>   You should not write strings that contain embedded quotation marks for use with the Input function (for example, "1,2""X"): the Input function parses this string as two complete and separate strings.
 *
 * @param FileNumber  Required. An Integer expression containing any valid file number.
 * @param Output      Optional. One or more comma-delimited expressions to write to a file.
 *
 * @exception IOException   FileNumber does not exist.
 * @exception IOException   File mode is invalid.
 *
 * @example
 * This example uses the Write function to write raw data to a sequential file.
 *
 * <pre>FileOpen(1, "TESTFILE", OpenMode.Output) ' Open file for output.
 * Write(1, "This is a test.")  ' Print text to file.
 * WriteLine(1)  ' Print blank line to file.
 * WriteLine(1, "Zone 1", TAB(), "Zone 2")   ' Print in two print zones.
 * WriteLine(1, "Hello", " ", "World")     ' Separate strings with space.
 * WriteLine(1, SPC(5), "5 leading spaces ")    ' Print five leading spaces.
 * WriteLine(1, TAB(10), "Hello")   ' Print word at column 10.
 *
 * ' Assign Boolean, Date, and Error values.
 * Dim aBool As Boolean
 * Dim aDate As DateTime
 * aBool = False
 * aDate = DateTime.Parse("February 12, 1969")
 *
 * ' Dates and Booleans are translated using locale settings of
 * ' your system.
 * WriteLine(1, aBool, " is a Boolean value")
 * WriteLine(1, aDate, " is a date")
 * FileClose(1)   ' Close file.
 * </pre>
 *
 * @see Input Input Function
 * @see FileOpen FileOpen Function
 * @see Print Print Function
 * @see PrintLine PrintLine Function
 */
procedure Write(
   ByVal FileNumber As Integer,
   ByVal ParamArray Output As Object
);

/**
 *
 * <P>
 * <b>Remarks</b>
 * <P>
 * If you omit Output, a blank line is printed to the file. Multiple expressions can be separated with a comma.
 * <P>
 * Unlike the Print function, the Write function inserts commas between items and quotation marks around strings as they are written to the file. You don't have to put explicit delimiters in the list. When Write is used to write data to a file, only the following data formats are supported and several universal assumptions are followed so the data can always be read and correctly interpreted using Input, regardless of locale:
 *
 * <UL>
 * <LI>Numeric data is always written using the period as the decimal separator.
 * <LI>For Boolean data, either #TRUE# or #FALSE# is printed. The True and False keywords are not translated, regardless of locale.
 * <LI>Date data is written to the file using the universal date format. When either the date or the time component is missing or zero, only the part provided gets written to the file.
 * <LI>Nothing is written to the file if Output data is empty. However, for null data, #NULL# is written.
 * <LI>For Error data, the output appears as #ERROR errorcode#. The Error keyword is not translated, regardless of locale.
 * <LI>WriteLine inserts a newline character (that is, a carriage returnlinefeed, or Chr(13) + Chr(10)), after it has written the final character in Output to the file.
 * </UL>
 *
 * <b>Note</b>   You should not write strings that contain embedded quotation marks for use with the Input function (for example, "1,2""X"): the Input function parses this string as two complete and separate strings.
 *
 * @param FileNumber  Required. An Integer expression containing any valid file number.
 * @param Output      Optional. One or more comma-delimited expressions to write to a file.
 *
 * @exception IOException   FileNumber does not exist.
 * @exception IOException   File mode is invalid.
 *
 * @example
 * This example uses the Write function to write raw data to a sequential file.
 *
 * <pre>FileOpen(1, "TESTFILE", OpenMode.Output) ' Open file for output.
 * Write(1, "This is a test.")  ' Print text to file.
 * WriteLine(1)  ' Print blank line to file.
 * WriteLine(1, "Zone 1", TAB(), "Zone 2")   ' Print in two print zones.
 * WriteLine(1, "Hello", " ", "World")     ' Separate strings with space.
 * WriteLine(1, SPC(5), "5 leading spaces ")    ' Print five leading spaces.
 * WriteLine(1, TAB(10), "Hello")   ' Print word at column 10.
 *
 * ' Assign Boolean, Date, and Error values.
 * Dim aBool As Boolean
 * Dim aDate As DateTime
 * aBool = False
 * aDate = DateTime.Parse("February 12, 1969")
 *
 * ' Dates and Booleans are translated using locale settings of
 * ' your system.
 * WriteLine(1, aBool, " is a Boolean value")
 * WriteLine(1, aDate, " is a date")
 * FileClose(1)   ' Close file.
 * </pre>
 *
 * @see Input Input Function
 * @see FileOpen FileOpen Function
 * @see Print Print Function
 * @see PrintLine PrintLine Function
 */
procedure WriteLine(
   ByVal FileNumber As Integer,
   ByVal ParamArray Output() As Object
)

/**
 * Returns an Integer value from 1 through 9999 representing the year.
 *
 * @param DateValue Required. Date value from which you want to extract the year.
 * <P>
 * You can also obtain the year by calling DatePart and specifying DateInterval.Year for the Interval argument.
 *
 * @example
 * This example uses the Year function to obtain the year from a specified date. In the development environment, the date literal is displayed in short date format using the locale settings of your code.
 *
 * <pre>
 * Dim MyDate As Date
 * Dim MyYear As Integer
 * MyDate = #2/12/1969#   ' Assign a date.
 * MyYear = Year(MyDate)   ' MyYear contains 1969.
 * </pre>
 *
 * @see Day Day Function
 * @see Month Month Function
 * @see Weekday Weekday Function
 * @see DatePart DatePart Function
 */
function Integer Year(ByVal DateValue As DateTime);
