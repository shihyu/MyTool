/* Assembler Instruction statements */
/**
 * *PROCESS
 * <br>Allows Assembler options to be specified at the beginning of the
 * program source code.  Up to 10 *PROCESS statements may be placed at
 * the beginning of a source code file.  *PROCESS statements may not be
 * continued.
 * Any Assembler option except the following may be
 * specified.
 * ADATA, LANGUAGE, SIZE, ASA, LINECOUNT, SYSPARM, DECK, LIST, TERM,
 * EXIT, OBJECT, TRANSLATE, GOFF, OPTABLE, XOBJECT
 * @example *PROCESS option1,option2  </code>
 */
procedure void "*PROCESS" (option1,option2,...) ;
/**
 * ACONTROL
 * <br>Allows the AFPR, COMPAT, FLAG (except the RECORD/NORECORD
 * suboption), LIBMAC, and RA2 HLASM option to be changed.
 * @example [seqsymbol] ACONTROL selection1,selection2  </code>
 * @see seqsymbol
 */
procedure void ACONTROL (selection,selection,...) ;
/**
 * ADATA
 * <br>Causes the Assembler to write records to the SYSADATA file.
 * @example <code> [seqsymbol] ADATA value1,value2,value3,value4,character-string  </code>
 * @param value1 - value4 If specified, value1 through value4 must be a
 * decimal self-defining term with a value
 * in the range -2**31 to +2**31-1.  If omitted, the separator
 * comma must be present.
 * @param character-string string up to 255 characters long
 * @see seqsymbol
 */
procedure void ADATA (value1,value2,value3,value4,character-string) ;
/**
 * AINSERT
 * <br>Inserts statements into the input stream. These
 * statements are queued in an internal buffer until the macro generator has
 * completed. At that point the internal buffer queue provides the next
 * statement. The statement is placed at the front or back of the input stream
 * depending on the 2nd operand.
 * <br>Note: While inserted statements may be placed at either end of the buffer
 * queue, the statements are removed only from the front of the buffer queue.
 * @example <code> [seqsymbol] AINSERT '         END',BACK</code>
 * @param statement 80-byte quoted statement
 * @param loc FRONT or BACK to control where in the queue the statement is placed.
 * @see seqsymbol
 */
procedure void AINSERT ('statement',loc) ;
/**
 * ALIAS
 * <br> Specifies alternate names for the external symbols that identify control
 * sections, entry points, and external references.
 * @example <code>EXTSYM1  ALIAS  C'extsym1'
           <br>  EXTSYM2  ALIAS  X'85A7A3A2A894F2' </code>
 * @param name an external symbol
 * @param alias an alternate name for the external symbol.  Each character
 * must have hex value x'42'-x'FE'
 */
procedure void ALIAS (name,alias) ;
/**
 * AMODE
 * <br>
 * @example <code> [seqsymbol] AINSERT '         END',BACK</code>
 * @param statement 80-byte quoted statement
 * @param loc FRONT or BACK to control where in the queue the statement is placed.
 * @see seqsymbol
 */
procedure void AMODE ('statement',loc);
/**
 * CATTR  (Requires XOBJECT Assembler option, MVS or CMS only)
 * <br>Establishes a program object external class name, and assigns
 * binder attributes for the class.
 * @example <code> class_name CATTR NOTEXECUTABLE</code>
 * @param class_name less than or equal to 16 characters,
 *                   underscore (_) may not be 2nd character.
 * @param attribute ALIGN(n), EXECUTABLE, DEFLOAD, MERGE, MOVABLE, NOLOAD, NOTEXECUTABLE,
 * NOTREUS, READONLY, REFR, RENT, REUS, RMODE(24), RMODE(31), RMODE(ANY),
 * <br> Default Attributes: When you don't specify attributes
 * on the CATTR instruction the defaults are:
 * ALIGN(3),EXECUTABLE,NOTREUS,RMODE(24)
 */
procedure void CATTR (class_name,attribute,attribute,... );
/**
 * CCW
 * <br>Define and generate an 8-byte, format-0 channel command word for input/output
 * operations. A format-0 channel command word allows a 24-bit data address.
 * @example <code>WRITE1 CCW 1,DATADR,X'48',X'50' </code>
 * @param name label
 * @param command_code absolute expression that specifies the command code
 * @param data_address relocatable or absolute expression that specifies the address of the data
 * to operate upon. This value is treated as a 3-byte, A-type address constant.
 * @param flags absolute expression that specifies the flags for bits 32 to 37,
 *              and zeros for bits 38 and 39, of the generated channel command word.
 * @param data_count absolute expression that specifies the byte count or length of data.
 */
procedure void CCW (name,command_code,data_address,flags,data_count);
/**
 * CCW0
 * <br>Define and generate an 8-byte, format-0 channel command word for input/output
 * operations. A format-0 channel command word allows a 24-bit data address.
 * @example <code>WRITE1 CCW 1,DATADR,X'48',X'50' </code>
 * @param name label
 * @param command_code absolute expression that specifies the command code
 * @param data_address relocatable or absolute expression that specifies the address of the data
 * to operate upon. This value is treated as a 3-byte, A-type address constant.
 * @param flags absolute expression that specifies the flags for bits 32 to 37,
 *              and zeros for bits 38 and 39, of the generated channel command word.
 * @param data_count absolute expression that specifies the byte count or length of data.
 */
procedure void CCW0 (name,command_code,data_address,flags,data_count);
/**
 * CCW1
 * <br>Defines and generates an 8-byte format-1 channel command word for input/output operations. A
 * format-1 channel command word allows 31-bit data addresses.
 * @example <code>A CCW1 X'0C',BUF1,X'00',L'BUF1 </code>
 * @param name label
 * @param command_code absolute expression that specifies the command code
 * @param data_address relocatable or absolute expression that specifies the address of the data
 * to operate upon. This value is treated as a 4-byte, A-type address constant.
 * @param flags an absolute expression that specifies the flags for bits 8 to 15 of the generated
 * channel command word. The value of this expression is right-justified in byte 1 of the generated
 * channel command word.
 * @param data_count absolute expression that specifies the byte count or length of data.
 */
procedure void CCW1 (name,command_code,data_address,flags,data_count);
/**
 * CEJECT
 * <br>Conditionally stops the printing of the assembler listing on the current page, and continues the
 * printing on the next page.
 * @example <code> [seqsymbol] CEJECT 15</code>
 * @param nbroflines the number of lines that must remain on a page to prevent a eject.
 * @see seqsymbol
 */
procedure void CEJECT (nbroflines);
/**
 * CNOP
 * <br>Force alignment of following instruction or data to a specific halfword boundary by
 * inserting NOP instructions.
 * @example <code> [seqsymbol] CEJECT 4,8</code>
 * @param byte specifies which even-numberd byte of word the location counter is set to.
 * @param word specifies alignment to next fullword (4) or doubleword (8)
 * <pre>
 *   ____________________________________________________________________
 *  |                            Doubleword                              |
 *  |____________________________________________________________________|
 *  |           Fullword              |            Fullword              |
 *  |_________________________________|__________________________________|
 *  |   Halfword    |    Halfword     |    Halfword    |    Halfword     |
 *  |_______________|_________________|________________|_________________|
 *  | Byte  |  Byte |  Byte  |  Byte  |  Byte  | Byte  |  Byte  |  Byte  |
 *  |_______|_______|________|________|________|_______|________|________|
 *  |0,4             2,4               0,4              2,4              |
 *  |0,8             2,8               4,8              6,8              |
 *  |____________________________________________________________________|
 * </pre>
 * @see seqsymbol
 */
procedure void CNOP (byte,word);
/**
 * COM
 * <br>Names the beginning or continuation of a common control section.
 * @example <code> COMMSECT COM</code>
 * @see seqsymbol
 */
procedure void COM ;
/**
 * COPY
 * <br>Copys the contents of member in place of the COPY statment.
 * @example <code> [seqsymbol] COPY ABCDE</code>
 * @see seqsymbol
 */
procedure void COPY (member) ;
/**
 * CSECT
 * <br>Names the beginning or continuation of an executable control section.
 * @example <code> ALPHA CSECT</code>
 * @see seqsymbol
 */
procedure void CSECT (name);
/**
 * CXD
 * <br>The CXD instruction reserves a fullword area in storage. The linker
 * or loader inserts into this area the total length of all external dummy
 * sections (DXDs) specified in the source modules that are assembled
 * and linked into one program.
 * @example <code> [name] CXD</code>
 * @see DXD
 */
procedure void CXD ;
/**
 * DC   Define Constant
 * <br>Allocates and initializes storage to a type and value.
 * @example <code> FIELDA DC 4CL4'ABCD'</code>
 * @param name Optional label assigned to storage specified.
 * @param dupfactor specified {@link duplication_factor} of storage allocated.
 * @param type specified {@link type} of storage allocated.
 * @param modifier specified {@link modifier} of storage allocated.
 * @param value The initial value to be placed in the defined storage.
 * @see DS

 */
procedure void DC (name,dupfactor,type,modifier,value) ;
/**
 * DROP
 * <br>Tell the Assembler to stop using <b><i>register</i></b> as a base register.
 * @example <code> DROP R10</code>
 * @param register the register currently being used as a base register or
 * or an equated value for the register.
 * @see USING
 */
procedure void DROP (register) ;
/**
 * DS   Define Storage
 * <br>The define storage command adjusts the location counter without creating
 * or initializing any storage.  DS is usually used to map storage that
 * has been defined somewhere else.
 * @example <code> FIELDA DS 4CL4</code>
 * @param name Optional label assigned to storage specified.
 * @param dupfactor specified {@link duplication_factor} of storage allocated.
 * @param type specified {@link type} of storage allocated.
 * @param modifier specified {@link modifier} of storage allocated.
 * @param value a value used to calculate the length.  <b>NO STORAGE IS INITIALIZED.</b>
 * @see DC
 */
procedure void DS (name,dupfactor,type,modifier,value) ;
/**
 * DSECT Define Dummy Control Section
 * <br>Remaps a section of memory defined elsewhere.  The location counter is started at
 * zero when a new DSECT is defined.  When continuing a previously defined dummy section (by
 * using the same name, the location counter is restored.
 * @example <code> DUMYAREA DSECT</code>
 */
procedure void DSECT (name) ;
/**
 * DXD Define External Dummy Section
 * <br> The DXD instruction identifies and defines an external dummy section.
 * In order to reference the storage defined by the external dummy section, the ordinary
 * symbol denoted by <i>name</i> must appear in the operand of a Q-type constant.
 * This symbol represents the address of the first byte of the external dummy
 * section defined, and has a length attribute value of 1.
 * @example <code> FIELDA DXD 4CL4</code>
 * @param name Optional label assigned to storage specified.
 * @param dupfactor specified {@link duplication_factor} of storage allocated.
 * @param type specified {@link type} of storage allocated.
 * @param modifier specified {@link modifier} of storage allocated.
 * @param value a value used to calculate the length.  <b>NO STORAGE IS INITIALIZED.</b>
 * @see CXD
 */
procedure void DXD (name,dupfactor,type,modifier,value) ;
/**
 * END
 * <br>Use the END instruction to end the assembly of a program. You can also supply an address
 * in the operand field to which control can be transferred after the program is loaded.
 * The END instruction must always be the last statement in the source program.
 * @example <code> END PGMA</code>
 * @param expression Usually the name of the module.  Points to the first statement to be executed
 * when the program is loaded.
 * @param language A marker for use by language translators that produce assembly code.
 * The operand has three sub-operands. The values in this operand are
 * copied into characters 53 to 71 of the End record in the object deck.
 * The syntax of this operand is
 * <b><code>  ,(char10,char4,char5) </code></b>
 * where all three sub-operands, and the comma and parentheses are
 * required.
 * <p>
 * <i>char10</i> is a one to ten character code. It is intended to be a language
 * translator identifier. <i>char4</i> must be exactly four characters long. It
 * is intended to be a release code. <i>char5</i> must be exactly five
 * characters long, and should be a date in the format "YYDDD." It is
 * intended to be the compile date.
 */
procedure void END (expression,language);
/**
 * ENTRY
 * <br>The ENTRY instruction identifies symbols defined in one source module so that they can
 * be referred to in another source module. These symbols are entry symbols.
 * @example <code> ENTRY PGMA1</code>
 * @param name Is a valid symbol, is defined in an executable control section, and is not
 * defined in a dummy control section, a common control section, or an external control section.
 * <p>Up to 65535 individual control sections, external symbols, and external dummy sections
 * can be defined in a source module.  However, the practical maximum number depends on the
 * amount of table storage available during link-editing.
 */
procedure void ENTRY (name) ;
/**
 * EQU
 * <br>Can be used to:
 * <ul>
 * <li>Assign single absolute values to symbols.
 * <li>Assign the values of previously defined symbols or expressions to new symbols,
 * thus letting you use different mnemonics for different purposes.
 * <li>Compute expressions whose values are unknown at coding time or difficult to
 * calculate. The value of the expressions is then assigned to a symbol.
 * </ul>
 * @example <pre>
 *     <code> R15 EQU 15</code>
 *    <code> TABLELEN EQU *-TABSTART</code>
 * </pre>
 * @param symbol An ordinary symbol or a variable symbol that has been assigned a
 * character string with a value that is valid for an ordinary symbol.  Must start in column 1.
 * @param expr1 a complexly relocatable expression, the whole expression, rather than its
 * value, is assigned to the symbol.  During the evaluation of any expression that includes
 * a complexly relocatable symbol, that symbol is replaced by its own defining expression.
 * @param expr2 represents a value that the assembler assigns as a length attribute value
 * to the symbol in the name field. It is optional, but, if specified, must be an absolute
 * value in the range 0 to 65,535. This value overrides the normal length attribute value
 * implicitly assigned from expr1.
 * @param expr3 represents a value that the assembler assigns as a type attribute value to
 * the symbol in the name field. It is optional, but, if specified, it must be an absolute
 * value in the range 0 to 255. This value overrides the normal type attribute
 * value implicitly assigned from expr1.
 */
procedure void EQU (symbol,expr1,expr2,expr3) ;
/**
 * EXEC
 * <br>The EXEC statement is used to embed code from a high level language
 * within assembly code.  It is most commonly used with EXEC CICS, EXEC DLI,
 * or EXEC SQL.
 * @example <pre>
 *        EXEC  CICS SEND FROM(MSG04) LENGTH(30) ERASE
 * </pre>
 * @param language language to embed within assembly.
 */
procedure void EXEC (language) ;
/**
 * EXITCTL
 * <br>The EXITCTL instruction sets or modifies the contents of the four signed fullword
 * exit-control parameters that the assembler maintains for each type of exit.
 * @example <code>  EXITCTL LISTING,256,,*+128 </code>
 * @param exittype identifies the type of exit to which this EXITCTL instruction applies.
 * Exit_type must have one of the following values:
 * <dl>
 * <dt>SOURCE </dt>
 * <dd>Sets the exit-control parameters for the user-supplied exit module specified in the
 * INEXIT suboption of the EXIT assembler option.
 * <dt>LIBRARY
 * <dd>Sets the exit-control parameters for the user-supplied exit module specified in the
 * LIBEXIT suboption of the EXIT assembler option.
 * <dt>LISTING
 * <dd>Sets the exit-control parameters for the user-supplied exit module specified in the
 * PRTEXIT suboption of the EXIT assembler option.
 * <dt>PUNCH
 * <dd>Sets the exit-control parameters for the user-supplied exit module specified in the
 * OBJEXIT suboption of the EXIT assembler option when it is called to process the object
 * module records generated when the DECK assembler option is specified.
 * <dt>OBJECT (MVS and CMS Only)
 * <dd>Sets the exit-control parameters for the user-supplied exit module specified in the
 * OBJEXIT suboption of the EXIT assembler option when it is called to process the object
 * module records generated when the OBJECT or XOBJECT assembler option is specified.
 * <dt>ADATA
 * <dd>Sets the exit-control parameters for the user-supplied exit module specified in the
 * ADEXIT suboption of the EXIT assembler option.
 * <dt>TERM
 * <dd>Sets the exit-control parameters for the user-supplied exit module specified in the
 * TRMEXIT suboption of the EXIT assembler option.
 * </dl>
 * @param value1 is the value to which the corresponding exit-control parameter
 * should be set. For each exit type, the assembler maintains four exit-control parameters
 * known as EXITCTL_1, EXITCTL_2, EXITCTL_3, and EXITCTL_4. Therefore, up to four values
 * may be specified. Which exit-control parameter is set is determined by the position of
 * the value in the operand of the instruction. You must code a comma in the operand for
 * each omitted value. If specified, control_value must be either:
 * <ul>
 * <li>A decimal self-defining term with a value in the range -2**31 to +2**31-1.
 * <li>An expression in the form *+/-n, where * is the current value of the corresponding
 * exit-control parameter to which n, a decimal self-defining term, is added or from which
 * n is subtracted. The value of the result of adding n to or subtracting
 * n from the current exit-control parameter value must be in the range -2**31 to +2**31-1.
 * </ul>
 * If control_value is omitted, the corresponding exit-control parameter retains its current value.
 * @param value2 See value1
 * @param value3 See value1
 * @param value4 See value1
 */
procedure void EXITCTL (exittype,value1,value2,value3,value4) ;
/**
 * <br>The EXTRN instruction identifies symbols referred to in a source module but defined in
 * another source module. These symbols are external symbols.
 * @param seqsymbol Optional, see {@link seqsymbol}
 * @param extrn is a relocatable symbol that:
 * <ul>
 * <li>Is a valid symbol
 * <li>Is not used as the name entry of a source statement in the source module in which it is defined
 * <li>Is not paired in an expression
 * @see ENTRY
 */
procedure void EXTRN (seqsymbol,extrn) ;
/**
 * ICTL
 * <br>The ICTL instruction changes the begin, end, and continue columns that establish the coding
 * format of the assembler language source statements.  Must be at the beginning of the source file.
 * @param begin decimal self-defining term within the range of 1 to 40, inclusive, which indicates
 * the begining column for statements.
 * @param end specifies the end column of the source statement. When <i>end</i> is specified it must be
 * a decimal self-defining term within the range of 41 to 80, inclusive. It must be not less than
 * <i>begin</i> +5, and must be greater than <i>continue</i>. If <i>end</i> is not specified, it is
 * assumed to be 71.
 * @param continue specifies the continue column of the source statement. When specified, <i>continue</i>
 * must be a decimal self-defining term within the range of 2 to 40, and it must be greater than <i>begin</i>.
 * If <i>continue</i> is not specified, or if column 80 is specified as the <i>end</i> column,
 * the assembler assumes that continuation lines are not allowed.
 * @example <code> ICTL 1,71,16 </code>    And defaults
 */
procedure void ICTL (begin,end,continue) ;
/**
 * ISEQ
 * The ISEQ instruction forces the assembler to check if the statements in a source module are
 * in sequential order. In the ISEQ instruction, you specify the columns between which the
 * assembler is to check for sequence numbers.
 * @param left specifies the first column of the field to be sequence-checked. If specified,
 * <i>left</i> must be a decimal self-defining term in the range 1 to 80, inclusive.
 * @param right specifies the extreme right column of the field to be sequence checked. If
 * specified, <i>right</i> must be a decimal self-defining term in the range 1 to 80, inclusive,
 * and must be greater than or equal to <i>left</i>.
 * @example <code> ISEQ 73,80</code>
 */
procedure void ISEQ (begin,end) ;
/**
 * LOCTR
 * <br>The LOCTR instruction specifies multiple location counters within a control section.
 * The assembler assigns consecutive addresses to the segments of code using one location
 * counter before it assigns addresses to segments of coding using the next location counter.
 * @param symbol Allows createion or continuation of previous location counters.
 */
procedure void LOCTR (symbol) ;
/**
 * LTORG
 * <br>Use the LTORG instruction so that the assembler can collect and assemble literals into
 * a literal pool. A literal pool contains the literals you specify in a source module either
 * after the preceding LTORG instruction, or after the beginning of the source module.
 */
procedure void LTORG () ;
/**
 * OPSYN
 * <br> Allows standard opcodes to be renamed (creates an alias or synonym)
 * @example <code> STORE OPSYN STH</code>
 */
procedure void OPSYN (alias,opcode) ;
/**
 * ORG
 * <br>The ORG instruction alters the setting of the location counter and thus controls the
 * structure of the current control section.  This redefines portions of a control section.
 * @param expression a relocatable expression, the value of which is used to set the location counter.
 * If <i>expression</i> is omitted, the location counter is set to the next available location
 * for the current control section.
 * @example <pre>
 * <code>   ORG TABBEGIN </code>
 * <code>   ORG *-100 </code>
 * <code>   ORG TABBEGIN+C' ' </code>
 * </pre>
 */
procedure void ORG (expression) ;
/**
 * POP
 * The POP instruction restores the PRINT, USING or ACONTROL status saved by the most
 * recent PUSH instruction.
 * @example <code>   POP PRINT </code>
 * @param option on eof the following values: PRINT, USING, or ACONTROL.  Multiple may be
 * used if separated by commas.
 * @param NOPRINT causes the POP statement to not be printed in the Assembler listing.
 * @see PUSH
 */
procedure void POP (option,NOPRINT) ;
/**
 * PRINT
 * <br>Instructs the Assembler to print various portion of the listing.
 * @param operand one of the following options:
 * <dl>
 * <dt>ON or OFF
 * <dd>Print or not print the source and object sections of the Assembler listing
 * <dt>GEN or NOGEN
 * <dd>Print or not print statements generated by macro expansion.
 * <dt>DATA or NODATA
 * <dd>
 * <dt>MCALL or NOMCALL
 * <dd>Print or not print nested macro calls.
 * <dt>MSOURCE or NOMSOURCE
 * <dd>Print or not print source statements generated by macro expansion.
 * <dt>UHEAD or NOUHEAD
 * <dd>Print or not print summary of active USINGs on title line of each page.
 * </dl>
 */
procedure void PRINT (operand) ;
/**
 * PUSH
 * <br>The PUSH instruction saves the current PRINT, USING or ACONTROL status in push-down
 * storage on a last-in, first-out basis.
 * @param option either PRINT, USING, or ACONTROL (multiple allowed if separated by comma)
 * @see POP
 */
procedure void PUSH (option) ;
/**
 * RMODE
 * <br>Controls the residence mode of the control section being created.  This indicates
 * where in memory the control section may be loaded.
 * @param option Either 24, 31, or ANY.
 */
procedure void RMODE (option) :
/**
 * <br>Serves as statement label for conditional assembly statements.
 * Must begin with a period (.) and may be from 1 to 62 alphanumeric
 * characters long.
 * @example .ABC001 ACONTROL COMPAT(...
 */
private const seqsymbol;
/**
 * Storage and Constant Types
 * <pre>
 *   ________________________________________________________________________
 *  | Code  | Constant Type | Machine Format                                 |
 *  |_______|_______________|________________________________________________|
 *  | C     | Character     | 8-bit code for each character                  |
 *  |_______|_______________|________________________________________________|
 *  | G     | Graphic       | 16-bit code for each character                 |
 *  |_______|_______________|________________________________________________|
 *  | X     | Hexadecimal   | 4-bit code for each hexadecimal digit          |
 *  |_______|_______________|________________________________________________|
 *  | B     | Binary        | Binary format                                  |
 *  |_______|_______________|________________________________________________|
 *  | F     | Fixed-point   | Signed, fixed-point binary format; normally a  |
 *  |       |               | fullword                                       |
 *  |_______|_______________|________________________________________________|
 *  | H     | Fixed-point   | Signed, fixed-point binary format; normally a  |
 *  |       |               | halfword                                       |
 *  |_______|_______________|________________________________________________|
 *  | E     | Floating-point| Short floating-point format; normally a        |
 *  |       |               | fullword                                       |
 *  |_______|_______________|________________________________________________|
 *  | D     | Floating-point| Long floating-point format; normally a         |
 *  |       |               | doubleword                                     |
 *  |_______|_______________|________________________________________________|
 *  | L     | Floating-point| Extended floating-point format; normally two   |
 *  |       |               | doublewords                                    |
 *  |_______|_______________|________________________________________________|
 *  | P     | Decimal       | Packed decimal format                          |
 *  |_______|_______________|________________________________________________|
 *  | Z     | Decimal       | Zoned decimal format                           |
 *  |_______|_______________|________________________________________________|
 *  | A     | Address       | Value of address; normally a fullword          |
 *  |_______|_______________|________________________________________________|
 *  | Y     | Address       | Value of address; normally a halfword          |
 *  |_______|_______________|________________________________________________|
 *  | S     | Address       | Base register and displacement value; a        |
 *  |       |               | halfword                                       |
 *  |_______|_______________|________________________________________________|
 *  | V     | Address       | Space reserved for external symbol addresses;  |
 *  |       |               | each address normally a fullword               |
 *  |_______|_______________|________________________________________________|
 *  | J     | Address       | Space reserved for length of class or DXD;     |
 *  |       |               | normally a fullword                            |
 *  |_______|_______________|________________________________________________|
 *  | Q     | Address       | Space reserved for external dummy section      |
 *  |       |               | offset                                         |
 *  |_______|_______________|________________________________________________|
 * </pre>
 */
private const type;
/**
 * Constant and Storage Modifiers
 * <br>The LENGTH modifier indicates the number of bytes of storage into which the
 * constant is to be assembled. <b>It is written as Ln, where n is either a decimal
 * self-defining term or an absolute expression enclosed by parentheses.</b> It must
 * have a positive value.
 * <p>The SCALE modifier specifies the amount of internal scaling that you want for:
 * <pre>
 *   Binary digits for fixed-point constants (H, F)
 *   Hexadecimal digits for floating-point constants (E, D, L)
 * </pre>
 * The scale modifier can be used only with the above types of constants. It
 * cannot be used with EB, DB, and LB floating point constants.
 * The range for each type of constant is:
 * <pre>
 *   Fixed-point constant H = -187 to 15
 *   Fixed-point constant F = -187 to 30
 *   Floating-point constant E = 0 to 5
 *   Floating-point constant D = 0 to 13
 *   Floating-point constant L = 0 to 27
 * </pre>
 * <b>The scale modifier is written as Sn, where n is either a decimal self-defining
 * term, or an absolute expression enclosed in parentheses.</b> Both types of
 * specification can be preceded by a sign; if no sign is present,
 * a plus sign is assumed.
 * <p>The EXPONENT modifier specifies the power of 10 by which the nominal value
 * of a constant is to be multiplied before it is converted to its internal binary
 * representation. It can only be used with the fixed-point (H and F) and
 * floating-point (E, D, and L) constants.  <b>The exponent modifier is written as En,
 * where n can be either a decimal self-defining term, or an absolute expression
 * enclosed in parentheses.</b> The decimal self-defining term or the expression can
 * be preceded by a sign: If no sign is present, a plus sign is assumed. The
 * range for the exponent modifier is -85 to +75. If using the type extension to
 * define a floating-point constant, the exponent modifier can be in the range
 * -2**31 to 2**31-1. If the nominal value cannot be represented exactly, a warning
 * message is issued.
 */
private const modifier;
/**
 * Storage Duplication Factor
 * <br>You may omit the duplication factor. If specified, it causes the nominal value
 * or multiple nominal values specified in a constant to be generated the number of
 * times indicated by the factor.
 */
private const duplication_factor;
/*                        */
/*  Machine Instructions  */
/*                        */
/**
 * ADD
 * <br>Add binary fullword at <b>storage</b> to contents of <b>register</b>
 * <br>Format={@link rxoperands RX} Length=4 OpCode=5A
 * {@link rc1 Condition_Codes_Set}
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] A R1,D2(X2,B2) </code>
 */
procedure void A(register,storage);
/**
 * ADD NORMALIZED (Long Hexadecimal-Floating-Point)
 * <br> Add LHFP at <b>storage</b> to floating-point <b>register</b>
 * <br>Format={@link rxoperands RX} Length=4 OpCode=6A
 * {@link rc27 Condition_Codes_Set}
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] AD R1,D2(X2,B2) </code>
 */
procedure void AD(register,storage);
/**
 * ADD (Long Binary-Floating-Point)
 * <br> Add LBFP at <b>storage</b> to <b>register</b>
 * <br>Format={@link rxeoperands RXE} Length=6 OpCode=ED1A
 * {@link rc27 Condition_Codes_Set}
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] ADB R1,D2(X2,B2) </code>
 */
procedure void ADB(register,storage);
/**
 * ADD (Long Binary-Floating-Point)
 * <br> Add LBFP in <b>register2</b> to contents of <b>register1</b>
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B31A
 * {@link rc27 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] ADBR R1,R2 </code>
 */
procedure void ADBR(register1,register2);
/**
 * ADD NORMALIZED (Long Hexadecimal-Floating-Point)
 * <br> Add LHFP in <b>register2</b> to floating-point <b>register1</b>
 * <br>Format={@link rroperands RR} Length=2 OpCode=2A
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] ADR R1,R2 </code>
 */
procedure void ADR(register1,register2);
/**
 * ADD NORMALIZED (Short Hexadecimal-Floating-Point)
 * <br> Add SHFP at <b>storage</b> to contents of <b>register</b>
 * <br>Format={@link rxoperands RX} Length=4 OpCode=7A
 * {@link rc8 Condition_Codes_Set}
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] AE R1,D2(X2,B2) </code>
 */
procedure void AE(register,storage);
/**
 * ADD (Short Binary-Floating-Point)
 * <br>Add SBFP at <b>storage</b> to contents of <b>register</b>
 * <br>Format={@link rxeoperands RXE} Length=6 OpCode=ED0A
 * {@link rc27 Condition_Codes_Set}
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] AEB R1,D2(X2,B2) </code>
 */
procedure void AEB(register,storage);
/**
 * ADD (Short Binary-Floating-Point)
 * <br>Add SBFP contents of <b>register2</b> to <b>register1</b>
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B30A
 * {@link rc27 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] AEBR R1,R2 </code>
 */
procedure void AEBR(register1,register2);
/**
 * ADD NORMALIZED (Short Hexadecimal-Floating-Point)
 * <br> Add SHFP contents of <b>register2</b> to floating-point <b>register1</b>
 * <br>Format={@link rroperands RR} Length=2 OpCode=3A
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] AER R1,R2 </code>
 */
procedure void AER(register1,register2);
/**
 * ADD HALFWORD
 * <br>Add binary halfword at <b>storage</b> to <b>register</b>
 * <br>Format={@link rxoperands RX} Length=4 OpCode=4A
 * {@link rc1 Condition_Codes_Set}
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] AH R1,D2(X2,B2) </code>
 */
procedure void AH(register,storage);
/**
 * ADD HALFWORD IMMEDIATE
 * <br>Add <b>immediate-value</b> to <b>register</b>
 * <br>Format={@link rioperands RI} Length=4 OpCode=A7A
 * {@link rc1 Condition_Codes_Set}
 * @param Register Any general purpose register
 * @param Immediate_value 16-bit integer (x'0000'-x'FFFF')
 * @example <code>[label] AHI R1,I2 </code>
 */
procedure void AHI(register,immediate_value);
/**
 * ADD LOGICAL
 * <br>Add binary fullword at <b>storage</b> to <b>register</b>
 * <br>Format={@link rxoperands RX} Length=4 OpCode=5E
 * {@link rc2 Condition_Codes_Set}
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] AL R1,D2(X2,B2) </code>
 */
procedure void AL(register,storage);
/**
 * ADD LOGICAL
 * <br>Add contents of <b>register2</b> to <b>register1</b>
 * <br>Format={@link rxoperands RR} Length=2 OpCode=1E
 * {@link rc2 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] ALR R1,R2 </code>
 */
procedure void ALR(register,register);
/**
 * ADD DECIMAL
 * <br>Add packed value at <b>storage2</b>, for length <b>L2</b>, to <b>storage1</b> for length <b>L1</b>
 * <br>Format={@link ssoperandsb SS} Length=6 OpCode=FA
 * {@link rc1 Condition_Codes_Set}
 * @param Storage1 Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement.
 *                Default length is as defined.
 * @param Storage2 Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement.
 *                Default length is as defined.
 * @example <code>[label] AP D1(L1,B1),D2(L2,B2) </code>
 */
procedure void AP(storage1,storage2);
/**
 * ADD
 * <br>Add contents of <b>register2</b> to <b>register1</b>
 * <br>Format={@link rroperands RR} Length=2 OpCode=1A
 * {@link rc1 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] AR R1,R2 </code>
 */
procedure void AR(register1,register2);
/**
 * ADD UNNORMALIZED (Short Hexadecimal-Floating-Point)
 * <br>Add SHFP at <b>storage</b> to <b>register</b>
 * <br>Format={@link rxoperands RX} Length=4 OpCode=7E
 * {@link rc8 Condition_Codes_Set}
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] AU R1,D2(X2,B2) </code>
 */
procedure void AU(register,storage);
/**
 * ADD UNNORMALIZED (Short Hexadecimal-Floating-Point)
 * <br>Add SHFP in <b>register2</b> to <b>register1</b>
 * <br>Format={@link rxoperands RR} Length=2 OpCode=3E
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] AUR R1,R2 </code>
 */
procedure void AUR(register1,register2);
/**
 * ADD UNNORMALIZED (Long Hexadecimal-Floating-Point)
 * <br>Add LHFP at <b>storage</b> to <b>register</b>
 * <br>Format={@link rxoperands RX} Length=4 OpCode=6E
 * {@link rc8 Condition_Codes_Set}
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] AW R1,D2(X2,B2) </code>
 */
procedure void AW(register,storage);
/**
 * ADD UNNORMALIZED (Long Hexadecimal-Floating-Point)
 * <br>Add LHFP in <b>register2</b> to <b>register1</b>
 * <br>Format={@link rroperands RR} Length=2 OpCode=2E
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] AWR R1,R2 </code>
 */
procedure void AWR(register1,register2);
/**
 * ADD (Extended Binary-Floating-Point)
 * <br>Add EBFP in <b>register2</b> to <b>register1</b>
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B34A
 * {@link rc27 Condition_Codes_Set}
 * @param Register1 Even-numbered floating-point register (of even-odd pair)
 * @param Register2 Even-numbered floating-point register (of even-odd pair)
 * @example <code>[label] AXBR R1,R2 </code>
 */
procedure void AXBR(register,register);
/**
 * ADD NORMALIZED (Extended Hexadecimal-Floating-Point)
 * <br>Add EHFP in <b>register2</b> to floating-point register pair <b>register1</b>
 * <br>Format={@link rroperands RR} Length=2 OpCode=36
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Even-numbered floating-point register (of even-odd pair)
 * @param Register2 Even-numbered floating-point register (of even-odd pair)
 * @example <code>[label] AXR R1,R2 </code>
 */
procedure void AXR(register1,register2);
/**
 * BRANCH UNCONDITIONAL
 * <br>Branch to <b>storage</b> address
 * <br>Format={@link rxoperands RX} Length=4 OpCode=47
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] B D1(X1,B1) </code>
 */
procedure void B(storage);
/**
 * BRANCH AND STACK
 * <br>Create linkage-stack branch state entry, branch to address in <b>register2</b>, <b>register1</b> contains return address
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B240
 * @param Register1 Any general purpose register (if 0, NSI address is return address)
 * @param Register2 Any general purpose register (if 0, no branch occurs)
 * @example <code>[label] BAKR R1,R2 </code>
 */
procedure void BAKR(register1,register2);
/**
 * BRANCH AND LINK
 * <br>Address of NSI is stored in <b>register</b>, branch to <b>storage</b> location
 * <br>Format={@link rxoperands RX} Length=4 OpCode=45
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] BAL R1,D2(X2,B2) </code>
 * @see BAS
 */
procedure void BAL(register,storage);
/**
 * BRANCH AND LINK
 * <br>Address of NSI is stored in <b>register1</b>, branch to address in <b>register2</b>
 * <br>Format={@link rroperands RR} Length=2 OpCode=05
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register (if 0, no branch takes place)
 * @example <code>[label] BALR R1,R2 </code>
 * @see BASR
 */
procedure void BALR(register1,register2);
/**
 * BRANCH AND SAVE
 * <br>Address of NSI stored in <b>register</b>, branch to <b>storage</b> location
 * <br>Format={@link rxoperands RX} Length=4 OpCode=4D
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] BAS R1,D2(X2,B2) </code>
 */
procedure void BAS(register,storage);
/**
 * BRANCH AND SAVE
 * <br>Address of NSI stored in <b>register1</b>, brnach to address in <b>register2</b>
 * <br>Format={@link rroperands RR} Length=2 OpCode=0D
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register (if 0, no branch takes place)
 * @example <code>[label] BASR R1,R2 </code>
 */
procedure void BASR(register1,register2);
/**
 * BRANCH AND SAVE AND SET MODE
 * <br>Address of NSI placed in <b>register1</b>, branch to address in <b>register2</b>
 * <br>Preferred method to call subroutines operating in a different addressing mode.
 * <br>Format={@link rroperands RR} Length=2 OpCode=0C
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] BASSM R1,R2 </code>
 * @see BSM
 */
procedure void BASSM(register1,register2);
/**
 * BRANCH ON CONDITION
 * <br>Branch to <b>storage</b> location if {@link mask} = condition code
 * <br>Format={@link rxoperands RX} Length=4 OpCode=47
 * @param Mask Numeric value of bits corresponding to condition codes (see mask link above)
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] BC M1,D2(X2,B2) </code>
 */
procedure void BC(mask,storage);
/**
 * BRANCH ON CONDITION
 * <br>Branch to address in <b>register</b> if {@link mask} = condition code
 * <br>Format={@link rroperands RR} Length=2 OpCode=07
 * @param Mask Numeric value of bits corresponding to condition codes (see mask link above)
 * @param Register Any general purpose register (if 0, no branch occurs)
 * @example <code>[label] BCR M1,R2 </code>
 */
procedure void BCR(mask,register);
/**
 * BRANCH ON COUNT
 * <br>Subtract 1 from <b>register</b>, branch to <b>storage</b> location if <b>register</b> does NOT contain 0
 * <br>Format={@link rxoperands RX} Length=4 OpCode=46
 * @param Register1 Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] BCT R1,D2(X2,B2) </code>
 */
procedure void BCT(register,storage);
/**
 * BRANCH ON COUNT
 * <br>Subtract 1 from <b>register1</b>, branch to address in <b>register2</b> if <b>register1</b> does NOT contain 0
 * <br>Format={@link rroperands RR} Length=2 OpCode=06
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register (if 0, no branch takes place)
 * @example <code>[label] BCTR R1,R2 </code>
 */
procedure void BCTR(register1,register2);
/**
 * BRANCH RELATIVE AND SAVE
 * <br>Save NSI in <b>register</b>, add <b>immediate-value</b>*2 to address of instruction and branch to result
 * <br>Format={@link rioperands RI} Length=4 OpCode=A75
 * @param Register Any general purpose register
 * @param Immediate_value A signed binary integer specifying the number of halfwords that is added to the
 * address of the instruction to generate the branch address.
 * @example <code>[label] BRAS R1,I2 </code>
 */
procedure void BRAS(register,immediate_value);
/**
 * BRANCH RELATIVE ON CONDITION
 * <br>If {@link mask} = condition code, add <b>immediate-value</b>*2 to address of instruction and branch to result
 * <br>Format={@link rioperands RI} Length=4 OpCode=A74
 * @param Mask numeric value of bits corresponding to condition codes (see mask link above)
 * @param Immediate_value A signed binary integer specifying the number of halfwords that is added to the
 * address of the instruction to generate the branch address.
 * @example <code>[label] BRC M1,I2 </code>
 */
procedure void BRC(mask,immediate_value);
/**
 * BRANCH RELATIVE ON COUNT
 * <br>Subtract 1 from <b>register</b>, if <b>register</b> contents NOT = 0, add <b>immediate-value</b>*2 to instruction address and branch
 * <br>Format={@link rioperands RI} Length=4 OpCode=A76
 * @param Register Any general purpose register
 * @param Immediate_value A signed binary integer specifying the number of halfwords that is added to the
 * address of the instruction to generate the branch address.
 * @example <code>[label] BRCT R1,I2 </code>
 */
procedure void BRCT(register,immediate_value);
/**
 * BRANCH RELATIVE ON INDEX HIGH
 * <br>Increment value  is added to <b>register1</b>.  If results greater than compare-value branch to current address + (<b>immediate-value</b>*2)
 * <br>Format={@link rsioperands RSI} Length=4 OpCode=84
 * @param Register1 Any general purpose register
 * @param Immediate_value A signed binary integer specifying the number of halfwords that is added to the
 * address of the instruction to generate the branch address.
 * @param Register3 Any general purpose register.
 * If <b>register3</b> is even, <b>register3</b> contains increment value and <b>register3</b>+1 contains compare value
 * else <b>register3</b> contains increment and compare value.
 * @example <code>[label] BRXH R1,R3,I2 </code>
 */
procedure void BRXH(register1,register3,immediate_value);
/**
 * BRANCH RELATIVE ON INDEX LOW OR EQ.
 * <br>Increment value  is added to <b>register1</b>.  If results less than or equal to compare-value branch to current address + (<b>immediate-value</b>*2)
 * <br>Format={@link rsioperands RSI} Length=4 OpCode=84
 * @param Register1 Any general purpose register
 * @param Immediate_value A signed binary integer specifying the number of halfwords that is added to the
 * address of the instruction to generate the branch address.
 * @param Register3 Any general purpose register.
 * If <b>register3</b> is even, <b>register3</b> contains increment value and <b>register3</b>+1 contains compare value
 * else <b>register3</b> contains increment and compare value.
 * @example <code>[label] BRXLE R1,R3,I2 </code>
 */
procedure void BRXLE(register1,register3,immediate_value);
/**
 * BRANCH AND SET AUTHORITY
 * <br>See OS/390 Principles of Operations
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B25A
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] BSA R1,R2 </code>
 */
procedure void BSA(register1,register2);
/**
 * BRANCH IN SUBSPACE GROUP
 * <br>See OS/390 Principles of Operations
 * <br>Format={@link rreoperands RRE) Length=4 OpCode=B258
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] BSG R1,R2 </code>
 */
procedure void BSG(register1,register2);
/**
 * BRANCH AND SET MODE
 * <br>High-order bit of <b>register1</b> is replaced with addressing mode bit of PSW.
 * <br>Set PSW addressing bit based on high-order bit of <b>register2</b> and branch to address in <b>register2</b>
 * <br>Format={@link rroperands RR} Length=2 OpCode=0B
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] BSM R1,R2 </code>
 */
procedure void BSM(register1,register2);
/**
 * BRANCH ON INDEX HIGH
 * <br>Increment value is added to <b>register1</b>.  If results greater than compare-value branch to <b>storage</b>
 * <br>Format={@link rsoperands RS} Length=4 OpCode=86
 * @param Register1 Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register,
 *                and <b>D</b>isplacement
 * @param Register3 Any general purpose register.
 * If <b>register3</b> is even, <b>register3</b> contains increment value and <b>register3</b>+1 contains compare value
 * else <b>register3</b> contains increment and compare value.
 * @example <code>[label] BXH R1,R3,D2(B2) </code>
 */
procedure void BXH(register1,register3,storage);
/**
 * BRANCH ON INDEX LOW OR EQUAL
 * <br>Increment value is added to <b>register1</b>.  If results less than or equal to compare-value branch to <b>storage</b>
 * <br>Format={@link rsoperands RS} Length=4 OpCode=86
 * @param Register1 Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register,
 *                and <b>D</b>isplacement
 * @param Register3 Any general purpose register.
 * If <b>register3</b> is even, <b>register3</b> contains increment value and <b>register3</b>+1 contains compare value
 * else <b>register3</b> contains increment and compare value.
 * @example <code>[label] BXLE R1,R3,D2(B2) </code>
 */
procedure void BXLE(register1,register3,storage);
/**
 * COMPARE
 * <br>Contents of <b>register</b> compared to fullword at <b>storage</b> and condition code set.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=59
 * {@link rc4 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] C R1,D2(X2,B2) </code>
 */
procedure void C(register,storage);
/**
 * COMPARE (Long Hexadecimal-Floating-Point)
 * <br>Algebraic compare (subtraction) of <b>register</b> to <b>storage</b> (register-storage), and condition code set.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=69
 * {@link rc4 Condition_Codes_Set}
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] CD R1,D2(X2,B2) </code>
 */
procedure void CD(register,storage);
/**
 * COMPARE (Long Binary-Floating-Point)
 * <br>Algebraic compare (subtraction) of <b>register</b> to <b>storage</b> (register-storage), and condition code set.
 * <br>Format={@link rxeoperands RXE} Length=6 OpCode=ED19
 * {@link rc25 Condition_Codes_Set}
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] CDB R1,D2(X2,B2) </code>
 */
procedure void CDB(register,storage);
/**
 * COMPARE (Long Binary-Floating-Point)
 * <br>Algebraic compare (subtraction) of <b>register1</b> to <b>register2</b> (register1-register2), and condition code set.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B319
 * {@link rc25 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] CDBR R1,R2 </code>
 */
procedure void CDBR(register1,register2);
/**
 * CONVERT FROM FIXED (32-bit integer to Long Binary-Floating-Point)
 * <br>32-bit binary integer in <b>register2</b> is converted to LBFP and stored in <b>register1</b>
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B395
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] CDFBR R1,R2 </code>
 */
procedure void CDFBR(register1,register2);
/**
 * CONVERT FROM FIXED (32-bit integer to Long Hexadecimal-Floating-Point)
 * <br>32-bit binary integer in <b>register2</b> is converted to LHFP and stored in <b>register1</b>
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B3B5
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] CDFR R1,R2 </code>
 */
procedure void CDFR(register1,register2);
/**
 * COMPARE (Long Hexadecimal-Floating-Point)
 * <br>Algebraic compare (subtraction) of <b>register1</b> to <b>register2</b> (register1-register2), and condition code set.
 * <br>Format={@link rroperands RR} Length=2 OpCode=29
 * {@link rc4 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] CDR R1,R2 </code>
 */
procedure void CDR(register1,register2);
/**
 * COMPARE DOUBLE AND SWAP
 * <br>Compare 64 bits of even-odd register pair <b>register1</b> to double-word at <b>storage</b>.
 * <br>If operands equal store even-odd register pair <b>register3</b> at <b>storage</b>
 * <br>else load <b>storage</b> into even-odd register pair <b>register1</b>
 * <br>Format={@link rsoperands RS} Length=4 OpCode=BB
 * {@link rc6 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register3 Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register
 *                and <b>D</b>isplacement on a double-word boundary
 * @example <code>[label] CDS R1,R3,D2(B2) </code>
 */
procedure void CDS(register1,register3,storage);
/**
 * COMPARE (Short Hexadecimal-Floating-Point)
 * <br>Algebraic compare (subtraction) of <b>register</b> to <b>storage</b> (register-storage), and condition code set.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=79
 * {@link rc4 Condition_Codes_Set}
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] CE R1,D2(X2,B2) </code>
 */
procedure void CE(register,storage);
/**
 * COMPARE (Short Binary-Floating-Point)
 * <br>Algebraic compare (subtraction) of <b>register</b> to <b>storage</b> (register-storage), and condition code set.
 * <br>Format={@link rxeoperands RXE} Length=6 OpCode=ED09
 * {@link rc25 Condition_Codes_Set}
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] CEB R1,D2(X2,B2) </code>
 */
procedure void CEB(register,storage);
/**
 * COMPARE (Short Binary-Floating-Point)
 * <br>Algebraic compare (subtraction) of <b>register1</b> to <b>register2</b> (register1-register2), and condition code set.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B309
 * {@link rc25 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] CEBR R1,R2 </code>
 */
procedure void CEBR(register1,register2);
/**
 * CONVERT FROM FIXED (32-bit integer to Short Binary-Floating-Point)
 * <br>32-bit binary integer in <b>register2</b> is converted to SBFP and stored in <b>register1</b>
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B394
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] CEFBR R1,R2 </code>
 */
procedure void CEFBR(register1,register2);
/**
 * CONVERT FROM FIXED (32-bit integer to Short Hexadecimal-Floating-Point)
 * <br>32-bit binary integer in <b>register2</b> is converted to SHFP and stored in <b>register1</b>
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B3B4
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] CEFR R1,R2 </code>
 */
procedure void CEFR(register1,register2);
/**
 * COMPARE (Short Hexadecimal-Floating-Point)
 * <br>Compare SHFP in <b>register1</b> to <b>register2</b> and set condition code
 * <br>Format={@link rroperands RR} Length=2 OpCode=39
 * {@link rc4 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] CER R1,R2 </code>
 */
procedure void CER(register1,register2);
/**
 * COMPARE AND FORM CODEWORD
 * <br>See OS/390 Principles of Operations.  General Registers 1, 2, & 3 are implied operands
 * <br>Format={@link soperands S} Length=4 OpCode=B21A
 * {@link rc28 Condition_Codes_Set}
 * @param Storage The second-operand address is not used to address data. Bits 17-30 of the second-operand address, with one
 * rightmost and one leftmost zero appended, are used as a 16-bit index limit. Bit 31 of the second-operand address is
 * the operand-control bit. When bit 31 is zero, the codeword is formed from the high operand; when bit 31 is one, the
 * codeword is formed from the low operand. The remainder of the second-operand address is ignored.
 * @example <code>[label] CFC D2(B2) </code>
 */
procedure void CFC(storage);
/**
 * CONVERT TO FIXED (Long Binary-Floating-Point to 32-bit integer)
 * <br>Convert and round LBFP in <b>register2</b> to 32-bit integer in <b>register1</b>, round using {@link roundingmask mask}
 * <br>Format={@link rrfoperands RRF} Length=4 OpCode=B399
 * {@link rc18 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @param Mask See mask link above
 * @example <code>[label] CFDBR R1,M3,R2 </code>
 */
procedure void CFDBR(register1,mask,register2);
/**
 * CONVERT TO FIXED (Long Hexadecimal-Floating-Point to 32-bit integer)
 * <br>Convert and round LHFP in <b>register2</b> to 32-bit integer in <b>register1</b>, round using {@link roundingmask mask}
 * <br>Format={@link rrfoperands RRF} Length=4 OpCode=B3B9
 * {@link rc18 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @param Mask See mask link above
 * @example <code>[label] CFDR R1,M3,R2 </code>
 */
procedure void CFDR(register1,mask,register2);
/**
 * CONVERT TO FIXED (Short Binary-Floating-Point to 32-bit integer)
 * <br>Convert and round SBFP in <b>register2</b> to 32-bit integer in <b>register1</b>, round using {@link roundingmask mask}
 * <br>Format={@link rrfoperands RRF} Length=4 OpCode=B398
 * {@link rc18 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @param Mask See mask link above
 * @example <code>[label] CFEBR R1,M3,R2 </code>
 */
procedure void CFEBR(register1,mask,register2);
/**
 * CONVERT TO FIXED (Short Hexadecimal-Floating-Point to 32-bit integer)
 * <br>Convert and round SHFP in <b>register2</b> to 32-bit integer in <b>register1</b>, round using {@link roundingmask mask}
 * <br>Format={@link rrfoperands RRF} Length=4 OpCode=B3B8
 * {@link rc18 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @param Mask See mask link above
 * @example <code>[label] CFER R1,M3,R2 </code>
 */
procedure void CFER(register1,mask,register2);
/**
 * CONVERT TO FIXED (Extended Binary-Floating-Point to 32-bit integer)
 * <br>Convert and round EBFP in <b>register2</b> to 32-bit integer in <b>register1</b>, round using {@link roundingmask mask}
 * <br>Format={@link rrfoperands RRF} Length=4 OpCode=B39A
 * {@link rc18 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @param Mask See mask link above
 * @example <code>[label] CFXBR R1,M3,R2 </code>
 */
procedure void CFXBR(register1,mask,register2);
/**
 * CONVERT TO FIXED (Extended Hexadecimal-Floating-Point to 32-bit integer)
 * <br>Convert and round EHFP in <b>register2</b> to 32-bit integer in <b>register1</b>, round using {@link roundingmask mask}
 * <br>Format={@link rrfoperands RRF} Length=4 OpCode=B3BA
 * {@link rc18 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @param Mask See mask link above
 * @example <code>[label] CFXR R1,M3,R2 </code>
 */
procedure void CFXR(register1,mask,register2);
/**
 * COMPARE HALFWORD
 * <br>The halfword at <b>storage</b> is expanded to be a fullword and compared to <b>register</b>.  The condition code is set.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=49
 * {@link rc4 Condition_Codes_Set}
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] CH R1,D2(X2,B2) </code>
 */
procedure void CH(register,storage);
/**
 * COMPARE HALFWORD IMMEDIATE
 * <br>16-bit binary integer value embedded within instruction is compare to 32-bit integer in <b>register</b>.  Condition code is set.
 * <br>Format={@link rioperands RI} Length=4 OpCode=A7E
 * {@link rc4 Condition_Codes_Set}
 * @param Register Any general purpose register
 * @param Immediate_value 16-bit binary integer
 * @example <code>[label] CHI R1,I2 </code>
 */
procedure void CHI(register,immediate_value);
/**
 * CHECKSUM
 * <br>See OS/390 Principles of Operations.  <b>Register2</b>+1 contains length of operand 2.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B241
 * {@link rc19 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Even numbered general register
 * @example <code>[label] CKSM R1,R2 </code>
 */
procedure void CKSM(register,register);
/**
 * COMPARE LOGICAL
 * <br>Fullword at <b>storage</b> are compared to contents of <b>register</b>.  Condition code is set.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=55
 * {@link rc4 Condition_Codes_Set}
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] CL R1,D2(X2,B2) </code>
 */
procedure void CL(register,storage);
/**
 * COMPARE LOGICAL (character)
 * <br>Contents of <b>storage2</b>, for length of operand 1, are compared to contents of <b>storage1</b>.  Condition code is set.
 * <br>Format={@link ssoperandsc SS} Length=6 OpCode=D5
 * {@link rc4 Condition_Codes_Set}
 * @param Storage1 Storage label or <b>B</b>ase register
 *                 and <b>D</b>isplacement
 * @param Storage2 Storage label or <b>B</b>ase register
 *                 and <b>D</b>isplacement
 * @example <code>[label] CLC D1(L,B1),D2(B2) </code>
 */
procedure void CLC(storage1,storage2);
/**
 * COMPARE LOGICAL LONG
 * <br><b>Register1</b> and <b>register2</b> must indicate even-odd pairs.
 * <br><b>Register1</b>+1 holds the length of operand 1, <b>register2</b>+1 holds the pad character for the shorter operand and the length of the second operand.
 * <br>Operands are compared until unequal or end of longer operand, condition code is set.
 * <br>Format={@link rroperands RR} Length=2 OpCode=0F
 * {@link rc4 Condition_Codes_Set}
 * @param Register1 Any even-numbered general purpose register, address of operand 1
 * @param Register2 Any even-numbered general purpose register, address of operand 2
 * @example <code>[label] CLCL R1,R2 </code>
 */
procedure void CLCL(register1,register2);
/**
 * COMPARE LOGICAL LONG EXTENDED
 * <br><b>Register1</b> and <b>register2</b> must indicate even-odd pairs.
 * <br><b>Register1</b>+1 holds the length of operand 1, <b>register3</b>+1 holds the length of the third operand.  The pad character is held in the lower-order 8 bits of <b>storage</b>.
 * <br>Operands are compared until unequal or end of longer operand, condition code is set.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=A9
 * {@link rc4 Condition_Codes_Set}
 * @param Register1 Any even-numbered general purpose register, address of operand 1
 * @param Register3 Any even-numbered general purpose register, address of operand 3
 * @param Storage Storage label or <b>B</b>ase register
 *                and <b>D</b>isplacement (B2 should not be = R1, R1+1, R3, or R3+1), holds pad character
 * @example <code>[label] CLCLE R1,R3,D2(B2) </code>
 */
procedure void CLCLE(register1,register3,storage);
/**
 * COMPARE LOGICAL (immediate)
 * <br>One byte at <b>storage</b> is compared to the <b>immediate-value</b>.  The condition code is set.
 * <br>Format={@link sioperands SI} Length=4 OpCode=95
 * {@link rc4 Condition_Codes_Set}
 * @param Storage Storage label or <b>B</b>ase register
 *                and <b>D</b>isplacement
 * @param Immediate-value A single byte value
 * @example <code>[label] CLI D1(B1),I2 </code>
 */
procedure void CLI(storage, immediate-value);
/**
 * COMPARE LOGICAL C. UNDER MASK
 * <br>Each byte of <b>register</b>, under control of <b>mask</b>, is compared to a byte in fullword at <b>storage</b> until an unequal condition or four bytes have been processed.  Condition code is set.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=BD
 * {@link rc4 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Mask Four bits which correspond to the four bytes of <b>register1</b>
 * @param Storage Storage label or <b>B</b>ase register
 *                and <b>D</b>isplacement
 * @example <code>[label] CLM R1,M3,D2(B2) </code>
 */
procedure void CLM(register,mask,storage);
/**
 * COMPARE LOGICAL
 * <br>Contents of <b>register1</b> are compared to contents of <b>register2</b>. Condition code is set.
 * <br>Format={@link rroperands RR} Length=2 OpCode=15
 * {@link rc4 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] CLR R1,R2 </code>
 */
procedure void CLR(storage);
/**
 * COMPARE LOGICAL STRING
 * <br>Storage at address from <b>register1</b> is compared to storage at address from <b>register2</b> until end of string character is found or 256 bytes processed.
 * <br>End of string character is stored in low-order byte of register 0 (high-order bytes of register 0 must be zero).
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B25D
 * {@link rc4 Condition_Codes_Set}
 * @param Register1 Any general purpose register except 0
 * @param Register2 Any general purpose register except 0
 * @param Genral Register 0 is an implied operand
 * @example <code>[label] CLST R1,R2 </code>
 */
procedure void CLST(register1,register2);
/**
 * COMPARE DECIMAL
 * <br>Algebraic comparison (subtraction) between <b>storage1</b> and <b>storage2</b>.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=F9
 * {@link rc4 Condition_Codes_Set}
 * @param Storage1 Storage label or <b>B</b>ase register
 *                and <b>D</b>isplacement with <b>L</b>ength
 * @param Storage2 Storage label or <b>B</b>ase register
 *                and <b>D</b>isplacement with <b>L</b>ength
 * @example <code>[label] CP D1(L1,B1),D2(L2,B2) </code>
 */
procedure void CP(storage1,storage2);
/**
 * COPY ACCESS
 * <br>Contents of access <b>register2</b> are placed in access <b>register1</b>
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B24D
 * @param Register1 Any access register
 * @param Register2 Any access register
 * @example <code>[label] CPYA R1,R2 </code>
 */
procedure void CPYA(register1,register2);
/**
 * COMPARE
 * <br>Contents of <b>register1</b> is compared to contents of <b>register2</b>
 * <br>Format={@link rroperands RR} Length=2 OpCode=19
 * {@link rc4 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] CR R1,R2 </code>
 */
procedure void CR(register1,register2);
/**
 * COMPARE AND SWAP
 * <br>Compare 32 bits of <b>register1</b> to fullword at <b>storage</b>.
 * <br>If operands equal, store <b>register3</b> at <b>storage</b>
 * <br>else load <b>storage</b> into <b>register1</b>
 * <br>Format={@link rsoperands RS} Length=4 OpCode=BA
 * {@link rc6 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register3 Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register
 *                and <b>D</b>isplacement on a fullword boundary
 * @example <code>[label] CS R1,R3,D2(B2) </code>
 */
procedure void CS(register1,register3,storage);
/**
 * CLEAR SUBCHANNEL
 * <br>The  designated subchannel is cleared, the current start or halt function,
 * if any, is terminated  at  the  designated  subchannel,  and  the  channel
 * subsystem  is signaled to asynchronously perform the clear function at the
 * designated subchannel and at the associated device.
 * <br>Format={@link soperands S} Length=4 OpCode=B230
 * {@link rc20 Condition_Codes_Set}
 * @param implied General Register 1 is implied operand and contains subsystem-identification word
 * @example <code>[label] CSCH       </code>
 */
procedure void CSCH();
/**
 * COMPARE UNTIL SUBSTRING EQUAL
 * <b>Register1</b>+1 and <b>register2</b>+1 hold the length of each operand (as 32-bit integers).
 * Low-order byte of register 0 holds the length of the equal substring that must be found (0-255).
 * Low-order byte of register 1 holds the pad character used to pad the shorter operand.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B257
 * {@link rc29 Condition_Codes_Set}
 * @param Register1 Any even-numbered general purpose register, address of operand 1
 * @param implied Register1+1 contains length of operand 1
 * @param Register2 Any even-numbered general purpose register, address of operand 2
 * @param implied Register2+1 contains length of operand 2
 * @example <code>[label] CUSE R1,R2 </code>
 */
procedure void CUSE(register1,register2);
/**
 * CONVERT TO BINARY
 * <br>The 8-byte packed-decimal field at <b>storage</b> is converted to 32-bit binary integer and placed in <b>register</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=4F
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] CVB R1,D2(X2,B2) </code>
 */
procedure void CVB(register,storage);
/**
 * CONVERT TO DECIMAL
 * <br>The 32-bit binary integer in <b>register</b> is converted to packed decimal and stored in 8-bytes at <b>storage</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=4E
 * @param Register1 Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] CVD R1,D2(X2,B2) </code>
 */
procedure void CVD(register,storage);
/**
 * COMPARE (Extended Binary-FLoating-Point)
 * <br>EBFP contents of <b>register1</b> compared to contents of <b>register2</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B349
 * {@link rc25 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] CXBR R1,R2 </code>
 */
procedure void CXBR(register1,register2);
/**
 * CONVERT FROM FIXED (32-bit integer to External Binary-Floating-Point)
 * <br>32-bit integer in <b>register2</b> is converted to EBFP and stored in <b>register1</b>
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B396
 * @param Register1 Any general purpose register
 * @param Register2 Any floating-point register
 * @example <code>[label] CXFBR R1,R2 </code>
 */
procedure void CXFBR(register1,register2);
/**
 * CONVERT FROM FIXED (32-bit integer to Extended Hexadecimal-Floating-Point)
 * <br>32-bit integer in <b>register2</b> is converted to EHFP and stored in <b>register1</b>
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B3B6
 * @param Register1 valid floating-point register pair
 * @param Register2 Any general purpose register
 * @example <code>[label] CXFR R1,R2 </code>
 */
procedure void CXFR(register1,register2);
/**
 * COMPARE (Extended Hexadecimal-FLoating-Point)
 * <br>The <b>registers</b> must point to valid floating-point register pairs. Algebraic compare (subtraction) is performed and condition code is set.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B369
 * {@link rc4 Condition_Codes_Set}
 * @param Register1 Floating-point register pair
 * @param Register2 Floating-point register pair
 * @example <code>[label] CXR R1,R2 </code>
 */
procedure void CXR(register1,register2);
/**
 * DIVIDE
 * <br><b>Register</b> must be an even register number of an even-odd register pair.
 * The pair holds the 64-bit integer dividend and is divided by the fullword at <b>storage</b>.
 * The remainder is placed in <b>register</b> and the quotient is placed in <b>register</b>+1.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=5D
 * @param Register1 Even-numbered general purpose register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] D R1,D2(X2,B2) </code>
 */
procedure void D(register,storage);
/**
 * DIVIDE (Long Hexadecimal-Floating-Point)
 * <br>The LHFP value in <b>register</b> is divided by the value at <b>storage</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=6D
 * @param Register1 Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] DD R1,D2(X2,B2) </code>
 */
procedure void DD(register,storage);
/**
 * DIVIDE (Long Binary-Floating-Point)
 * <br>The LBFP value in <b>register</b> is divided by the value at <b>storage</b>.
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED1D
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] DDB R1,D2(X2,B2) </code>
 */
procedure void DDB(register,storage);
/**
 * DIVIDE (Long Binary-Floating-Point)
 * <br>The LBFP value in <b>register1</b> is divided by the value in <b>register2</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B31D
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] DDBR R1,R2 </code>
 */
procedure void DDBR(register1,register2);
/**
 * DIVIDE (Long Hexadecimal-Floating-Point)
 * <br>The LHFP value in <b>register1</b> is divided by the value at <b>register2</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=2D
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] DDR R1,R2 </code>
 */
procedure void DDR(register1,register2);
/**
 * DIVIDE (Short Hexadecimal-Floating-Point)
 * <br>The SHFP value in <b>register</b> is divided by the value at <b>storage</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=7D
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] DE R1,D2(X2,B2) </code>
 */
procedure void DE(register,storage);
/**
 * DIVIDE (Short Binary-Floating-Point)
 * <br>The SBFP value in <b>register</b> is divided by the value at <b>storage</b>.
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED0D
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] DEB R1,D2(X2,B2) </code>
 */
procedure void DEB(register,storage);
/**
 * DIVIDE (Short Binary-Floating-Point)
 * <br>The SBFP value in <b>register1</b> is divided by the value at <b>register2</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B30D
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] DEBR R1,R2 </code>
 */
procedure void DEBR(register1,register2);
/**
 * DIVIDE (Short Hexadecimal-Floating-Point)
 * <br>The SHFP value in <b>register1</b> is divided by the value at <b>register2</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=3D
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] DER R1,R2 </code>
 */
procedure void DER(register1,register2);
/**
 * DIVIDE TO INTEGER (Long Binary-Floating-Point)
 * <br>The LBFP value in <b>register1</b> is divided by the value in <b>register2</b> and the integer quotient
 * is placed in <b>register3</b>.  The remainder replaces the dividend in <b>register1</b>.  The condition code is set.
 * Rounding takes place under control of the {@link roundingmask mask}.
 * <br>Format={@link rrfoperands RRF} Length=4 OpCode=B35B
 * {@link rc21 Condition_Codes_Set}
 * @param Register1 Any floating-point register, dividend and remainder
 * @param Register2 Any floating-point register, divisor
 * @param Register3 Any floating-point register, integer quotient
 * @param Mask Rounding control mask, see link above
 * @example <code>[label] DIDBR R1,R3,R2,M4 </code>
 */
procedure void DIDBR(register1,register3,register2,mask);
/**
 * DIVIDE TO INTEGER (Short Binary-Floating-Point)
 * <br>The SBFP value in <b>register1</b> is divided by the value in <b>register2</b> and the integer quotient
 * is placed in <b>register3</b>.  The remainder replaces the dividend in <b>register1</b>.  The condition code is set.
 * Rounding takes place under control of the {@link roundingmask mask}.
 * <br>Format={@link rrfoperands RRF} Length=4 OpCode=B353
 * {@link rc21 Condition_Codes_Set}
 * @param Register1 Any floating-point register, dividend and remainder
 * @param Register2 Any floating-point register, divisor
 * @param Register3 Any floating-point register, integer quotient
 * @param Mask Rounding control mask, see link above
 * @example <code>[label] DIEBR R1,R3,R2,M4 </code>
 */
procedure void DIEBR(register1,register3,register2,mask);
/**
 * DIVIDE DECIMAL
 * <br>The packed-decimal value at <b>storage1</b> is divided by the value at <b>storage2</b>.
 * The quotient  and  remainder are placed at <b>storage1</b> in format: packed-decimal quotient (for length of L1-L2) followed by remainder for length of L2
 * <br>Format={@link ssoperands SS} Length=6 OpCode=FD
 * @param Storage1 Storage label or <b>B</b>ase register
 *                and <b>D</b>isplacement with <b>L</b>ength
 * @param Storage2 Storage label or <b>B</b>ase register
 *                and <b>D</b>isplacement with <b>L</b>ength
 * @example <code>[label] DP D1(L1,B1),D2(L2,B2) </code>
 */
procedure void DP(storage1,storage2);
/**
 * DIVIDE
 * <br><b>Register1</b> must be an even register number of an even-odd register pair.
 * The pair holds the 64-bit integer dividend and is divided by the 32-bit contents of <b>register2</b>.
 * The remainder (32-bit integer) is placed in <b>register1</b> and the quotient (32-bit integer) is placed in <b>register1</b>+1.
 * <br>Format={@link rroperands RR} Length=2 OpCode=1D
 * @param Register1 Any even-numbered general purpose register, dividend, and remainder
 * @param implied Register1+1 quotient
 * @param Register2 Any general purpose register, divisor
 * @example <code>[label] DR R1,R2 </code>
 */
procedure void DR(register1,register2);
/**
 * DIVIDE (Extended Binary-FLoating-Point)
 * <br>The EBFP value in <b>register1</b> is divided by the value in <b>register2</b>.
 * The register fields must indicate floating-point register pairs.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B34D
 * @param Register1 Any even-numbered floating-point register, dividend and quotient
 * @param Register2 Any even-numbered floating-point register, divisor
 * @example <code>[label] DXBR R1,R2 </code>
 */
procedure void DXBR(register1,register2);
/**
 * DIVIDE (Extended Hexadecimal-FLoating-Point)
 * <br>The EHFP value in <b>register1</b> is divided by the value in <b>register2</b>.
 * The register fields must indicate floating-point register pairs.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B22D
 * @param Register1 Any even-numbered floating-point register, dividend and quotient
 * @param Register2 Any even-numbered floating-point register, divisor
 * @example <code>[label] DXR R1,R2 </code>
 */
procedure void DXR(register1,register2);
/**
 * EXTRACT ACCESS
 * <br>The contents of access <b>register2</b> are placed in general <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B24F
 * @param Register1 Any general register
 * @param Register2 Any access register
 * @example <code>[label] EAR R1,R2 </code>
 */
procedure void EAR(register1,register2);
/**
 * EDIT
 * <br>The packed-decimal digits at <b>storage2</b> are converted to display
 * format under control of the {@link editpattern edit_pattern} at <b>storage1</b> and replaces <b>storage1</b>.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=DE
 * {@link rc8 Condition_Codes_Set}
 * @param Storage1 Storage label or <b>B</b>ase register
 *                and <b>D</b>isplacement with <b>L</b>ength
 * @param Storage Storage label or <b>B</b>ase register
 *                and <b>D</b>isplacement
 * @example <code>[label] ED D1(L,B1),D2(B2) </code>
 */
procedure void ED(storage1,storage2);
/**
 * EDIT AND MARK
 * <br>The packed-decimal digits at <b>storage2</b> are converted to display
 * format under control of the {@link editpattern edit_pattern} at <b>storage1</b> and replaces <b>storage1</b>.
 * The address of the first significant result byte is placed in general register 1.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=DF
 * {@link rc8 Condition_Codes_Set}
 * @param Storage1 Storage label or <b>B</b>ase register
 *                and <b>D</b>isplacement with <b>L</b>ength
 * @param Storage2 Storage label or <b>B</b>ase register
 *                and <b>D</b>isplacement
 * @param implied General Register 1 holds address of first significant digit.
 * @example <code>[label] EDMK D1(L,B1),D2(B2) </code>
 */
procedure void EDMK(storage1,storage2);
/**
 * EXTRACT FPC
 * <br>The contents of the FPC (floating-point-control) register are placed in <b>register</b>
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B38C
 * @param Register1 Any general purpose register
 * @param implied Floating-Point-Control Register
 * @example <code>[label] EFPC R1 </code>
 */
procedure void EFPC(register1);
/**
 * EXTRACT PRIMARY ASN
 * <br>The  16-bit  PASN,  bits  16-31  of  control  register 4, is placed in bit
 * positions 16-31 of general register R1.  Bits 0-15 of the general register
 * are set to zeros.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B226
 * @param Register Any general purpose register
 * @example <code>[label] EPAR R1 </code>
 */
procedure void EPAR(register);
/**
 * EXTRACT STACKED REGISTERS
 * <br>The  contents  of a set of general registers and a set of access registers
 * that were saved in the last state entry in the linkage stack are  restored
 * to  the registers.  Each set of registers begins with <b>register1</b> and ends
 * with <b>register2</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B249
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] EREG R1,R2 </code>
 */
procedure void EREG(register1,register2);
/**
 * EXTRACT SECONDARY ASN
 * <br>The  16-bit  SASN,  bits  16-31  of  control  register 3, is placed in bit
 * positions 16-31 of general <b>register1</b>.  Bits 0-15 of general <b>register1</b>
 * are set to zeros.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B227
 * @param Register1 Any general purpose register
 * @example <code>[label] ESAR R1 </code>
 */
procedure void ESAR(register1);
/**
 * EXTRACT STACKED STATE
 * <br>The contents of one of the four eight-byte fields immediately preceding
 * the entry descriptor of the last state entry in the linkage stack are
 * placed in the pair of general registers designated by the <b>register1</b> field.  The
 * condition code is set to indicate whether the state entry is a branch
 * state entry or a program-call state entry. Bits 24-31 of general <b>register2</b> are
 * an unsigned binary integer that is used to select the state-entry byte positions
 * from which information is to be extracted.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B24A
 * {@link rc22 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] ESTA R1,R2 </code>
 */
procedure void ESTA(register1,register2);
/**
 * EXECUTE
 * <br>The  single  instruction  at <b>storage</b> is modified by the
 * contents of <b>register1</b>, and the resulting instruction, called the
 * target instruction, is executed.  Condition code is set per the target
 * instruction.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=44
 * @param Register Any general purpose register, when not 0, bits 8-15 of target instruction are OR'ed with bits 24-31 of register1
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] EX R1,D2(X2,B2) </code>
 */
procedure void EX(register,storage);
/**
 * LOAD FP INTEGER (Long Binary-Floating-Point)
 * <br>The LBFP value in <b>register2</b> is rounded to an integer value and
 * placed in <b>register1</b>.  Rounding is controlled by {@link roundingmask mask}.
 * <br>Format={@link rrfoperands RRF} Length=4 OpCode=B35F
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @param Mask Rounding control mask, see link above
 * @example <code>[label] FIDBR R1,M3,R2 </code>
 */
procedure void FIDBR(register1,mask,register2);
/**
 * LOAD FP INTEGER (Long Hexadecimal-Floating-Point)
 * <br>The LHFP value in <b>register2</b> is rounded to an integer value and
 * placed in <b>register1</b>.  Rounding is controlled by {@link roundingmask mask}.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B37F
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @param Mask Rounding control mask, see link above
 * @example <code>[label] FIDR R1,R2 </code>
 */
procedure void FIDR(register1,mask,register2);
/**
 * LOAD FP INTEGER (Short Binary-Floating-Point)
 * <br>The SBFP value in <b>register2</b> is rounded to an integer value and
 * placed in <b>register1</b>.  Rounding is controlled by {@link roundingmask mask}.
 * <br>Format={@link rrfoperands RRF} Length=4 OpCode=B357
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @param Mask Rounding control mask, see link above
 * @example <code>[label] FIEBR R1,M3,R2 </code>
 */
procedure void FIEBR(register1,mask,register2);
/**
 * LOAD FP INTEGER (Short Hexadecimal-Floating-Point)
 * <br>The SHFP value in <b>register2</b> is rounded to an integer value and
 * placed in <b>register1</b>.  Rounding is controlled by {@link roundingmask mask}.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B377
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @param Mask Rounding control mask, see link above
 * @example <code>[label] FIER R1,R2 </code>
 */
procedure void FIER(register1,mask,register2);
/**
 * LOAD FP INTEGER (Extended Binary-Floating-Point)
 * <br>The EBFP value in <b>register2</b> is rounded to an integer value and
 * placed in <b>register1</b>.  Rounding is controlled by {@link roundingmask mask}.
 * <br>Format={@link rrfoperands RRF} Length=4 OpCode=B347
 * @param Register1 Any floating-point register pair
 * @param Register2 Any floating-point register pair
 * @param Mask Rounding control mask, see link above
 * @example <code>[label] FIXBR R1,M3,R2 </code>
 */
procedure void FIXBR(register1,mask,register2);
/**
 * LOAD FP INTEGER (Extended Hexadecimal-Floating-Point)
 * <br>The EHFP value in <b>register2</b> is rounded to an integer value and
 * placed in <b>register1</b>.  Rounding is controlled by {@link roundingmask mask}.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B367
 * @param Register1 Any floating-point register pair
 * @param Register2 Any floating-point register pair
 * @param Mask Rounding control mask, see link above
 * @example <code>[label] FIXR R1,R2 </code>
 */
procedure void FIXR(register1,mask,register2);
/**
 * HALVE (Long Hexadecimal-Floating-Point)
 * <br>The LHFP value in <b>register2</b> is divided by 2 and the result is placed in <b>register1</b>
 * <br>Format={@link rroperands RR} Length=2 OpCode=24
 * @param Register1 Any floating-point register, integer quotient
 * @param Register2 Any floating-point register, dividend
 * @example <code>[label] HDR R1,R2 </code>
 */
procedure void HDR(storage);
/**
 * HALVE (Short Hexadecimal-Floating-Point)
 * <br>The SHFP value in <b>register2</b> is divided by 2 and the result is placed in <b>register1</b>
 * <br>Format={@link rroperands RR} Length=2 OpCode=34
 * @param Register1 Any floating-point register, integer quotient
 * @param Register2 Any floating-point register, dividend
 * @example <code>[label] HER R1,R2 </code>
 */
procedure void HER(storage);
/**
 * HALT SUBCHANNEL
 * <br>The  current  start  function,  if  any,  is  terminated at the designated
 * subchannel, and  the  channel  subsystem  is  signaled  to  asynchronously
 * perform  the  halt  function  at  the  designated  subchannel  and  at the
 * associated device.
 * <br>Format={@link soperands S} Length=4 OpCode=B231
 * {@link rc23 Condition_Codes_Set}
 * @param implied General Register 1 contains the subsystem-identification word, which designates the subchannel that is to be halted.
 * @example <code>[label] HSCH       </code>
 */
procedure void HSCH();
/**
 * INSERT ADDRESS SPACE CONTROL
 * <br>The  address-space-control  bits,  bits  16 and 17 of the current PSW, are
 * placed in reversed order in bit positions 22 and 23  of <b>register</b>;
 * that is, bit 16 is placed in bit position 23, and bit 17 is placed in
 * bit position 22.  Bits 16-21 of the register are set to zeros, and bits
 * 0-15 and 24-31 of the register remain unchanged. The
 * address-space-control bits are also used to set the condition code.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B224
 * {@link rc24 Condition_Codes_Set}
 * @param Register Any general purpose register
 * @example <code>[label] IAC R1 </code>
 */
procedure void IAC(register);
/**
 * INSERT CHARACTER
 * <br>The byte at <b>storage</b> is inserted into bit positions
 * 24-31 of <b>register</b>.  The remaining bits in the register remain
 * unchanged.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=43
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register,
 *                inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] IC R1,D2(X2,B2) </code>
 */
procedure void IC(register,storage);
/**
 * INSERT CHARACTERS UNDER MASK
 * <br>Bytes of <b>storage</b> are inserted into bytes of <b>register</b>,
 * under the control of <b>mask</b>.  The number of bytes moved from <b>storage</b>
 * corresponds to the number of 1's in the mask.  A mask value of 11 (b'1011') will
 * move three consecutive bytes from storage to bytes 1, 3, and 4 of <b>register</b> and leave byte 2
 * unchanged.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=BF
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Mask Four bits which correspond to the bytes of register
 * {@link rc7 Condition_Codes_Set}
 * @example <code>[label] ICM R1,M3,D2(B2) </code>
 */
procedure void ICM(register,mask,storage);
/**
 * INSERT PSW KEY
 * The  four-bit  PSW-key,  bits  8-11 of the current PSW, is inserted in bit
 * positions 24-27 of General Register 2, and bits 28-31 of that register are
 * set to zeros.  Bits 0-23 of General Register 2 remain unchanged.
 * <br>Format={@link soperands S} Length=4 OpCode=B20B
 * @param implied General Register 2, see above
 * @example <code>[label] IPK R1 </code>
 */
procedure void IPK();
/**
 * INSERT PROGRAM MASK
 * <br>The condition code and program mask from the current PSW are inserted into
 * bit positions 2 and 3 and 4-7, respectively, of <b>register</b>.  Bits
 * 0 and 1 of the register are set to zeros; bits 8-31 are left unchanged.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B222
 * @param Register Any general purpose register
 * @example <code>[label] IPM R1 </code>
 */
procedure void IPM(register);
/**
 * INVALIDATE PAGE TABLE ENTRY
 * <br>The designated page-table entry is invalidated, and the translation-lookaside buffers (TLBs)
 * in all CPUs in the configuration are cleared of the associated entries.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B221
 * @param Register1 Any general purpose register in the format of a segment-table entry with only the page-table origin used.
 * @param Register2 Any general purpose register in the format of a virtual address with only the page index used.
 * @example <code>[label] IPTE R1,R2 </code>
 */
procedure void IPTE(register1,register2);
/**
 * INSERT STORAGE KEY EXTENDED
 * <br>The storage key for the block that is addressed by the contents of <b>register2</b>
 * are placed in bits 24-30 of <b>register1</b> (bit 31 is set to zero).
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B229
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] ISKE R1,R2 </code>
 */
procedure void ISKE(register1,register2);
/**
 * INSERT VIRTUAL STORAGE KEY
 * <br>The storage key for the location designated by the virtual address in <b>register2</b> is placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B223
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] IVSK R1,R2 </code>
 */
procedure void IVSK(register1,register2);
/**
 * COMPARE AND SIGNAL (Long Binary-Floating-Point)
 * <br>Compare <b>register</b> to <b>storage</b>, set condition code.  Indicate
 * QNaN operands with IEEE-invalid-operation condition.
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED18
 * {@link rc25 Condition_Codes_Set}
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] KDB R1,D2(X2,B2) </code>
 */
procedure void KDB(storage);
/**
 * COMPARE AND SIGNAL (Long Binary-Floating-Point)
 * <br>Compare <b>register1</b> to <b>register2</b>, set condition code.  Indicate
 * QNaN operands with IEEE-invalid-operation condition.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B318
 * {@link rc25 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] KDBR R1,R2 </code>
 */
procedure void KDBR(storage);
/**
 * COMPARE AND SIGNAL (Short Binary-Floating-Point)
 * <br>Compare <b>register</b> to <b>storage</b>, set condition code.  Indicate
 * QNaN operands with IEEE-invalid-operation condition.
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED08
 * {@link rc25 Condition_Codes_Set}
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] KEB R1,D2(X2,B2) </code>
 */
procedure void KEB(storage);
/**
 * COMPARE AND SIGNAL (Short Binary-Floating-Point)
 * <br>Compare <b>register1</b> to <b>register2</b>, set condition code.  Indicate
 * QNaN operands with IEEE-invalid-operation condition.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B308
 * {@link rc25 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] KEBR R1,R2 </code>
 */
procedure void KEBR(storage);
/**
 * COMPARE AND SIGNAL (Extended Binary-FLoating-Point)
 * <br>Compare <b>register1</b> to <b>register2</b>, set condition code.  Indicate
 * QNaN operands with IEEE-invalid-operation condition.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B348
 * {@link rc25 Condition_Codes_Set}
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any valid floating-point register pair
 * @example <code>[label] KXBR R1,R2 </code>
 */
procedure void KXBR(storage);
/**
 * LOAD
 * <br>The fullword at <b>storage</b> is placed in <b>register</b>
 * <br>Format={@link rxoperands RX} Length=4 OpCode=58
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] L R1,D2(X2,B2) </code>
 */
procedure void L(storage);
/**
 * LOAD ADDRESS
 * <br>The address of memory represented by <b>storage</b> is inserted into <b>register</b>.
 * The high-order bits of <b>register</b> are set to zero (depending on addressing mode).
 * <br>Format={@link rxoperands RX} Length=4 OpCode=41
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] LA R1,D2(X2,B2) </code>
 */
procedure void LA(register,storage);
/**
 * LOAD ADDRESS EXTENDED
 * <br>The address of memory represented by <b>storage</b> is inserted into general <b>register</b>.
 * The access register matching the general is also updated based on the address-space-control bits.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=51
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @param implied Access register with same number as general register
 * @example <code>[label] LAE R1,D2(X2,B2) </code>
 */
procedure void LAE(storage);
/**
 * LOAD ACCESS MULTIPLE
 * <br>The set of access registers starting with access <b>register1</b> and ending
 * with access <b>register3</b> is loaded from the locations designated by <b>storage</b>.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=9A
 * @param Register1 Any access register
 * @param Register3 Any access register
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] LAM R1,R3,D2(B2) </code>
 */
procedure void LAM(storage);
/**
 * LOAD ADDRESS SPACE PARAMETERS
 * <br>The contents of the doubleword at the first-operand location contain
 * values to be loaded into control registers 3 and 4, including a secondary
 * ASN and a primary ASN.  Execution of the instruction consists in
 * performing four major steps: PASN translation, SASN  translation, SASN
 * authorization, and control-register loading.  Each of these steps may or
 * may not be performed, depending on the outcome of certain tests and on the
 * setting of bits 29-31 of the second-operand address.   These steps, when
 * successful, obtain additional values, which are loaded into control
 * registers 1, 5, and 7.  When the steps are not successful, no control
 * registers are changed, and the reason is indicated in the condition code.
 * <br>Format={@link sseoperands SSE} Length=6 OpCode=E500
 * {@link rc26 Condition_Codes_Set}
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 *                Doubleword holding values to be loaded
 * @param Control The right-most three bits control portions of the operation.
 * @example <code>[label] LASP D1(B1),D2(B2) </code>
 */
procedure void LASP(storage,control);
/**
 * LOAD COMPLEMENT (Long Binary-Floating-Point)
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B313
 * {@link rc8 Condition_Codes_Set}
 * @example <code>[label] LCDBR R1,R2 </code>
 */
procedure void LCDBR(storage);
/**
 * LOAD COMPLEMENT (Long Hexadecimal-Floating-Point)
 * <br>The contents of <b>register2</b> are placed in <b>register1</b>
 * with the sign bit inverted.
 * <br>Format={@link rroperands RR} Length=2 OpCode=23
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LCDR R1,R2 </code>
 */
procedure void LCDR(register1,register2);
/**
 * LOAD COMPLEMENT (Short Binary-Floating-Point)
 * <br>The contents of <b>register2</b> are placed in <b>register1</b>
 * with the sign bit inverted.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B303
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LCEBR R1,R2 </code>
 */
procedure void LCEBR(register1,register2);
/**
 * LOAD COMPLEMENT (Short Hexadecimal-Floating-Point)
 * <br>The contents of <b>register2</b> are placed in <b>register1</b>
 * with the sign bit inverted.
 * <br>Format={@link rroperands RR} Length=2 OpCode=33
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LCER R1,R2 </code>
 */
procedure void LCER(register1,register2);
/**
 * LOAD COMPLEMENT
 * <br>The two's complement of <b>register2</b> is placed in <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=13
 * {@link rc1 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] LCR R1,R2 </code>
 */
procedure void LCR(register1,register2);
/**
 * LOAD CONTROL
 * <br>The control registers from <b>register1</b> through <b>register3</b>
 * are loaded with the fullwords starting at <b>storage</b>.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=B7
 * @param Register1 Any control register
 * @param Register3 Any control register
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement.  Must point to a fullword boundary.
 * @example <code>[label] LCTL R1,R3,D2(B2) </code>
 */
procedure void LCTL(register1,register3,storage);
/**
 * LOAD COMPLEMENT (Extended Binary-FLoating-Point)
 * <br>The contents of <b>register2</b> are placed in <b>register1</b> with the sign bit inverted.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B343
 * {@link rc8 Condition_Codes_Set}
 * @param Register Any valid floating-point register pair
 * @param Register Any valid floating-point register pair
 * @example <code>[label] LCXBR R1,R2 </code>
 */
procedure void LCXBR(register1,register2);
/**
 * LOAD COMPLEMENT (Extended Hexadecimal-FLoating-Point)
 * <br>The contents of <b>register2</b> are placed in <b>register1</b>
 * with the sign bit inverted.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B363
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any valid floating-point register pair
 * @example <code>[label] LCXR R1,R2 </code>
 */
procedure void LCXR(storage);
/**
 * LOAD (long)
 * <br>The value at <b>storage</b> is placed in <b>register</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=68
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] LD R1,D2(X2,B2) </code>
 */
procedure void LD(register,storage);
/**
 * LOAD LENGTHENED (short to long HFP)
 * <br>The value at <b>storage</b> is loaded into <b>register</b>.
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED24
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] LDE R1,D2(X2,B2) </code>
 */
procedure void LDE(register,storage);
/**
 * LOAD LENGTHENED (short to long BFP)
 * <br>The value at <b>storage</b> is loaded into <b>register</b>.
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED04
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] LDEB R1,D2(X2,B2) </code>
 */
procedure void LDEB(storage);
/**
 * LOAD LENGTHENED (short to long BFP)
 * <br>The value at <b>register2</b> is loaded into <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B304
 * @param Register Any floating-point register
 * @param Register Any floating-point register
 * @example <code>[label] LDEBR R1,R2 </code>
 */
procedure void LDEBR(register1,register2);
/**
 * LOAD LENGTHENED (short to long HFP)
 * <br>The value at <b>register2</b> is loaded into <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B324
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LDER R1,R2 </code>
 */
procedure void LDER(register1,register2);
/**
 * LOAD (long)
 * <br>The value in <b>register2</b> is loaded into <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=28
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LDR R1,R2 </code>
 */
procedure void LDR(register1,register2);
/**
 * LOAD ROUNDED (extended to long BFP)
 * <br>Contents of <b>register2</b> are rounded and placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B345
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LDXBR R1,R2 </code>
 */
procedure void LDXBR(register1,register2);
/**
 * LOAD ROUNDED (extended to long HFP)
 * <br>Contents of <b>register2</b> are rounded and placed in <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=25
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LDXR R1,R2 </code>
 */
procedure void LDXR(register1,register2);
/**
 * LOAD (short)
 * <br>The contents at <b>storage</b> are placed in <b>register</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=78
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] LE R1,D2(X2,B2) </code>
 */
procedure void LE(register,storage);
/**
 * LOAD ROUNDED (long to short BFP)
 * <br>The contents of <b>register2</b> are rounded and placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B344
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LEDBR R1,R2 </code>
 */
procedure void LEDBR(register1,register2);
/**
 * LOAD ROUNDED (long to short HFP)
 * <br>Contents of <b>register2</b> are rounded and placed in <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=35
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LEDR R1,R2 </code>
 */
procedure void LEDR(register1,register2);
/**
 * LOAD (short)
 * <br>Contents of <b>register2</b> are placed in <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=38
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LER R1,R2 </code>
 */
procedure void LER(register1,register2);
/**
 * LOAD ROUNDED (extended to short BFP)
 * <br>Contents of <b>register2</b> are rounded and placed in <b>register1</b>.
 * <br>Contents of <b>register2</b> are rounded and placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B346
 * @param Register1 Any floating-point register pair
 * @param Register2 Any floating-point register pair
 * @example <code>[label] LEXBR R1,R2 </code>
 */
procedure void LEXBR(storage);
/**
 * LOAD ROUNDED (extended to short HFP)
 * <br>Contents of <b>register2</b> are rounded and placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B366
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register pair
 * @example <code>[label] LEXR R1,R2 </code>
 */
procedure void LEXR(storage);
/**
 * LOAD FPC
 * <br>The four-bytes at <b>storage</b> is loaded into the Floating-Point-Control register
 * <br>Format={@link soperands S} Length=4 OpCode=B29D
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] LFPC D2(B2) </code>
 */
procedure void LFPC(storage);
/**
 * LOAD HALFWORD
 * <br>The halfword at <b>storage</b> is loaded int <b>register</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=48
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] LH R1,D2(X2,B2) </code>
 */
procedure void LH(storage);
/**
 * LOAD HALFWORD IMMEDIATE
 * <br>The <b>immediate-value</b> in bits 16-31 of the instruction are loaded
 * into <b>register</b>.  The sign bit is extended to fill the left-most bits of register.
 * <br>Format={@link rioperands RI} Length=4 OpCode=A78
 * @param Register Any general purpose register
 * @param immediate-value 16-bit signed binary integer
 * @example <code>[label] LHI R1,I2 </code>
 */
procedure void LHI(storage);
/**
 * LOAD MULTIPLE
 * <br>Fullwords of memory, starting at <b>storage</b>, are loaded into <b>register1</b> through
 * <b>register3</b>. Register 15 follows register 0.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=98
 * @param Register Any general purpose register
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] LM R1,R3,D2(B2) </code>
 */
procedure void LM(storage);
/**
 * LOAD NEGATIVE (Long Binary-Floating-Point)
 * <br>The value in <b>register2</b> is placed in <b>register1</b> and the sign bit is set to one.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B311
 * {@link rc30 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LNDBR R1,D2(X2,B2) </code>
 */
procedure void LNDBR(register1,register2);
/**
 * LOAD NEGATIVE (Long Hexadecimal-Floating-Point)
 * <br>The value in <b>register2</b> is placed in <b>register1</b> and the sign bit is set to one.
 * <br>Format={@link rroperands RR} Length=2 OpCode=21
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LNDR R1,R2 </code>
 */
procedure void LNDR(register1,register2);
/**
 * LOAD NEGATIVE (Short Binary-Floating-Point)
 * <br>The value in <b>register2</b> is placed in <b>register1</b> and the sign bit is set to one.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B301
 * {@link rc30 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LNEBR R1,D2(X2,B2) </code>
 */
procedure void LNEBR(register1,register2);
/**
 * LOAD NEGATIVE (Short Hexadecimal-Floating-Point)
 * <br>The value in <b>register2</b> is placed in <b>register1</b> and the sign bit is set to one.
 * <br>Format={@link rroperands RR} Length=2 OpCode=31
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LNER R1,R2 </code>
 */
procedure void LNER(register1,register2);
/**
 * LOAD NEGATIVE
 * <br>The two's complement of the value in <b>reigster2</b> is placed in <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=11
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] LNR R1,R2 </code>
 */
procedure void LNR(register1,register2);
/**
 * LOAD NEGATIVE (Extended Binary-FLoating-Point)
 * <br>The value in <b>register2</b> is placed in <b>register1</b> and the sign bit is set to one.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B341
 * {@link rc30 Condition_Codes_Set}
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any valid floating-point register pair
 * @example <code>[label] LNXBR R1,D2(X2,B2) </code>
 */
procedure void LNXBR(register1,register2);
/**
 * LOAD NEGATIVE (Extended Hexadecimal-Floating-Point)
 * <br>The value in <b>register2</b> is placed in <b>register1</b> and the sign bit is set to one.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B361
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any valid floating-point register pair
 * @example <code>[label] LNXR R1,R2 </code>
 */
procedure void LNXR(register1,register2);
/**
 * LOAD POSITIVE (Long Binary-Floating-Point)
 * <br>The value in <b>register2</b> is placed in <b>register1</b> and the sign bit is set to zero.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B310
 * {@link rc31 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LPDBR R1,R2 </code>
 */
procedure void LPDBR(register1,register2);
/**
 * LOAD POSITIVE (Long Hexadecimal-Floating-Point)
 * <br>The value in <b>register2</b> is placed in <b>register1</b> and the sign bit is set to zero.
 * <br>Format={@link rroperands RR} Length=2 OpCode=20
 * {@link rc32 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LPDR R1,R2 </code>
 */
procedure void LPDR(register1,register2);
/**
 * LOAD POSITIVE (Short Binary-Floating-Point)
 * <br>The value in <b>register2</b> is placed in <b>register1</b> and the sign bit is set to zero.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B300
 * {@link rc31 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LPEBR R1,R2 </code>
 */
procedure void LPEBR(register1,register2);
/**
 * LOAD POSITIVE (Short Hexadecimal-Floating-Point)
 * <br>The value in <b>register2</b> is placed in <b>register1</b> and the sign bit is set to zero.
 * <br>Format={@link rroperands RR} Length=2 OpCode=30
 * {@link rc32 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LPER R1,R2 </code>
 */
procedure void LPER(register1,register2);
/**
 * LOAD POSITIVE
 * <br>The absolute value of the value in <b>register2</b> is placed in <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=10
 * {@link rc9 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] LPR R1,R2 </code>
 */
procedure void LPR(storage);
/**
 * LOAD PSW
 * <br>The current PSW is replaced with the value at <b>storage</b>
 * <br>Format={@link soperands S} Length=4 OpCode=82
 * @param Storage Double word referenced by <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] LPSW D2(B2) </code>
 */
procedure void LPSW(storage);
/**
 * LOAD POSITIVE (Extended Binary-FLoating-Point)
 * <br>The value in <b>register2</b> is placed in <b>register1</b> and the sign bit is set to zero.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B340
 * {@link rc31 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LPXBR R1,R2 </code>
 */
procedure void LPXBR(register1,register2);
/**
 * LOAD POSITIVE (Extended Hexadecimal-FLoating-Point)
 * <br>The value in <b>register2</b> is placed in <b>register1</b> and the sign bit is set to zero.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B360
 * {@link rc32 Condition_Codes_Set}
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any valid floating-point register pair
 * @example <code>[label] LPXR R1,R2 </code>
 */
procedure void LPXR(register1,register2);
/**
 * LOAD
 * <br>The contents of <b>register2</b> are placed in <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=18
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] LR R1,R2 </code>
 */
procedure void LR(storage);
/**
 * LOAD REAL ADDRESS
 * <br>The real address corresponding to the <b>storage</b> virtual address is
 * placed in <b>register1</b>
 * <br>Format={@link rxoperands RX} Length=4 OpCode=B1
 * {@link rc33 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] LRA R1,D2(X2,B2) </code>
 */
procedure void LRA(register,storage);
/**
 * LOAD ROUNDED (extended to long HFP)
 * <br>Contents of <b>register2</b> are rounded to long HFP and loaded into <b>register1</b>
 * <br>Format={@link rroperands RR} Length=2 OpCode=25
 * @param Register1 Any floating-point register
 * @param Register2 Any valid floating-point register pair
 * @example <code>[label] LRDR R1,R2 </code>
 */
procedure void LRDR(register1,register2);
/**
 * LOAD ROUNDED (long to short HFP)
 * <br>Contents of <b>register2</b> are rounded to short HFP and loaded into <b>reigster1</b>
 * <br>Format={@link rroperands RR} Length=2 OpCode=35
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LRER R1,R2 </code>
 */
procedure void LRER(register1,register2);
/**
 * LOAD AND TEST (Long Binary-Floating-Point)
 * <br>Contents of <b>register2</b> are placed in <b>register1</b> and the condition code is set.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B312
 * {@link rc27 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LTDBR R1,R2 </code>
 */
procedure void LTDBR(register1,register2);
/**
 * LOAD AND TEST (Long Hexadecimal-Floating-Point)
 * <br>Contents of <b>register2</b> are placed in <b>register1</b> and the condition code is set.
 * <br>Format={@link rroperands RR} Length=2 OpCode=22
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LTDR R1,R2 </code>
 */
procedure void LTDR(register1,register2);
/**
 * LOAD AND TEST (Short Binary-Floating-Point)
 * <br>Contents of <b>register2</b> are placed in <b>register1</b> and the condition code is set.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B302
 * {@link rc27 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LTEBR R1,R2 </code>
 */
procedure void LTEBR(register1,register2);
/**
 * LOAD AND TEST (Short Hexadecimal-Floating-Point)
 * <br>Contents of <b>register2</b> are placed in <b>register1</b> and the condition code is set.
 * <br>Format={@link rroperands RR} Length=2 OpCode=32
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] LTER R1,R2 </code>
 */
procedure void LTER(register1,register2);
/**
 * LOAD AND TEST
 * <br>Contents of <b>register2</b> are placed in <b>register1</b> and the condition code is set.
 * <br>Format={@link rroperands RR} Length=2 OpCode=12
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] LTR R1,R2 </code>
 */
procedure void LTR(register1,register2);
/**
 * LOAD AND TEST (Extended Binary-FLoating-Point)
 * <br>Contents of <b>register2</b> are placed in <b>register1</b> and the condition code is set.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B342
 * {@link rc27 Condition_Codes_Set}
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any valid floating-point register pair
 * @example <code>[label] LTXBR R1,R2 </code>
 */
procedure void LTXBR(register1,register2);
/**
 * LOAD AND TEST (Extended Hexadecimal-Floating-Point)
 * <br>Contents of <b>register2</b> are placed in <b>register1</b> and the condition code is set.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B362
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any valid floating-point register pair
 * @example <code>[label] LTXR R1,R2 </code>
 */
procedure void LTXR(register1,register2);
/**
 * LOAD USING REAL ADDRESS
 * <br>The word at the real-storage location addressed by the contents of <b>register2</b> is placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B24B
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register, contents must point to a word boundary
 * @example <code>[label] LURA R1,R2 </code>
 */
procedure void LURA(register1,register2);
/**
 * LOAD LENGTHENED (long to ext. HFP)
 * <br>The value at <b>storage</b> is expanded to extended format and placed in <b>register1</b>.
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED25
 * @param Register Any valid floating-point register pair
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] LXD R1,D2(X2,B2) </code>
 */
procedure void LXD(register,storage);
/**
 * LOAD LENGTHENED (long to ext. BFP)
 * <br>The value at <b>storage</b> is expanded to extended format and placed in <b>register1</b>
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED05
 * @param Register Any valid floating-point register pair
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] LXDB R1,D2(X2,B2) </code>
 */
procedure void LXDB(register,storage);
/**
 * LOAD LENGTHENED (long to ext. BFP)
 * <br>The value in <b>register2</b> is expanded to extended format and placed in <b>reigster1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B305
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any floating-point register
 * @example <code>[label] LXDBR R1,R2 </code>
 */
procedure void LXDBR(register1,register2);
/**
 * LOAD LENGTHENED (long to ext. HFP)
 * <br>The contents of <b>register2</b> are expanded to extended format and placed in <b>register1</b>
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B325
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any floating-point register
 * @example <code>[label] LXDR R1,R2 </code>
 */
procedure void LXDR(register1,register2);
/**
 * LOAD LENGTHENED (short to ext. HFP)
 * <br>The value at <b>storage</b> is expanded to extended format and placed in <b>register1</b>
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED26
 * @param Register Any valid floating-point register pair
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] LXE R1,D2(X2,B2) </code>
 */
procedure void LXE(register,storage);
/**
 * LOAD LENGTHENED (short to ext. BFP)
 * <br>The value at <b>storage</b> is expanded to extended format and placed in <b>register</b>
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED06
 * @param Register Any valid floating-point register pair
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] LXEB R1,D2(X2,B2) </code>
 */
procedure void LXEB(register,storage);
/**
 * LOAD LENGTHENED (short to ext. BFP)
 * <br>The value in <b>register2</b> is expanded to extended format and placed in <b>register1</b>
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B306
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any floating-point register
 * @example <code>[label] LXEBR R1,R2 </code>
 */
procedure void LXEBR(register1,register2);
/**
 * LOAD LENGTHENED (short to ext. HFP)
 * <br>The value in <b>register2</b> is expanded to extended format and placed in <b>register1</b>
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B326
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any floating-point register
 * @example <code>[label] LXER R1,R2 </code>
 */
procedure void LXER(register1,register2);
/**
 * LOAD (extended)
 * <br>Contents of <b>register2</b> are loaded unchanged int <b>register1</b>
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B365
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any valid floating-point register pair
 * @example <code>[label] LXR R1,R2 </code>
 */
procedure void LXR(register1,register2);
/**
 * LOAD ZERO (long)
 * <br>All bits of <b>register</b> are set to 0's
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B375
 * @param Register Any floating-point register
 * @example <code>[label] LZDR R1 </code>
 */
procedure void LZDR(register);
/**
 * LOAD ZERO (short)
 * <br>All bits of <b>register</b> are set to 0's
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B374
 * @param Register Any floating-point register
 * @example <code>[label] LZER R1 </code>
 */
procedure void LZER(register);
/**
 * LOAD ZERO (extended)
 * <br>All bits of <b>register</b> are set to 0's
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B376
 * @param Register2 Any valid floating-point register pair
 * @example <code>[label] LZXR R1 </code>
 */
procedure void LZXR(register);
/**
 * MULTIPLY
 * <br>The 32-bit value in <b>register1</b>+1 is multipled by the 32-bit value in the follword at <b>storage</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=5C
 * @param Register Any general purpose register pair (must be even).  Doubleword result in in R1+(R1+1)
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] M R1,D2(X2,B2) </code>
 */
procedure void M(register,storage);
/**
 * MULTIPLY AND ADD (Long Binary-Floating-Point)
 * <br>The contents of <b>storage</b> and <b>reigster3</b> are multiplied together and then
 * the contents of <b>register1</b> are added.  Results are stored in <b>register1</b>
 * <br>Format={@link rxoperands RX}F Length=6 OpCode=ED1E
 * @param Register1 Any floating-point register
 * @param Register3 Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] MADB R1,R3,D2(X2,B2) </code>
 */
procedure void MADB(register1,register3,storage);
/**
 * MULTIPLY AND ADD (Long Binary-Floating-Point)
 * <br>The contents of <b>register2</b> and <b>reigster3</b> are multiplied together and then
 * the contents of <b>register1</b> are added.  Results are stored in <b>register1</b>
 * <br>Format={@link rrfoperands RRF} Length=4 OpCode=B31E
 * @param Register1 Any floating-point register
 * @param Register3 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] MADBR R1,R3,R2 </code>
 */
procedure void MADBR(register1,register3,register2);
/**
 * MULTIPLY AND ADD (Short Binary-Floating-Point)
 * <br>The contents of <b>storage</b> and <b>reigster3</b> are multiplied together and then
 * the contents of <b>register1</b> are added.  Results are stored in <b>register1</b>
 * <br>Format={@link rxoperands RX}F Length=6 OpCode=ED0E
 * @param Register1 Any floating-point register
 * @param Register3 Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] MAEB R1,R3,D2(X2,B2) </code>
 */
procedure void MAEB(storage);
/**
 * MULTIPLY AND ADD (Short Binary-Floating-Point)
 * <br>The contents of <b>register2</b> and <b>reigster3</b> are multiplied together and then
 * the contents of <b>register1</b> are added.  Results are stored in <b>register1</b>
 * <br>Format={@link rrfoperands RRF} Length=4 OpCode=B30E
 * @param Register1 Any floating-point register
 * @param Register3 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] MAEBR R1,R3,R2 </code>
 */
procedure void MAEBR(register1,register3,register2);
/**
 * MONITOR CALL
 * <br>A program interrupt is caused when the monitor bits in control register 8 match the bits in the <b>immediate-value</b>.
 * <br>Format={@link sioperands SI} Length=4 OpCode=AF
 * @param Immediate-value Binary number indicating one of 16 monitor classes.
 * @param Storage Computed value (contents of B1+D2) placed in location 156 of operating system.
 * @example <code>[label] MC D1(B1),I2 </code>
 */
procedure void MC(storage,immediate-value);
/**
 * MULTIPLY (Long Hexadecimal-Floating-Point)
 * <br>Contents of <b>storage</b> are multiplied by contents of <b>register</b> and results are placed in <b>register</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=6C
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] MD R1,D2(X2,B2) </code>
 */
procedure void MD(register,storage);
/**
 * MULTIPLY (Long Binary-Floating-Point)
 * <br>Contents of <b>storage</b> are multiplied by contents of <b>register</b> and results are placed in <b>register</b>.
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED1C
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] MDB R1,D2(X2,B2) </code>
 */
procedure void MDB(register,storage);
/**
 * MULTIPLY (Long Binary-Floating-Point)
 * <br>Contents of <b>register1</b> are multiplied by contents of <b>register2</b> and results are placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B31C
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] MDBR R1,R2 </code>
 */
procedure void MDBR(register1,register2);
/**
 * MULTIPLY (short to long HFP)
 * <br>Contents of <b>storage</b> are multiplied by contents of <b>register</b> and results are placed in <b>register</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=7C
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] MDE R1,D2(X2,B2) </code>
 */
procedure void MDE(register,storage);
/**
 * MULTIPLY (short to long BFP)
 * <br>Contents of <b>storage</b> are multiplied by contents of <b>register</b> and results are placed in <b>register</b>.
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED0C
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] MDEB R1,D2(X2,B2) </code>
 */
procedure void MDEB(register,storage);
/**
 * MULTIPLY (short to long BFP)
 * <br>Contents of <b>register1</b> are multiplied by contents of <b>register2</b> and results are placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B30C
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] MDEBR R1,R2 </code>
 */
procedure void MDEBR(register1,register2);
/**
 * MULTIPLY (short to long HFP)
 * <br>Contents of <b>register1</b> are multiplied by contents of <b>register2</b> and results are placed in <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=3C
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] MDER R1,R2 </code>
 */
procedure void MDER(register1,register2);
/**
 * MULTIPLY (Long Hexadecimal-Floating-Point)
 * <br>Contents of <b>register1</b> are multiplied by contents of <b>register2</b> and results are placed in <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=2C
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] MDR R1,R2 </code>
 */
procedure void MDR(register1,register2);
/**
 * MULTIPLY (short to long HFP)
 * <br>Contents of <b>storage</b> are multiplied by contents of <b>register</b> and results are placed in <b>register</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=7C
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] ME R1,D2(X2,B2) </code>
 */
procedure void ME(register,storage);
/**
 * MULTIPLY (Short Hexadecimal-Floating-Point)
 * <br>Contents of <b>storage</b> are multiplied by contents of <b>register</b> and results are placed in <b>register</b>.
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED37
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] MEE R1,D2(X2,B2) </code>
 */
procedure void MEE(register,storage);
/**
 * MULTIPLY (Short Binary-Floating-Point)
 * <br>Contents of <b>storage</b> are multiplied by contents of <b>register</b> and results are placed in <b>register</b>.
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED17
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] MEEB R1,D2(X2,B2) </code>
 */
procedure void MEEB(register,storage);
/**
 * MULTIPLY (Short Binary-Floating-Point)
 * <br>Contents of <b>register1</b> are multiplied by contents of <b>register2</b> and results are placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B317
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] MEEBR R1,R2 </code>
 */
procedure void MEEBR(register1,register2);
/**
 * MULTIPLY (Short Hexadecimal-Floating-Point)
 * <br>Contents of <b>register1</b> are multiplied by contents of <b>register2</b> and results are placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B337
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] MEER R1,R2 </code>
 */
procedure void MEER(register1,register2);
/**
 * MULTIPLY (short to long HFP)
 * <br>Contents of <b>register1</b> are multiplied by contents of <b>register2</b> and results are placed in <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=3C
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] MER R1,R2 </code>
 */
procedure void MER(register1,register2);
/**
 * MULTIPLY HALFWORD
 * <br>Contents of <b>storage</b> are multiplied by contents of <b>register</b> and results are placed in <b>register</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=4C
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement (2 bytes)
 * @example <code>[label] MH R1,D2(X2,B2) </code>
 */
procedure void MH(register,storage);
/**
 * MULTIPLY HALFWORD IMMEDIATE
 * <br><b>Immediate-value</b> is multiplied by contents of <b>register</b> and results are placed in <b>register</b>.
 * <br>Format={@link rioperands RI} Length=4 OpCode=A7C
 * @param Register Any general purpose register
 * @param Immediate-value Half-word included within the instruction
 * @example <code>[label] MHI R1,I2 </code>
 */
procedure void MHI(register,immediate-value);
/**
 * MULTIPLY DECIMAL
 * <br>The packed-decimal value at <b>storage1</b> is multiplied by the packed-decimal value at <b>storage2</b>.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=FC
 * @param Storage1 Storage label or <b>B</b>ase register and <b>D</b>isplacement with <b>L</b>ength
 * @param Storage2 Storage label or <b>B</b>ase register and <b>D</b>isplacement with <b>L</b>ength
 * @example <code>[label] MP D1(L1,B1),D2(L2,B2) </code>
 */
procedure void MP(storage1,storage2);
/**
 * MULTIPLY
 * <br>Contents of <b>register1</b> are multiplied by contents of <b>register2</b> and results are placed in <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=1C
 * @param Register1 Even general purpose register of a even-odd pair, multiplicand is in register1+1
 * @param Register2 Any general purpose register
 * @example <code>[label] MR R1,R2 </code>
 */
procedure void MR(register1,register2);
/**
 * MULTIPLY SINGLE
 * <br>The contents of <b>register</b> are multiplied by the 32-bit value at <b>storage</b>.
 * The right-most 32-bits of the result are stored in <b>register</b>
 * <br>Format={@link rxoperands RX} Length=4 OpCode=71
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] MS R1,D2(X2,B2) </code>
 */
procedure void MS(register,storage);
/**
 * MODIFY SUBCHANNEL
 * <br>The  information  contained in the subchannel-information block (SCHIB) is
 * placed in the program-modifiable fields of the subchannel.   As a  result,
 * the  program  influences,  for  that  subchannel,  certain  aspects of I/O
 * processing relative to the clear, halt, resume, and  start  functions  and
 * certain I/O support functions.
 * <br>Format={@link soperands S} Length=4 OpCode=B232
 * @param implied General Register 1 contains subsystem-identification word
 * @param Storage Logical address of the SCHIB (on a word boundary).
 * @example <code>[label] MSCH D2(B2) </code>
 */
procedure void MSCH(storage);
/**
 * MULTIPLY AND SUBTRACT (Long Binary-Floating-Point)
 * <br>The contents of <b>storage</b> and <b>reigster3</b> are multiplied together and then
 * the contents of <b>register1</b> are subtracted from the product.  Results are stored in <b>register1</b>
 * <br>Format={@link rxoperands RX}F Length=6 OpCode=ED1F
 * @param Register1 Any floating-point register
 * @param Register3 Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] MSDB R1,R3,D2(X2,B2) </code>
 */
procedure void MSDB(register1,register3,storage);
/**
 * MULTIPLY AND SUBTRACT (Long Binary-Floating-Point)
 * <br>The contents of <b>register2</b> and <b>reigster3</b> are multiplied together and then
 * the contents of <b>register1</b> are subtracted from the product.  Results are stored in <b>register1</b>
 * <br>Format={@link rrfoperands RRF} Length=4 OpCode=B31F
 * @param Register1 Any floating-point register
 * @param Register3 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] MSDBR R1,R3,R2 </code>
 */
procedure void MSDBR(register1,register3,register2);
/**
 * MULTIPLY AND SUBTRACT (Short Binary-Floating-Point)
 * <br>The contents of <b>storage</b> and <b>reigster3</b> are multiplied together and then
 * the contents of <b>register1</b> are subtracted from the product.  Results are stored in <b>register1</b>
 * <br>Format={@link rxoperands RX}F Length=6 OpCode=ED0F
 * @param Register1 Any floating-point register
 * @param Register3 Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] MSEB R1,R3,D2(X2,B2) </code>
 */
procedure void MSEB(register1,register3,storage);
/**
 * MULTIPLY AND SUBTRACT (Short Binary-Floating-Point)
 * <br>The contents of <b>register2</b> and <b>reigster3</b> are multiplied together and then
 * the contents of <b>register1</b> are added.  Results are stored in <b>register1</b>
 * <br>Format={@link rrfoperands RRF} Length=4 OpCode=B30F
 * @param Register1 Any floating-point register
 * @param Register3 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] MSEBR R1,R3,R2 </code>
 */
procedure void MSEBR(register1,register3,register2);
/**
 * MULTIPLY SINGLE
 * <br>The contents of <b>register1</b> are multiplied by the value in <b>register2</b>.  Results are placed in <b>register1</b>
 * Only 32 bits of the product are retained.
 * The right-most 32-bits of the result are stored in <b>register</b>
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B252
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] MSR R1,R2 </code>
 */
procedure void MSR(register1,register2);
/**
 * MODIFY STACKED STATE
 * <br>The  contents  of the pair of general registers designated by <b>register</b>
 * are placed in the modifiable area, byte positions  152-159,  of  the  last
 * state entry in the linkage stack.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B247
 * @param Register The even-numbered register of an even-odd pair of general registers
 * @example <code>[label] MSTA R1 </code>
 */
procedure void MSTA(register);
/**
 * MOVE (character)
 * <br>The contents of <b>storage2</b> are move to <b>storage1</b>.  The number of bytes moved is
 * controlled by the length of the first operand.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=D2
 * @example <code>[label] MVC D1(L,B1),D2(B2) </code>
 * @param Storage1 Storage label or <b>B</b>ase register and <b>D</b>isplacement with <b>L</b>ength
 * @param Storage2 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 */
procedure void MVC(storage);
/**
 * MOVE WITH DESTINATION KEY
 * <br><b>Storage1</b> is replaced by <b>storage2</b>.  The accesses to the
 * destination-operand location are performed by using the key specified in
 * general register 1, and the accesses to the source-operand location are
 * performed by using the PSW key.
 * <br>Format={@link sseoperands SSE} Length=6 OpCode=E50F
 * @param Storage1 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Storage2 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param implied Register 0 Bit2 24-31 contains the length of operands
 * @param implied Register 1 Bits 24-27 conatins the access key
 * @example <code>[label] MVCDK D1(B1),D2(B2) </code>
 */
procedure void MVCDK(storage1,storage2);
/**
 * MOVE INVERSE
 * <br>Bytes at <b>storage2</b>, working right-to-left, are moved to <b>storage1</b>and stored left-to-right.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=E8
 * @param Storage1 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Storage2 Storage label or <b>B</b>ase register and <b>D</b>isplacement of RIGHTMOST byte of operand2
 * @example <code>[label] MVCIN D1(L,B1),D2(B2) </code>
 */
procedure void MVCIN(storage1,storage2);
/**
 * MOVE WITH KEY
 * <br>The  first  operand is replaced by the second operand.  The fetch accesses
 * to the second-operand location are performed by using the key specified in
 * the third operand, and the store accesses to  the  first-operand  location
 * are performed by using the PSW key.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=D9
 * {@link rc34 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register3 Any general purpose register, bits 24-27 contain the access key
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register and <b>D</b>isplacement
 * @example <code>[label] MVCK D1(R1,B1),D2(B2),R3 </code>
 */
procedure void MVCK(storage);
/**
 * MOVE LONG
 * <br>Move bytes from address in <b>register2</b> to address in <b>register1</b>.  Length of source is in <b>register2</b>+1,
 * pad character is in bits 0-7 of <b>register2</b>+1.  Length of operand 1 is in <b>register1</b>+1
 * <br>Format={@link rroperands RR} Length=2 OpCode=0E
 * {@link rc35 Condition_Codes_Set}
 * @param Register1 Any even-numbered general purpose register
 * @param Register2 Any even-numbered general purpose register
 * @example <code>[label] MVCL R1,R2 </code>
 */
procedure void MVCL(register1,register2);
/**
 * MOVE LONG EXTENDED
 * <br>Move bytes from address in <b>register3</b> to address in <b>register1</b>.  Length of source is in <b>register3</b>+1.
 * Length of operand 1 is in <b>register1</b>+1.  Pad character is in bits 24-31 of <b>storage</b> operand.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=A8
 * {@link rc36 Condition_Codes_Set}
 * @param Register1 Any even-numbered general purpose register
 * @param Register3 Any even-numbered general purpose register
 * @param Storage bits 24-31 of this operand (the last byte of the instruction) contain the pad character.
 * @example <code>[label] MVCLE R1,R3,D2(B2) </code>
 */
procedure void MVCLE(register1,register3,storage);
/**
 * MOVE TO PRIMARY
 * <br>Move data from secondary address space to primary address space.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=DA
 * {@link rc34 Condition_Codes_Set}
 * @param Storage1 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Register1 Any general purpose register, contains the true length on the operands
 * @param Storage2 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Register3 Any general purpose register, contains the secondary-space access key in bits 24-27.
 * @example <code>[label] MVCP D1(R1,B1),D2(B2),R3 </code>
 */
procedure void MVCP(storage1,register1,storage2,register3);
/**
 * MOVE TO SECONDARY
 * <br>Move data from primary address space to secondary address space.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=DB
 * {@link rc34 Condition_Codes_Set}
 * @param Storage1 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Register1 Any general purpose register, contains the true length on the operands
 * @param Storage2 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Register3 Any general purpose register, contains the secondary-space access key in bits 24-27.
 * @example <code>[label] MVCS D1(R1,B1),D2(B2),R3 </code>
 */
procedure void MVCS(storage1,register1,storage2,register3);
/**
 * MOVE WITH SOURCE KEY
 * <br>The contents of <b>storage2</b> are placed at <b>storage2</b>.
 * <br>Format={@link sseoperands SSE} Length=6 OpCode=E50E
 * @param Storage1 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Storage2 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param implied General Register 0, bits 24-31, contains the length of the operands
 * @param implied General Register 1, bits 24-27, contains the access key for second operand storage location.
 * @example <code>[label] MVCSK D1(B1),D2(B2) </code>
 */
procedure void MVCSK(storage1,storage2);
/**
 * MOVE (immediate)
 * <br>The contents of <b>immediate-value</b>, bits 8-15 of the instruction, are stored at storage.
 * <br>Format={@link sioperands SI} Length=4 OpCode=92
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Immediate-value Single byte stored within the instruction.
 * @example <code>[label] MVI D1(B1),I2 </code>
 */
procedure void MVI(storage,immediate-value);
/**
 * MOVE NUMERICS
 * <br>The right-most four bits of each byte at <b>storage2</b> is placed in the right-most four bits of each byte at <b>storage2</b>.
 * Leftmost-bits at <b>storage1</b> are not changed.  Length of <b>storage1</b> controls the number of bytes moved.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=D1
 * @param Storage1 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Storage2 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] MVN D1(L,B1),D2(B2) </code>
 */
procedure void MVN(storage1,storage2);
/**
 * MOVE WITH OFFSET
 * <br>Use to add a sign to a packed, unsigned value.  The bits at <b>storage2</b> are shifted left
 * by four positions and then placed at <b>storage1</b>.  The right-most four bits of <b>storage1</b>
 * are left unchanged.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=F1
 * @param Storage1 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Storage2 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] MVO D1(L1,B1),D2(L2,B2) </code>
 */
procedure void MVO(storage1,storage2);
/**
 * MOVE PAGE (facility 1)
 * <br>The 4K bytes at the address in <b>register2</b> is moved to the address in <b>reigster1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B254
 * {@link rc37 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @param implied General purpose register 0, bits 16-23 must contain b'00000001', other bits ignored.
 * @example <code>[label] MVPG R1,R2 </code>
 */
procedure void MVPG(register1,register2);
/**
 * MOVE PAGE (facility 2)
 * <br>The 4K bytes at the address in <b>register2</b> is moved to the address in <b>reigster1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B254
 * {@link rc37 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @param implied General purpose register 0, Bits 24-27 of general register 0 are used as the specified access key. Bit 20 of general register 0, when one, specifies that
 * the specified access key is to be used for accessing the first operand, and bit 21 specifies the same for the second operand.
 * A specification exception is recognized if bits 20 and 21 are both ones. Bit 22 of general register 0 is a
 * destination-reference-intention bit, and bit 23 is a condition-code-option bit. Bits 16-19 of general register 0 must be zeros;
 * otherwise, a specification exception is recognized. Bits 0-15 and 28-31 of general register 0 are ignored.
 * @example <code>[label] MVPG R1,R2 </code>
 */
procedure void MVPG(register1,register2,gpr0);
/**
 * MOVE STRING
 * <br>Contents at address in <b>reigster2</b> are moved to address in <b>reigster1</b>.
 * Length of moved data is controlled by end of data character (stored in genral reigster 0, or CPU-
 * determined number of bytes.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B255
 * {@link rc38 Condition_Codes_Set}
 * @example <code>[label] MVST R1,R2 </code>
 */
procedure void MVST(register1,register2);
/**
 * MOVE ZONES
 * <br>The left-most bits of each byte of <b>storage2</b> (zone of zoned-numeric formated data)
 * is move to left-most bits of each byte of <b>storage1</b>.
 * Number of moved bytes is controlled by the length of <b>storage1</b>.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=D3
 * @param Storage1 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Storage2 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] MVZ D1(L,B1),D2(B2) </code>
 */
procedure void MVZ(storage);
/**
 * MULTIPLY (Extended Binary-Floating-Point)
 * <br>Multiply contents of <b>register1</b> by <b>register2</b>.  Results in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B34C
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any valid floating-point register pair
 * @example <code>[label] MXBR R1,R2 </code>
 */
procedure void MXBR(register1,register2);
/**
 * MULTIPLY (long to extended HFP)
 * <br>Multiply contents of <b>register</b> by <b>storage</b>.  Results in <b>register</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=67
 * @param Register Any valid floating-point register pair
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register, and <b>D</b>isplacement
 * @example <code>[label] MXD R1,D2(X2,B2) </code>
 */
procedure void MXD(register,storage);
/**
 * MULTIPLY (long to extended BFP)
 * <br>Multiply contents of <b>register</b> by <b>storage</b>.  Results in <b>register</b>.
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED07
 * @param Register Any valid floating-point register pair
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register, and <b>D</b>isplacement
 * @example <code>[label] MXDB R1,D2(X2,B2) </code>
 */
procedure void MXDB(register,storage);
/**
 * MULTIPLY (long to extended BFP)
 * <br>Multiply contents of <b>register1</b> by <b>register2</b>.  Results in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B307
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any floating-point register
 * @example <code>[label] MXDBR R1,R2 </code>
 */
procedure void MXDBR(register1,register2);
/**
 * MULTIPLY (long to extended HFP)
 * <br>Multiply contents of <b>register1</b> by <b>register2</b>.  Results in <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=27
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any floating-point register
 * @example <code>[label] MXDR R1,R2 </code>
 */
procedure void MXDR(register1,register2);
/**
 * MULTIPLY (Extended Hexadecimal-Floating-Point)
 * <br>Multiply contents of <b>register1</b> by <b>register2</b>.  Results in <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=26
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any valid floating-point register pair
 * @example <code>[label] MXR R1,R2 </code>
 */
procedure void MXR(register1,register2);
/**
 * AND
 * <br>Compare bits of <b>register</b> and fullword at <b>storage</b>, set
 * bit of <b>register</b> to 1 when both bits in compare are 1, else set to 0.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=54
 * {@link rc3 Condition_Codes_Set}
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register, and <b>D</b>isplacement
 * @example <code>[label] N R1,D2(X2,B2) </code>
 */
procedure void N(register,storage);
/**
 * AND (character)
 * <br>Compare bits starting at <b>storage1</b> and bits at <b>storage2</b>, for <b>L</b>ength bytes.
 * Set bit of <b>storage1</b> to 1 when both bits in compare are 1, else set to 0.
 * <br>Format={@link ssoperandsc SS} Length=6 OpCode=D4
 * {@link rc3 Condition_Codes_Set}
 * @param Storage1 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Storage2 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] NC D1(L,B1),D2(B2) </code>
 */
procedure void NC(storage,storage);
/**
 * AND (immediate)
 * <br>Compare the byte at <b>storage</b> to the immediate value.  Set each bit
 * of <b>storage</b> to 1 when both bits of the compare are 1, else set to 0.
 * <br>Format={@link sioperands SI} Length=4 OpCode=94
 * {@link rc3 Condition_Codes_Set}
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Immediate-value Single byte stored within the instruction.
 * @example <code>[label] NI D1(B1),I2 </code>
 */
procedure void NI(storage,immediate-value);
/**
 * AND
 * <br>Compare the bits of <b>register1</b> and <b>register2</b>.  Set each bit of <b>register1</b>
 * to 1 when both bits of the compare are 1, else set to 0.
 * <br>Format={@link rroperands RR} Length=2 OpCode=14
 * {@link rc3 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] NR R1,R2 </code>
 */
procedure void NR(register1,register2);
/**
 * OR
 * <br>Compare the bits of <b>register</b> to the fullword at <b>storage</b>.
 * Set the bit of <b>register</b> to 1 when one or both bits in the compare
 * are 1, else set the bit of <b>register</b> to 0.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=56
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register, and <b>D</b>isplacement
 * @example <code>[label] O R1,D2(X2,B2) </code>
 */
procedure void O(register,storage);
/**
 * OR (character)
 * <br>Compare the bits at <b>storage1</b> to the bits at <b>storage2</b>.
 * Set the bit of <b>storage1</b> to 1 when one or both bits in the compare
 * are 1, else set the bit of <b>storage1</b> to 0.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=D6
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] OC D1(L,B1),D2(B2) </code>
 */
procedure void OC(storage1,storage2);
/**
 * OR (immediate)
 * <br>Compare the bits of one byte at <b>storage</b> to the <b>immediate-value</b> within the instruction.
 * Set the bit of <b>storage</b> to 1 when one or both bits in the compare
 * are 1, else set the bit of <b>storage</b> to 0.
 * <br>Format={@link sioperands SI} Length=4 OpCode=96
 * {@link rc3 Condition_Codes_Set}
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Immediate-value One byte indicates bits of storage to "test"
 * @example <code>[label] OI D1(B1),I2 </code>
 */
procedure void OI(storage,immediate-valuie);
/**
 * OR
 * <br>Compare the bits of <b>register1</b> to the bits of <b>register2</b>.
 * Set the bit of <b>register1</b> to 1 when one or both bits in the compare
 * are 1, else set the bit of <b>register1</b> to 0.
 * <br>Format={@link rroperands RR} Length=2 OpCode=16
 * {@link rc3 Condition_Codes_Set}
 * @param Register1 Any general purpose register
 * @param Register2 Any general purpose register
 * @example <code>[label] OR R1,R2 </code>
 */
procedure void OR(register1,register2);
/**
 * PACK
 * <br>The zoned decimal value at <b>storage2</b> is converted to packed decimal format and
 * stored at <b>storage1</b>.  The zone bits of the right-most byte of <b>storage2</b> is placed
 * in the right-most bits of <b>storage1</b> to serve as the sign.  The numeric bits of <b>storage2</b>
 * are moved to <b>storage1</b>.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=F2
 * @param Storage1 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Storage2 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] PACK D1(L1,B1),D2(L2,B2) </code>
 */
procedure void PACK(storage1,storage2);
/**
 * PURGE ALB
 * <br>The  ART-lookaside  buffer  (ALB)  of  this CPU is cleared of entries.  No
 * change is made to the contents of addressable storage or registers.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B248
 */
procedure void PALB();
/**
 * PROGRAM CALL
 * <br>See Principles of Operation
 * <br>Format={@link soperands S} Length=4 OpCode=B218
 * @example <code>[label] PC D2(B2) </code>
 */
procedure void PC(storage);
/**
 * PROGRAM CALL FAST
 * <br>See Principles of Operation
 * <br>Format={@link soperands S} Length=4 OpCode=B218
 * @example <code>[label] PCF D2(B2) </code>
 */
procedure void PCF(storage);
/**
 * PERFORM LOCKED OPERATION
 * <br>See Principles of Operation
 * <br>Format={@link ssoperands SS} Length=6 OpCode=EE
 * @param implied General Register 1, contains address of the program lock token (PLT)
 * @param implied General Register 0, contains test bit and function code
 * @param Register1 Depending on function code, contains one comparison value, may
 * need to be even-numbered register of even-off pair
 * @param Storage1 Depends on function code
 * @param Register3 Depends on function code
 * @param Storage4 Depends on functions code
 * @example <code>[label] PLO R1,D2(B2),R3,D4(B4) </code>
 */
procedure void PLO(register1,storage2,register3,storage4);
/**
 * PROGRAM RETURN
 * <br>See principles of Operation
 * <br>Format=E Length=2 OpCode=0101
 * @example <code>[label] PR </code>
 */
procedure void PR();
/**
 * PROGRAM TRANSFER
 * <br>The  contents  of  general  register R1 are used as the new values for the
 * PSW-key mask, the PASN, and the SASN.  The contents of general register R2
 * are used as the new values for the problem-state bit, addressing-mode bit,
 * and instruction address in the current PSW.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B228
 * @param Register1 Any General Purpose Register
 * @param Register2 Any General Purpose Register
 * @example <code>[label] PT R1,R2 </code>
 */
procedure void PT(register1,register2);
/**
 * PURGE TLB
 * <br>The  translation-lookaside buffer (TLB) of this CPU is cleared of entries.
 * No change is made to the contents of addressable storage or registers.
 * <br>Format={@link soperands S} Length=4 OpCode=B20D
 * @example <code>[label] PTLB        </code>
 */
procedure void PTLB(storage);
/**
 * RESET CHANNEL PATH
 * <br>Signal the Channel-apth-reset facility to reset the path indicated by the
 * Channel-path identifier (CHPID) in Genreal Register 1
 * <br>Format={@link soperands S} Length=4 OpCode=B23B
 * {@link rc39 Condition_Codes_Set}
 * @param implied General Purpose Register 1, contains CHPID
 * @example <code>[label] RCHP        </code>
 */
procedure void RCHP();
/**
 * RESUME PROGRAM
 * <br>Certain fields in the current PSW and the contents of access register
 * and general register B2 are replaced from fields in the
 * second operand.
 * The offsets of the fields in the second operand are specified in a parameter
 * list that immediately follows the instruction in the instruction address space.
 * See Principles of Operation for format of parameter list.
 * <br>Format={@link soperands S} Length=4 OpCode=B277
 * @example <code>[label] RP D2(B2) </code>
 */
procedure void RP(storage);
/**
 * RESET REFERENCE BIT EXTENDED
 * <br>The  reference  bit  in  the  storage  key  for  the 4K-byte block that is
 * addressed by the contents of <b>register2</b> is  set  to  zero.    The
 * contents of <b>register1</b> are ignored.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B22A
 * {@link rc40 Condition_Codes_Set}
 * @example <code>[label] RRBE R1,R2 </code>
 */
procedure void RRBE(register1,register2);
/**
 * RESUME SUBCHANNEL
 * <br>The channel subsystem is signaled to perform the resume function on
 * the subchannel designated by the subsystem-identification word stored in General Register 1
 * <br>Format={@link soperands S} Length=4 OpCode=B238
 * {@link rc41 Condition_Codes_Set}
 * @example <code>[label] RSCH        </code>
 */
procedure void RSCH(storage);
/**
 * SUBTRACT
 * <br>The 32-bit signed binary integer value at <b>storage</b> is subtracted from the
 * 32-bit signed binary integer in <b>register1</b>.  Difference is placed in <b>register</b>
 * <br>Format={@link rxoperands RX} Length=4 OpCode=5B
 * {@link rc42 Condition_Codes_Set}
 * @param Register Any General Purpose Register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register, and <b>D</b>isplacement
 * @example <code>[label] S R1,D2(X2,B2) </code>
 */
procedure void S(register,storage);
/**
 * SET ADDRESS SPACE CONTROL
 * <br>Modifies bits 16 and 17 of the PSW (address space control) based on
 * value of bits 20-23 of the instruction.
 * Serialization and checkpoint-synchronization are performed before and after the operation.
 * <br>Format={@link soperands S} Length=4 OpCode=B219
 * @example <code>[label] SAC D2(B2) </code>
 */
procedure void SAC(storage);
/**
 * SET ADDRESS SPACE CONTROL FAST
 * <br>Modifies bits 16 and 17 of the PSW (address space control) based on
 * value of bits 20-23 of the instruction.
 * <br>Format={@link soperands S} Length=4 OpCode=B279
 * @example <code>[label] SACF D2(B2) </code>
 */
procedure void SACF(storage);
/**
 * SET ADDRESS LIMIT
 * <br>The address-limit-checking facility is signaled to use the address contained
 * in General Register 1 as the address-limit value.
 * <br>Format={@link soperands S} Length=4 OpCode=B237
 * @param implied General Register 1, contains 31-bit address of a 64K boundary byte
 * @example <code>[label] SAL         </code>
 */
procedure void SAL(storage);
/**
 * SET ACCESS
 * <br>The contents of <b>register2</b> are placed in access register <b>register1</b>
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B24E
 * @param Register1 Access register
 * @param Register2 Any General Purpose register
 * @example <code>[label] SAR R1,R2 </code>
 */
procedure void SAR(storage);
/**
 * SET CHANNEL MONITOR
 * <br>The monitoring modes of the channel subsystem are made either active or inactive, depending on the setting of the
 * measurement-mode-control bits in General Register 1.
 * <br>Format={@link soperands S} Length=4 OpCode=B23C
 * @param implied General Purpose Register 1
 * @param implied General Purpose Register 2
 * @example <code>[label] SCHM        </code>
 */
procedure void SCHM(storage);
/**
 * SET CLOCK
 * <br>The current value of the TOD clock is replaced by the contents of the double word
 * at <b>storage</b>.
 * <br>Format={@link soperands S} Length=4 OpCode=B204
 * {@link rc43 Condition_Codes_Set}
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] SCK D2(B2) </code>
 */
procedure void SCK(storage);
/**
 * SET CLOCK COMPARATOR
 * <br>The current value of the clock comparator is replaced by the doubleword
 * at <b>storage</b>.
 * <br>Format={@link soperands S} Length=4 OpCode=B206
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] SCKC D2(B2) </code>
 */
procedure void SCKC(storage);
/**
 * SUBTRACT NORMALIZED (Long Hexadecimal-Floating-Point)
 * <br>The value in <b>storage</b> is subtracted from the value in <b>register</b>.
 * The results are placed in <b>register</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=6B
 * {@link rc8 Condition_Codes_Set}
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register, and <b>D</b>isplacement
 * @example <code>[label] SD R1,D2(X2,B2) </code>
 */
procedure void SD(register,storage);
/**
 * SUBTRACT (Long Binary-Floating-Point)
 * <br>The value in <b>storage</b> is subtracted from the value in <b>register</b>.
 * The results are placed in <b>register</b>.
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED1B
 * {@link rc8 Condition_Codes_Set}
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register, and <b>D</b>isplacement
 * @example <code>[label] SDB R1,D2(X2,B2) </code>
 */
procedure void SDB(register,storage);
/**
 * SUBTRACT (Long Binary-Floating-Point)
 * <br>The value in <b>register2</b> is subtracted from the value in <b>register1</b>.
 * The results are placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B31B
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] SDBR R1,R2 </code>
 */
procedure void SDBR(register1,register2);
/**
 * SUBTRACT NORMALIZED (Long Hexadecimal-Floating-Point)
 * <br>The value in <b>register2</b> is subtracted from the value in <b>register1</b>.
 * The results are placed in <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=2B
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] SDR R1,R2 </code>
 */
procedure void SDR(register1,register2);
/**
 * SUBTRACT NORMALIZED (Short Hexadecimal-Floating-Point)
 * <br>The value in <b>storage</b> is subtracted from the value in <b>register</b>.
 * The results are placed in <b>register</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=7B
 * {@link rc8 Condition_Codes_Set}
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register, and <b>D</b>isplacement
 * @example <code>[label] SE R1,D2(X2,B2) </code>
 */
procedure void SE(register,storage);
/**
 * SUBTRACT (Short Binary-Floating-Point)
 * <br>The value in <b>storage</b> is subtracted from the value in <b>register</b>.
 * The results are placed in <b>register</b>.
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED0B
 * {@link rc8 Condition_Codes_Set}
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register, and <b>D</b>isplacement
 * @example <code>[label] SEB R1,D2(X2,B2) </code>
 */
procedure void SEB(register,storage);
/**
 * SUBTRACT (Short Binary-Floating-Point)
 * <br>The value in <b>register2</b> is subtracted from the value in <b>register1</b>.
 * The results are placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B30B
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] SEBR R1,R2 </code>
 */
procedure void SEBR(register1,register2);
/**
 * SUBTRACT NORMALIZED (Short Hexadecimal-Floating-Point)
 * <br>The value in <b>register2</b> is subtracted from the value in <b>register1</b>.
 * The results are placed in <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=3B
 * {@link rc8 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] SER R1,R2 </code>
 */
procedure void SER(register1,register2);
/**
 * SET FPC
 * <br>The contents of the general register designated by <b>register1</b> are placed in
 * the FPC (floating-point-control) register.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B384
 * @param Register1 Any General Purpose Register
 * @example <code>[label] SFPC R1 </code>
 */
procedure void SFPC(register);
/**
 * SUBTRACT HALFWORD
 * <br>The value in <b>storage</b> is subtracted from the value in <b>register</b>.
 * The results are placed in <b>register</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=4B
 * {@link rc8 Condition_Codes_Set}
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register, and <b>D</b>isplacement
 * @example <code>[label] SH R1,D2(X2,B2) </code>
 */
procedure void SH(register,storage);
/**
 * SIGNAL PROCESSOR
 * <br>An  eight-bit  order  code  and,  if  called  for,  a 32-bit parameter are
 * transmitted to the CPU designated by the  CPU  address  contained  in  the
 * third  operand.   The result is indicated by the condition code and may be
 * detailed by status assembled in the first-operand location.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=AE
 * {@link rc44 Condition_Codes_Set}
 * @param Register1 Optional Parameter and status
 * @param Register3 Bits 16-31 hold CPU address
 * @param Storage Not an address, contains the order code
 * @example <code>[label] SIGP R1,R3,D2(B2) </code>
 */
procedure void SIGP(register1,register3,storage);
/**
 * SUBTRACT LOGICAL
 * <br>The value in <b>storage</b> is subtracted from the value in <b>register</b>.
 * The results are stored in <b>register</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=5F
 * {@link rc12 Condition_Codes_Set}
 * @example <code>[label] SL R1,D2(X2,B2) </code>
 */
procedure void SL(register,storage);
/**
 * SHIFT LEFT SINGLE
 * <br>The  31-bit numeric part of the signed first operand is shifted left the
 * number of bits specified by the second-operand address, and the result is
 * placed at the first-operand location.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=8B
 * {@link rc42 Condition_Codes_Set}
 * @param Register Any general purpose register
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] SLA R1,D2(B2) </code>
 */
procedure void SLA(storage);
/**
 * SHIFT LEFT DOUBLE
 * <br>The  63-bit  numeric  part of the signed first operand is shifted left the
 * number of bits specified by the second-operand address, and the result  is
 * placed at the first-operand location.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=8F
 * {@link rc42 Condition_Codes_Set}
 * @param Register Even-numbered general register of even-off pair
 * @param Storage Not an address, rightmost six bits indicate the number of bits to
 * shift left.
 * @example <code>[label] SLDA R1,D2(B2) </code>
 */
procedure void SLDA(register,storage);
/**
 * SHIFT LEFT DOUBLE LOGICAL
 * <br>The  64-bit value in <b>register1</b> plus <b>register1</b>+1
 * is shifted left the number of bits specified by
 * <b>storage</b>, and the result is placed in <b>register</b>
 * <br>Format={@link rsoperands RS} Length=4 OpCode=8D
 * {@link rc42 Condition_Codes_Set}
 * @param Register Even-numbered general register of even-off pair
 * @param Storage Not an address, rightmost six bits indicate the number of bits to
 * shift left.
 * @example <code>[label] SLDL R1,D2(B2) </code>
 */
procedure void SLDL(register,storage);
/**
 * SHIFT LEFT SINGLE LOGICAL
 * <br>The  32-bit contents of <b>register1</b> is shifted left the number of bits specified by
 * <b>storage</b>, and the result is placed in <b>register</b>.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=89
 * {@link rc42 Condition_Codes_Set}
 * @param Register Any general register
 * @param Storage Not an address, rightmost six bits indicate the number of bits to
 * shift left.
 * @example <code>[label] SLL R1,D2(B2) </code>
 */
procedure void SLL(register,storage);
/**
 * SUBTRACT LOGICAL
 * <br>The 32-bit unsigned binary integer in <b>register2</b> is subtracted
 * from the 32-bit unsigned binary integer in <b>register1</b>.  The result
 * is placed in <b>register1</b>
 * <br>Format={@link rroperands RR} Length=2 OpCode=1F
 * {@link rc12 Condition_Codes_Set}
 * @param Register1 Any general register
 * @param Register2 Any general register
 * @example <code>[label] SLR R1,R2 </code>
 */
procedure void SLR(register1,register2);
/**
 * SUBTRACT DECIMAL
 * <br>The packed-decimal value at <b>storage2</b> is subtracted from
 * <b>storage1</b>.  Results are placed in <b>storage1</b>.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=FB
 * {@link rc1 Condition_Codes_Set}
 * @param Storage1 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Storage2 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] SP D1(L1,B1),D2(L2,B2) </code>
 */
procedure void SP(storage1,storage2);
/**
 * SET PSW KEY FROM ADDRESS
 * <br>The PSW key, bits 8-11 of the PSW, is replaced by bits 24-27 of the instruction.
 * <br>Format={@link soperands S} Length=4 OpCode=B20A
 * @param Storage Not an address.
 * @example <code>[label] SPKA D2(B2) </code>
 */
procedure void SPKA(storage);
/**
 * SET PROGRAM MASK
 * <br>The contents of <b>register</b> are used to set the condition code (bits 2 and 3)
 * and the program mask (bits 4-7) in the current PSW
 * <br>Format={@link rroperands RR} Length=2 OpCode=04
 * @param Register Any general register
 * @example <code>[label] SPM R1 </code>
 */
procedure void SPM(register);
/**
 * SET CPU TIMER
 * <br>The doubleword at <b>storage</b> is used to set the CPU timer.
 * <br>Format={@link soperands S} Length=4 OpCode=B208
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] SPT D2(B2) </code>
 */
procedure void SPT(storage);
/**
 * SET PREFIX
 * <br>The contents of the prefix register are replaced by the contents of bit
 * positions 1-19 of the word at the location designated by <b>storage</b>.
 * The ART-lookaside buffer (ALB) and
 * translation-lookaside buffer (TLB) of this CPU are cleared of entries.
 * <br>Format={@link soperands S} Length=4 OpCode=B210
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] SPX D2(B2) </code>
 */
procedure void SPX(storage);
/**
 * SQUARE ROOT (Long Hexadecimal-Floating-Point)
 * <br>The square root of the value in <b>register2</b> is placed in <b>register1</b>.
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED35
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] SQD R1,D2(X2,B2) </code>
 */
procedure void SQD(register1,register2);
/**
 * SQUARE ROOT (Long Binary-Floating-Point)
 * <br>The square root of the value in <b>storage</b> is placed in <b>register</b>.
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED15
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register, and <b>D</b>isplacement
 * @example <code>[label] SQDB R1,D2(X2,B2) </code>
 */
procedure void SQDB(register,storage);
/**
 * SQUARE ROOT (Long Binary-Floating-Point)
 * <br>The square root of the value in <b>register2</b> is placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B315
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] SQDBR R1,R2 </code>
 */
procedure void SQDBR(register1,register2);
/**
 * SQUARE ROOT (Long Hexadecimal-Floating-Point)
 * <br>The square root of the value in <b>register2</b> is placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B244
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] SQDR R1,R2 </code>
 */
procedure void SQDR(register1,register2);
/**
 * SQUARE ROOT (Short Hexadecimal-Floating-Point)
 * <br>The square root of the value in <b>register2</b> is placed in <b>register1</b>.
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED34
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] SQE R1,D2(X2,B2) </code>
 */
procedure void SQE(register,storage);
/**
 * SQUARE ROOT (Short Binary-Floating-Point)
 * <br>The square root of the value in <b>register2</b> is placed in <b>register1</b>.
 * <br>Format={@link rxoperands RXE} Length=6 OpCode=ED14
 * @param Register1 Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register, and <b>D</b>isplacement
 * @example <code>[label] SQEB R1,D2(X2,B2) </code>
 */
procedure void SQEB(storage);
/**
 * SQUARE ROOT (Short Binary-Floating-Point)
 * <br>The square root of the value in <b>register2</b> is placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B314
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] SQEBR R1,R2 </code>
 */
procedure void SQEBR(register1,register2);
/**
 * SQUARE ROOT (Short Hexadecimal-Floating-Point)
 * <br>The square root of the value in <b>register2</b> is placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B245
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] SQER R1,R2 </code>
 */
procedure void SQER(register1,register2);
/**
 * SQUARE ROOT (Extended Binary-Floating-Point)
 * <br>The square root of the value in <b>register2</b> is placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B316
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any valid floating-point register pair
 * @example <code>[label] SQXBR R1,R2 </code>
 */
procedure void SQXBR(register1,register2);
/**
 * SQUARE ROOT (Extended Hexadecimal-Floating-Point)
 * <br>The square root of the value in <b>register2</b> is placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B336
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any valid floating-point register pair
 * @example <code>[label] SQXR R1,R2 </code>
 */
procedure void SQXR(register1,register2);
/**
 * SUBTRACT
 * <br>Subtract the 32-bit signed binary integer in <b>register2</b> from the
 * value in <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=1B
 * {@link rc1 Condition_Codes_Set}
 * @param Register1 Any general register
 * @param Register2 Any general register
 * @example <code>[label] SR R1,R2 </code>
 */
procedure void SR(register1,register2);
/**
 * SHIFT RIGHT SINGLE
 * <br>The 31-bit numeric part of the contents of <b>register</b> are shifted
 * to the right the number of time indicated by the last (rightmost) six bits
 * of <b>storage</b>.  The sign bit is duplicated to supply new leading bits.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=8A
 * {@link rc8 Condition_Codes_Set}
 * @param Register Any general register
 * @param Storage Not an Address, rightmost six bits indicate number of bits to shift.
 * @example <code>[label] SRA R1,D2(B2) </code>
 */
procedure void SRA(register,storage);
/**
 * SHIFT RIGHT DOUBLE
 * <br>The 63-bit numeric part of the contents of <b>register</b> and <b>register+1</b> are shifted
 * to the right the number of time indicated by the last (rightmost) six bits
 * of <b>storage</b>.  The sign bit is duplicated to supply new leading bits.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=8E
 * {@link rc8 Condition_Codes_Set}
 * @param Register Any even-numbered general register of an even-odd pair
 * @param Storage Not an Address, rightmost six bits indicate number of bits to shift.
 * @example <code>[label] SRDA R1,D2(B2) </code>
 */
procedure void SRDA(register,storage);
/**
 * SHIFT RIGHT DOUBLE LOGICAL
 * <br>The 64-bits of <b>register</b> and <b>register+1</b> are shifted
 * to the right the number of time indicated by the last (rightmost) six bits
 * of <b>storage</b>.  Zero bits are entered to supply new leading bits.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=8C
 * {@link rc8 Condition_Codes_Set}
 * @param Register Any even-numbered general register of an even-odd pair
 * @param Storage Not an Address, rightmost six bits indicate number of bits to shift.
 * @example <code>[label] SRDL R1,D2(B2) </code>
 */
procedure void SRDL(register,storage);
/**
 * SHIFT RIGHT SINGLE LOGICAL
 * <br>The 32-bits of <b>register</b> are shifted
 * to the right the number of times indicated by the last (rightmost) six bits
 * of <b>storage</b>.  Zero bits are entered to supply new leading bits.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=88
 * {@link rc8 Condition_Codes_Set}
 * @param Register Any general register
 * @param Storage Not an Address, rightmost six bits indicate number of bits to shift.
 * @example <code>[label] SRL R1,D2(B2) </code>
 */
procedure void SRL(register,storage);
/**
 * SET ROUNDING MODE
 * <br>The rounding-mode bits in the FPC register are set with bits 30 and 31 of the instruction.
 * <br>Format={@link soperands S} Length=4 OpCode=B299
 * @param Storage Not an Address, rightmost two bits hold rounding-mode.
 * @example <code>[label] SRNM D2(B2) </code>
 */
procedure void SRNM(storage);
/**
 * SHIFT AND ROUND DECIMAL
 * <br>The packed-decimal contents of <b>storage1</b> are shifted the number of
 * decimal digits and the direction controlled by bits 26-31 of the instruction.
 * Bits 26-31 contain a signed binary integer.  Positive numbers (1-31) shift left,
 * negative numbers (-1 to -32) shift to the right.  Rounding is controlled by the
 * <b>immediate-value</b> portion of the instruction.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=F0
 * {@link rc1 Condition_Codes_Set}
 * @param Storage1 Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Storage2 Not an address.  Last six bits control amount and dirction of shift
 * @param Immediate-value Rounding amount, added to last digit shifted out
 * @example <code>[label] SRP D1(L1,B1),D2(B2),I3 </code>
 */
procedure void SRP(storage1,storage2,immediate-value);
/**
 * SEARCH STRING
 * <br>Storage starting from the address in <b>register2</b> is searched for the value
 * in bit positions 24-31 of General Register 0.  The search continues until the search
 * character is found, the address in <b>register1</b> is reached, or a CPU-determined
 * number of characters has been searched.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B25E
 * {@link rc45 Condition_Codes_Set}
 * @param implied General Purpose Register 0, bits 24-31 hold search character, other bits must be zero.
 * @param Register Any general register, contains address of first byte after operand2. (R2-R1 = length of operand2).
 * When character found contains address of character.
 * @param Register Any general register, contains address of storage to be searched and
 * @example <code>[label] SRST R1,R2 </code>
 */
procedure void SRST(register1,register2);
/**
 * SET SECONDARY ASN
 * <br>The  ASN  specified in bit positions 16-31 of general register R1 replaces
 * the secondary ASN in control register 3, and the segment-table designation
 * corresponding to that ASN replaces the SSTD in control register 7.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B225
 * @param Register Any general register
 * @param implied Control Register 3
 * @param implied Control Register 7
 * @example <code>[label] SSAR R1 </code>
 */
procedure void SSAR(register);
/**
 * START SUBCHANNEL
 * <br>The channel subsystem is signaled to asynchronously perform the start function
 * for the associated device.  The address of the ORB is designated by <b>storage/b>.
 * <br>Format={@link soperands S} Length=4 OpCode=B233
 * {@link rc23 Condition_Codes_Set}
 * @param implied General Purpose Register 1
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] SSCH D2(B2) </code>
 */
procedure void SSCH(storage);
/**
 * SET STORAGE KEY EXTENDED
 * <br>The storage key for the 4K-byte block that is addressed by the contents of
 * <b>register2</b> is replaced by bits from <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B22B
 * @param Register1 Any general register, bits 24-30 contain new storage key.
 * @param Register2 Any general register
 * @example <code>[label] SSKE R1,R2 </code>
 */
procedure void SSKE(register1,register2);
/**
 * SET SYSTEM MASK
 * <br>Bits 0-7 of the current PSW are replaced by the byte at <b>storage</b>.
 * <br>Format={@link soperands S} Length=4 OpCode=80
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] SSM D2(B2) </code>
 */
procedure void SSM(storage);
/**
 * STORE
 * <br>The value in <b>register</b> is placed in memory at <b>storage</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=50
 * @param Register Any general register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register, and <b>D</b>isplacement
 * @example <code>[label] ST R1,D2(X2,B2) </code>
 */
procedure void ST(register,storage);
/**
 * STORE ACCESS MULTIPLE
 * <br>Access registers, starting with <b>register1</b> through <b>register3</b>,
 * are stored in memory beginning at <b>storage</b>.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=9B
 * @param Register1 Any access register
 * @param Register3 Any access register
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] STAM R1,R3,D2(B2) </code>
 */
procedure void STAM(register1,register3,storage);
/**
 * STORE CPU ADDRESS
 * <br>The  16-bit  unsigned  binary integer by which this CPU is identified in a
 * multiprocessing  configuration  is  stored  at   the   halfword   location
 * designated by <b>storage</b>.
 * <br>Format={@link soperands S} Length=4 OpCode=B212
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement.  Must be a halfword boundary.
 * @example <code>[label] STAP D2(B2) </code>
 */
procedure void STAP(storage);
/**
 * STORE CHARACTER
 * <br>Bits 24-31 of <b>register</b> are placed in the byte at <b>storage</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=42
 * @param Register Any general register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register, and <b>D</b>isplacement
 * @example <code>[label] STC R1,D2(X2,B2) </code>
 */
procedure void STC(register,storage);
/**
 * STORE CLOCK
 * <br>The  current  value  of  bits  0-63  of  the  TOD  clock  is stored in the
 * eight-byte field designated by <b>storage</b>,  provided  the
 * clock is in the set, stopped, or not-set state.
 * <br>Format={@link soperands S} Length=4 OpCode=B205
 * {@link rc46 Condition_Codes_Set}
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] STCK D2(B2) </code>
 */
procedure void STCK(storage);
/**
 * STORE CLOCK COMPARATOR
 * <br>The  current  value  of  the  clock comparator is stored at the doubleword
 * location designated by <b>storage</b>.
 * <br>Format={@link soperands S} Length=4 OpCode=B207
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement of a doubleword
 * @example <code>[label] STCKC D2(B2) </code>
 */
procedure void STCKC(storage);
/**
 * STORE CHARACTERS UNDER MASK
 * <br>Bytes from <b>register</b> are placed in contiguous locations of <b>storage</b>.
 * <b>Mask</b> controls which bytes of <b>register</b> are stored.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=BE
 * @param Register Any general register
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Mask Four-bit mask indicating which bytes of register should be stored.
 * @example <code>[label] STCM R1,M3,D2(B2) </code>
 */
procedure void STCM(register,mask,storage);
/**
 * STORE CHANNEL PATH STATUS
 * <br>A channel-path-status word of up to 256 bits is stored at <b>storage</b>.
 * <br>Format={@link soperands S} Length=4 OpCode=B23A
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement of 32-byte boundary.
 * @example <code>[label] STCPS D2(B2) </code>
 */
procedure void STCPS(storage);
/**
 * STORE CHANNEL REPORT WORD
 * <br>A CRW containing information affecting the channel subsystem is stored at <b>storage</b>.
 * <br>Format={@link soperands S} Length=4 OpCode=B239
 * {@link rc47 Condition_Codes_Set}
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement for a word-bounda
 * @example <code>[label] STCRW D2(B2) </code>
 */
procedure void STCRW(storage);
/**
 * STORE CONTROL
 * <br>The set of control registers starting with control <b>register1</b> and ending
 * with control <b>register3</b> is stored at the locations designated by <b>storage</b>.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=B6
 * @param Register1 Any control register
 * @param Register3 Any control register
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement of a word boundary
 * @example <code>[label] STCTL R1,R3,D2(B2) </code>
 */
procedure void STCTL(register1,register3,storage);
/**
 * STORE (long)
 * <br>The long floating point value in <b>register</b> is stored at <b>storage</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=60
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register, and <b>D</b>isplacement
 * @example <code>[label] STD R1,D2(X2,B2) </code>
 */
procedure void STD(register,storage);
/**
 * STORE (short)
 * <br>The short floating point value in <b>register</b> is stored at <b>storage</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=70
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register, and <b>D</b>isplacement
 * @example <code>[label] STE R1,D2(X2,B2) </code>
 */
procedure void STE(register,storage);
/**
 * STORE FPC
 * <br>The contents of the Floating-Point-Control (FPC) register are stored
 * at <b>storage</b>.
 * <br>Format={@link soperands S} Length=4 OpCode=B29C
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] STFPC D2(B2) </code>
 */
procedure void STFPC(storage);
/**
 * STORE HALFWORD
 * <br>Bits 16-31 (the two low order bytes) are stored at <b>storage/b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=40
 * @param Register Any general register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register, and <b>D</b>isplacement
 * @example <code>[label] STH R1,D2(X2,B2) </code>
 */
procedure void STH(register,storage);
/**
 * STORE CPU ID
 * <br>Information  identifying  the  CPU  is  stored  at the doubleword location
 * designated by <b>storage</b>.
 * <br>Format={@link soperands S} Length=4 OpCode=B202
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] STIDP D2(B2) </code>
 */
procedure void STIDP(storage);
/**
 * STORE MULTIPLE
 * <br>The contents of <b>register1</b> through <b>register3</b> are placed in
 * memory designated by <b>storage</b>.  General Register 0 follows General Register 15.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=90
 * @param Register1 Any general register
 * @param Register3 Any general register
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] STM R1,R3,D2(B2) </code>
 */
procedure void STM(register1,register3,storage);
/**
 * STORE THEN AND SYSTEM MASK
 * <br>Bits 0-7 of the current PSW are stored at <b>storage</b> then bits 0-7
 * of the PSW are replaced by the logical AND of the original contents and
 * the <b>immediate-value</b>.
 * <br>Format={@link sioperands SI} Length=4 OpCode=AC
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Immediate-value bit mask to be used to AND with the PSW.
 * @example <code>[label] STNSM D1(B1),I2 </code>
 */
procedure void STNSM(storage,immediate-value);
/**
 * STORE THEN OR SYSTEM MASK
 * <br>Bits 0-7 of the current PSW are stored at <b>storage</b> then bits 0-7
 * of the PSW are replaced by the logical OR of the original contents and
 * the <b>immediate-value</b>.
 * <br>Format={@link sioperands SI} Length=4 OpCode=AD
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @param Immediate-value bit mask to be used to OR with the PSW.
 * @example <code>[label] STOSM D1(B1),I2 </code>
 */
procedure void STOSM(storage,immediate-value);
/**
 * STORE CPU TIMER
 * <br>The  current  value  of the CPU timer is stored at the doubleword location
 * designated <b>storage</b>.
 * <br>Format={@link soperands S} Length=4 OpCode=B209
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement
 * @example <code>[label] STPT D2(B2) </code>
 */
procedure void STPT(storage);
/**
 * STORE PREFIX
 * <br>The  contents of the prefix register are stored at the word location
 * designated by <b>storage</b>.   Zeros are provided for bit
 * positions 0 and 20-31.
 * <br>Format={@link soperands S} Length=4 OpCode=B211
 * @example <code>[label] STPX D2(B2) </code>
 */
procedure void STPX(storage);
/**
 * STORE SUBCHANNEL
 * <br>Control and status information for the subchannel indicated by General Register 1
 * is stored in the SCHIB referred to by <b>storage</b>.
 * <br>Format={@link soperands S} Length=4 OpCode=B234
 * @param Storage Storage label or <b>B</b>ase register and <b>D</b>isplacement (word boundary)
 * @param implied General Register 1 holds the subsystem-identification word
 * @example <code>[label] STSCH D2(B2) </code>
 */
procedure void STSCH(storage);
/**
 * STORE USING REAL ADDRESS
 * <br>The contents of <b>register1</b> are stored at the address specified by
 * <b>register2</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B246
 * @param Register1 Any general register
 * @param Register2 Any general register, contains real address of word boundary storage.
 * @example <code>[label] STURA R1,R2 </code>
 */
procedure void STURA(storage);
/**
 * SUBTRACT UNNORMALIZED (Short Hexadecimal-Floating-Point)
 * <br>The contents of <b>storage</b> is subtracted from the contents of
 * <b>register</b>.  Results are left in <b>register</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=7F
 * {@link rc48 Condition_Codes_Set}
 * @param Register Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register, and <b>D</b>isplacement
 * @example <code>[label] SU R1,D2(X2,B2) </code>
 */
procedure void SU(register,storage);
/**
 * SUBTRACT UNNORMALIZED (Short Hexadecimal-Floating-Point)
 * <br>The contents of <b>register2</b> is subtracted from the contents of
 * <b>register1</b>.  Results are left in <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=3F
 * {@link rc48 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] SUR R1,R2 </code>
 */
procedure void SUR(register1,register2);
/**
 * SUPERVISOR CALL
 * <br>The immediate-value is placed in the interruption code and a supervisor-call
 * interruption is invoked.
 * <br>Format={@link rroperands RR} Length=2 OpCode=0A
 * @param immediate-value The SVC call number.
 * @example <code>[label] SVC I </code>
 */
procedure void SVC(storage);
/**
 * SUBTRACT UNNORMALIZED (Long Hexadecimal-Floating-Point)
 * <br>The contents of <b>storage</b> is subtracted from the contents of
 * <b>register</b>.  Results are left in <b>register</b>.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=6F
 * {@link rc48 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Storage Storage label or <b>B</b>ase register, inde<b>X</b> register, and <b>D</b>isplacement
 * @example <code>[label] SW R1,D2(X2,B2) </code>
 */
procedure void SW(register,storage);
/**
 * SUBTRACT UNNORMALIZED (Long Hexadecimal-Floating-Point)
 * <br>The contents of <b>register2</b> is subtracted from the contents of
 * <b>register1</b>.  Results are left in <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=2F
 * {@link rc48 Condition_Codes_Set}
 * @param Register1 Any floating-point register
 * @param Register2 Any floating-point register
 * @example <code>[label] SWR R1,R2 </code>
 */
procedure void SWR(register1,register2);
/**
 * SUBTRACT (Extended Binary-Floating-Point)
 * <br>The value in <b>register2</b> is subtracted from the value in
 * <b>register1</b>.  Results are left in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B34B
 * {@link rc48 Condition_Codes_Set}
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any valid floating-point register pair
 * @example <code>[label] SXBR R1,R2 </code>
 */
procedure void SXBR(register1,register2);
/**
 * SUBTRACT NORMALIZED (Extended Hexadecimal-FLoating-Point)
 * <br>The value in <b>register2</b> is subtracted from the value in
 * <b>register1</b>.  Results are left in <b>register1</b>.
 * <br>Format={@link rroperands RR} Length=2 OpCode=37
 * {@link rc48 Condition_Codes_Set}
 * @param Register1 Any valid floating-point register pair
 * @param Register2 Any valid floating-point register pair
 * @example <code>[label] SXR R1,R2 </code>
 */
procedure void SXR(register1,register2);
/**
 * TEST ACCESS
 * <br>The  access-list-entry token (ALET) in access register
 * <b>register1</b> is tested for exceptions recognized during
 * access-register translation (ART).  The extended authorization index
 * (EAX) used is bits 0-15 of general register <b>register2</b>.
 * The ALET is also tested for whether it designates the dispatchable-unit
 * access list or the primary-space access list and for whether it is
 * 00000000 or 00000001 hex.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B24C
 * {@link rc49 Condition_Codes_Set}
 * @param Register1 Access register containing ALET
 * @param Register2 General register containing Extended Authorization Index (EAX)
 * @example <code>[label] TAR R1,R2 </code>
 */
procedure void TAR(register1,register2);
/**
 * TEST BLOCK
 * <br>The storage locations and storage key of a 4K-byte block are tested for
 * usability, and the result of the test is indicated in the condition code.
 * The test for usability is based on the susceptibility of the block to the
 * occurrence of invalid checking-block code.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B22C
 * @param Register1 Not used.
 * @param Register2 General register containing address of 4k storage block
 * @param implied General Register 0, should contain 0's
 * @example <code>[label] TB R2 </code>
 */
procedure void TB(register2);
/**
 * CONVERT HFP TO BFP (long)
 * <br>The long hexadecimal-floating-point (HFP) value in <b>reegister2</b> is
 * converted to long binary-floating-point (BFP) and placed in <b>register1</b>.
 * Rounding is controlled by the bits in <b>mask3</b>.
 * <br>Format={@link rrfoperands RRF} Length=4 OpCode=B351
 * @param Register1 Destination of long, rounded, BFP value
 * @param Register2 Source of long HFP value
 * @param Mask3 bit pattern controlling rounding,
 * {@link roundingmask see_rounding_mask_values}
 * @example <code>[label] TBDR R1,M3,R2 </code>
 */
procedure void TBDR(register1,register2,mask3);
/**
 * CONVERT HFP TO BFP (long to short)
 * <br>The long hexadecimal-floating-point (HFP) value in <b>reegister2</b> is
 * converted to short binary-floating-point (BFP) and placed in <b>register1</b>.
 * Rounding is controlled by the bits in <b>mask3</b>.
 * <br>Format={@link rrfoperands RRF} Length=4 OpCode=B351
 * @param Register1 Destination of long, rounded, BFP value
 * @param Register2 Source of long HFP value
 * @param Mask3 bit pattern controlling rounding,
 * {@link roundingmask see_rounding_mask_values}
 * @example <code>[label] TBDR R1,M3,R2 </code>
 */
procedure void TBEDR(register1,register2,mask3);
/**
 * TEST DATA CLASS (Long Binary-Floating-Point)
 * <br>The long BFP value in <b>register1</b> is tested to determine if it is
 * zero, normalized number, denormalized number, infinity, quiet NaN,
 * signaling NaN, postive or negative.  The test value is stored as a
 * bit pattern in bits 20-32
 * of the instruction (operand 2 displacement area).
 * <br>Format={@link rxeoperands RXE} Length=6 OpCode=ED11
 * {@link rc50 Condition_Codes_Set}
 * @param Register1 Contains a long BFP to be test for class and sign.
 * @param Storage Displacement value indicates one or more class and type
 * @example <code>[label] TCDB R1,D2(X2,B2) </code>
 */
procedure void TCDB(register,storage);
/**
 * TEST DATA CLASS (Short Binary-Floating-Point)
 * <br>The short BFP value in <b>register1</b> is tested to determine if it is
 * zero, normalized number, denormalized number, infinity, quiet NaN,
 * signaling NaN, postive or negative.  The test value is stored as a
 * bit pattern in bits 20-32
 * of the instruction (operand 2 displacement area).
 * <br>Format={@link rxeoperands RXE} Length=6 OpCode=ED10
 * {@link rc50 Condition_Codes_Set}
 * @param Register1 Contains a long BFP to be test for class and sign.
 * @param Storage Displacement value indicates one or more class and type
 * @example <code>[label] TCEB R1,D2(X2,B2) </code>
 */
procedure void TCEB(register,storage);
/**
 * TEST DATA CLASS (Extended Binary-FLoating-Point)
 * <br>The extended BFP value in <b>register1</b> is tested to determine if it is
 * zero, normalized number, denormalized number, infinity, quiet NaN,
 * signaling NaN and postive or negative.  The test value is stored as a
 * bit pattern in bits 20-32
 * of the instruction (operand 2 displacement area).
 * <br>Format={@link rxeoperands RXE} Length=6 OpCode=ED12
 * {@link rc50 Condition_Codes_Set}
 * @param Register1 Floating-point register pair containing an extended BFP to
 * be tested for class and sign.
 * @param Storage Displacement value indicates one or more class and type
 * @example <code>[label] TCXB R1,D2(X2,B2) </code>
 */
procedure void TCXB(register,storage);
/**
 * CONVERT BFP TO HFP (short to long)
 * <br>The short binary-floating-point value in <b>register2</b> is converted
 * to a long hexadecimal-floating-point value and placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B358
 * {@link rc51 Condition_Codes_Set}
 * @param Register1 Contains a long BFP to be test for class and sign.
 * @param register2 Contains the short BFP value to be converted
 * @example <code>[label] THDER R1,R2 </code>
 */
procedure void THDER(register1,register2);
/**
 * CONVERT BFP TO HFP (long)
 * <br>The long binary-floating-point value in <b>register2</b> is converted
 * to a long hexadecimal-floating-point value and placed in <b>register1</b>.
 * <br>Format={@link rreoperands RRE} Length=4 OpCode=B359
 * {@link rc51 Condition_Codes_Set}
 * @param Register1 Contains a long BFP to be test for class and sign.
 * @param Register2 Contains the long BFP value to be converted
 * @example <code>[label] THDR R1,R2 </code>
 */
procedure void THDR(register1,register2);
/**
 * TEST UNDER MASK
 * <br>The <b>immediate-value</b> mask is used to select bits for testing
 * from <b>storage</b>.  The value of the selected bits is indicated by the
 * condition code.
 * <br>Format={@link sioperands SI} Length=4 OpCode=91
 * {@link rc52 Condition_Codes_Set}
 * @param Storage Address of byte containing bits to be tested.
 * @param Immediate-value 8-bit Bit map to indicate which bits to test.
 * @example <code>[label] TM D1(B1),I2 </code>
 */
procedure void TM(storage,immediate-value);
/**
 * TEST UNDER MASK HIGH
 * <br>The 16-bit <b>immediate-value</b> is used to test leftmost 16 bits
 * of <b>register1</b>.  See {@link TM}
 * <br>Format={@link rioperands RI} Length=4 OpCode=A70
 * {@link rc53 Condition_Codes_Set}
 * @param Register1 General register to be tested (bits 0-16)
 * @param Immediate-value 16 bits indicating the bits of <b>register1</b>
 * to be tested
 * @example <code>[label] TMH R1,I2 </code>
 */
procedure void TMH(register,immediate-value);
/**
 * TEST UNDER MASK LOW
 * <br>The 16-bit <b>immediate-value</b> is used to test rightmost 16 bits
 * of <b>register1</b>.  See {@link TM}
 * <br>Format={@link rioperands RI} Length=4 OpCode=A71
 * {@link rc53 Condition_Codes_Set} <br>
 * @param Register1 General register to be tested (bits 0-16)
 * @param Immediate-value 16 bits indicating the bits of <b>register1</b>
 * to be tested
 * @example <code>[label] TML R1,I2 </code>
 */
procedure void TML(register,immediate-value);
/**
 * TEST PENDING INTERRUPTION
 * <br>The I/O-interruption code for a pending I/O-interruption request
 * is stored at  the location designated by <b>storage</b>,
 * and the pending I/O-interruption request is cleared.
 * <br>Format={@link soperands S} Length=4 OpCode=B236
 * {@link rc54 Condition_Codes_Set}
 * @param Storage Address where interrupt code is stored.  If zero the
 * interrupt code is stored at real address 184-191.
 * @example <code>[label] TPI D2(B2) </code>
 */
procedure void TPI(storage);
/**
 * TEST PROTECTION
 * <br>Test passed address to determine if accessing that storage would
 * result in a protection exception.
 * <br>Format={@link sseoperands SSE} Length=6 OpCode=E501
 * {@link rc55 Condition_Codes_Set}
 * @param Storage1 address of storage to be tested
 * @param Storage2 Not an address, bits 24-27 of computed value indicate the
 * access key for the test.
 * @example <code>[label] TPROT D1(B1),D2(B2) </code>
 */
procedure void TPROT(storage1,storage2);
/**
 * TRANSLATE
 * <br>Each byte of <b>storage1</b> is used as an offset from <b>storage2</b>.
 * The byte at <b>storage2</b> plus the offset replaces the byte at <b>storage1</b>.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=DC
 * @param Storage1 Address of storage to be translated, for length of L
 * @param Storage2 Address of table holding new byte values. Should
 * point to 256 bytes of storage to account for all offset values from
 * <b>storage1</b>.
 * @example <code>[label] TR D1(L,B1),D2(B2) </code>
 */
procedure void TR(storage1,storage2);
/**
 * TRACE
 * <br>Create an entry in storage pointed to by Control Register 12 containing
 * TOD, seelcted registers (<b>Register1</b> thru <b>register2</b>) and other
 * data.
 * <br>Format={@link rsoperands RS} Length=4 OpCode=99
 * @example <code>[label] TRACE R1,R3,D2(B2) </code>
 */
procedure void TRACE(storage);
/**
 * TRAP
 * <br> Perform a trap operation if the trap-enabled bit of the Dispatchable-
 * Unit Control Table (DUCT) is on.
 * <br>Format=E Length=2 OpCode=01FF
 */
procedure void TRAP2(storage);
/**
 * TRAP
 * <br> Perform a trap operation if the trap-enabled bit of the Dispatchable-
 * Unit Control Table (DUCT) is on.
 * <br>Format={@link soperands S} Length=4 OpCode=B2FF
 */
procedure void TRAP4(storage);
/**
 * TRANSLATE AND TEST
 * <br>Each byte of <b>stoarge1</b> is treated as an offset off of <b>storage2</b>.
 * If the corresponding byte at <b>storage2</b>+offset is zero, processing
 * continues with the next byte of <b>storage1</b>.  When the byte at
 * <b>storage2</b>+offset is not zero it is place in the low order byte of
 * General Purpose Register 2 and the address of the byte (off of <b>storage1</b>)
 * is placed in General Purpose Register 1.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=DD
 * {@link rc56 Condition_Codes_Set}
 * @param Storage1 Address of storage to be tested and translated.
 * @param Storage2 Address of replacement values table.  Should be 256 bytes long.
 * @example <code>[label] TRT D1(L,B1),D2(B2) </code>
 */
procedure void TRT(storage1,storage2);
/**
 * TEST AND SET
 * <br>The leftmost bit (bit 0) of the byte located at
 * <b>storage</b> is used to set the condition code,
 * and then the byte is set to all ones.
 * <br>Format={@link soperands S} Length=4 OpCode=93
 * {@link rc57 Condition_Codes_Set}
 * @param Storage Address of byte tested and then seto to xFF
 * @example <code>[label] TS D2(B2) </code>
 */
procedure void TS(storage);
/**
 * TEST SUBCHANNEL
 * <br>Control and status information for the subchannel is stored
 * in the designated IRB.
 * <br>Format={@link soperands S} Length=4 OpCode=B235
 * {@link rc58 Condition_Codes_Set}
 * @param Storage Full-word boundary address of the IRB
 * @param implied General Register 1, containing the subsystem
 * identification word.
 * @example <code>[label] TSCH D2(B2) </code>
 */
procedure void TSCH(storage);
/**
 * UNPACK
 * <br> The packed deciaml value at <b>storage2</b> is converted
 * to zoned decimal and placed at <b>storage1</b>.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=F3
 * @param Storage1 address of result field
 * @param Storage2 address of packed decimal value
 * @example <code>[label] UNPK D1(L1,B1),D2(L2,B2) </code>
 */
procedure void UNPK(storage1,storage2);
/**
 * UPDATE TREE
 * <br>The doubleword nodes of a tree in storage are examined successively
 * on a path toward the base of the tree, and the contents of general-register
 * pair 0-1 are conditionally interchanged with the contents of the nodes so
 * as to give a unique maximum logical value in general register 0.
 * <br>Format=E Length=2 OpCode=0102
 * {@link rc59 Condition_Codes_Set}
 */
procedure void UPT(storage);
/**
 * EXCLUSIVE OR
 * <br>Used for inverting bit values.  Bits of <b>register</b> and
 * <b>storage</b> are compared and the bits
 * of <b>register</b> are set to indicate the results of the comparison.
 * If the two bits are alike, the bit of <b>register</b> is set to 0, if the
 * bits are not alike, the bit of <b>register</b> is set to 1.
 * <br>Format={@link rxoperands RX} Length=4 OpCode=57
 * {@link rc3 Condition_Codes_Set}
 * @param Register 32 bits that will be compared to bits at storage and set.
 * @param Storage Fullword of storage that control the setting of bits in <b>register</b>
 * @example <code>[label] X R1,D2(X2,B2) </code>
 */
procedure void X(register,storage);
/**
 * EXCLUSIVE OR (character)
 * <br>Used for inverting bit values.  Bits of <b>storage1</b> and
 * <b>storage2</b> are compared and the bits
 * of <b>storage1</b> are set to indicate the results of the comparison.
 * If the two bits are alike, the bit of <b>storge1</b> is set to 0, if the
 * bits are not alike, the bit of <b>storage1</b> is set to 1.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=D7
 * {@link rc3 Condition_Codes_Set}
 * @param Storage1 address of storage holding bits to be inverted
 * @param Storage2 address of storage that control the setting of bits in <b>storage1</b>
 * @example <code>[label] XC D1(L,B1),D2(B2) </code>
 */
procedure void XC(storage1,storage2);
/**
 * EXCLUSIVE OR (immediate)
 * <br>Used for inverting bit values.  Bits of <b>immediate-value</b> and
 * <b>storage</b> are compared and the bits
 * of <b>storage</b> are set to indicate the results of the comparison.
 * If the two bits are alike, the bit of <b>storage</b> is set to 0, if the
 * bits are not alike, the bit of <b>storage</b> is set to 1.
 * <br>Format={@link sioperands SI} Length=4 OpCode=97
 * {@link rc3 Condition_Codes_Set}
 * @param Storage address of one byte that will be inverted
 * @param immediate-value 8 bit mask that controls which bits of <b>storage</b>
 * are inverted
 * @example <code>[label] XI D1(B1),I2 </code>
 */
procedure void XI(storage,immediate-value);
/**
 * EXCLUSIVE OR
 * <br>Used for inverting bit values.  Bits of <b>register1</b> and
 * <b>register2</b> are compared and the bits
 * of <b>register1</b> are set to indicate the results of the comparison.
 * If the two bits are alike, the bit of <b>register1</b> is set to 0, if the
 * bits are not alike, the bit of <b>register1</b> is set to 1.
 * <br>Format={@link rroperands RR} Length=2 OpCode=17
 * {@link rc3 Condition_Codes_Set}
 * @param Register1 32 bits that will be compared to bits at storage and set.
 * @param Register2 32 bits that control the setting of bits in <b>register1</b>
 * @example <code>[label] XR R1,R2 </code>
 */
procedure void XR(register1,register2);
/**
 * ZERO AND ADD
 * <br> Storage at <b>storage1</b> is set to packed deciaml zero and then the
 * packed-decimal value at <b>storage2</b> is added.
 * <br>Format={@link ssoperands SS} Length=6 OpCode=F8
 * {@link rc42 Condition_Codes_Set}
 * @param Storage1 result field, initial value ignored
 * @param Storage2 Packed-decimal value to be placed at <b>storage1</b>
 * @example <code>[label] ZAP D1(L1,B1),D2(L2,B2) </code>
 */
procedure void ZAP(storage);
/**
 * QST Format Operands<br>
 * <dl compact>
 * <dt>VR1<dd>Vector Register (0-15)
 * <dt>RS2<dd>Register containing starting address of vector (0-15)
 * <dt>RT2<dd>Register containing stride of vector (0-15)
 * <dt>QR3<dd>General or Floating-point register (0-15)
 * </dl>
 */
private const qstoperands;
/**
 * QV Format Operands
 * <dl compact>
 * <dt>VR1<dd>Vector Register (0-15)
 * <dt>VR2<dd>Vector Register (0-15)
 * <dt>QR3<dd>General or Floating-point register (0-15)
 * </dl>
 */
private const qvoperands;
/**
 * RR (register and register) Format Operands
 * <dl compact>
 * <dt>R1<dd>Register containing address of operand 1 (0-15)
 * <dt>R2<dd>Register containing address of operand 2 (0-15)
 * </dl>
 */
private const rroperands;
/**
 * RRE (register and register with extended opcode) Format Operands
 * <dl compact>
 * <dt>R1<dd>Register containing operand 1 (0-15)
 * <dt>R2<dd>Register containing operand 2 (0-15)
 * </dl>
 */
private const rreoperands;
/**
 * RRf (register and register with extended opcode) Format Operands
 * <dl compact>
 * <dt>R1<dd>Register containing operand 1 (0-15)
 * <dt>R2<dd>Register containing operand 2 (0-15)
 * <dt>R3<dd>usage depends on instruction (0-15)
 * </dl>
 */
private const rrfoperands;
/**
 * RS (register and storage) Format Operands
 * <dl compact>
 * <dt>R1<dd>Register containing address of operand 1 (0-15)
 * <dt>B2<dd>Register containing base address of operand 2 (0-15)
 * <dt>D2<dd>Displacement of operand 2 (0-4095)
 * <dt>R3<dd>Register designation depending on instruction (0-15)
 * </dl>
 */
private const rsoperands;
/**
 * RSI (register, register and immedaate-value) Format Operands
 * <dl compact>
 * <dt>R1<dd>Register containing address of operand 1 (0-15)
 * <dt>I2<dd>haldword immediate value imbedded within instruction (x'0000'-x'FFFF')
 * <dt>R3<dd>Register designation depending on instruction (0-15)
 * </dl>
 */
private const rsioperands;
/**
 * RX (register and indexed-storage) Format Operands
 * <dl compact>
 * <dt>R1<dd>Register containing address of operand 1 (0-15)
 * <dt>B2<dd>Register containing base address of operand 2 (0-15)
 * <dt>D2<dd>Displacement of operand 2 (0-4095)
 * <dt>X2<dd>Register containing index value to be added to base and displacement (0-15)
 * </dl>
 */
private const rxoperands;
/**
 * RXE (register and indexed-storage extended opcode) Format Operands
 * <dl compact>
 * <dt>R1<dd>Register containing address of operand 1 (0-15)
 * <dt>B2<dd>Register containing base address of operand 2 (0-15)
 * <dt>D2<dd>Displacement of operand 2 (0-4095)
 * <dt>X2<dd>Register containing index value to be added to base and displacement (0-15)
 * </dl>
 */
private const rxeoperands;
/**
 * S (implied-operand and storage) Format Operands
 * <dl compact>
 * <dt>B2<dd>Register containing base address of operand 2 (0-15)
 * <dt>D2<dd>Displacement of operand 2 (0-4095)
 * </dl>
 */
private const soperands;
/**
 * SI (storage and immediate-operand) Format Operands
 * <dl compact>
 * <dt>I2<dd>Immediate value (x'00'-x'FF')
 * <dt>B1<dd>Register containing base address of operand 1 (0-15)
 * <dt>D1<dd>Displacement of operand 1 (0-4095)
 * </dl>
 */
private const sioperands;
/**
 * VR Format Operands
 * <dl compact>
 * <dt>VR1<dd>(0-15)
 * <dt>GR2<dd>(0-15)
 * <dt>QR3<dd>(0-15)
 * </dl>
 */
private const vroperands;
/**
 * VS Format Operands
 * <dl compact>
 * <dt>RS2<dd>(0-15)
 * </dl>
 */
private const vsoperands;
/**
 * VST Format Operands
 * <dl compact>
 * <dt>VR1<dd>(0-15)
 * <dt>RS2<dd>(0-15)
 * <dt>RT2<dd>(0-15)
 * <dt>VR3<dd>(0-15)
 * </dl>
 */
private const vstoperands;
/**
 * VV Format Operands
 * <dl compact>
 * <dt>VR1<dd>(0-15)
 * <dt>VR2<dd>(0-15)
 * <dt>VR3<dd>(0-15)
 * </dl>
 */
private const vvoperands;
/**
 * RSE Format Operands
 * <dl compact>
 * <dt>VR1<dd>(0-15)
 * <dt>B2<dd>Register containing base address of operand 2 (0-15)
 * <dt>D2<dd>Displacement of operand 2 (0-4095)
 * <dt>R3<dd>Register designation depending on instruction (0-15)
 * </dl>
 */
private const rseoperands;
/**
 * SS (storage and storage) Format Operands (option 1)
 * <dl compact>
 * <dt>R1<dd>(0-15)
 * <dt>B1<dd>Register containing base address of operand 1 (0-15)
 * <dt>D1<dd>Displacement of operand 1 (0-4095)
 * <dt>B2<dd>Register containing base address of operand 2 (0-15)
 * <dt>D2<dd>Displacement of operand 2 (0-4095)
 * <dt>R3<dd>(0-15)
 * </dl>
 */
private const ssoperandsa;
/**
 * SS (storage and storage) Format Operands (option 2)
 * <dl compact>
 * <dt>L1<dd>Length of operand 1 (0-15)
 * <dt>B1<dd>Register containing base address of operand 1 (0-15)
 * <dt>D1<dd>Displacement of operand 1 (0-4095)
 * <dt>L2<dd>Length of operand 2 (0-15)
 * <dt>B2<dd>Register containing base address of operand 2 (0-15)
 * <dt>D2<dd>Displacement of operand 2 (0-4095)
 * </dl>
 */
private const ssoperandsb;
/**
 * SS (storage and storage) Format Operands (option 3)
 * <dl compact>
 * <dt>L<dd>Length of operand (0-255)
 * <dt>B1<dd>Register containing base address of operand 1 (0-15)
 * <dt>D1<dd>Displacement of operand 1 (0-4095)
 * <dt>B2<dd>Register containing base address of operand 2 (0-15)
 * <dt>D2<dd>Displacement of operand 2 (0-4095)
 * </dl>
 */
private const ssoperandsc;
/**
 * SSE (storage and storage with extended opcode) Format Operands
 * <dl compact>
 * <dt>B1<dd>Register containing base address of operand 1 (0-15)
 * <dt>D1<dd>Displacement of operand 1 (0-4095)
 * <dt>B2<dd>Register containing base address of operand 2 (0-15)
 * <dt>D2<dd>Displacement of operand 2 (0-4095)
 * </dl>
 */
private const sseoperands;
/**
 * Assembler instructions operands
 * <dl compact>
 * <dt>L<dd>Length of operation (0-255)
 * <dt>I<dd>Immediate value (see SVC) (x'00' - x'FF')
 * <dt>B1<dd>Register containing base address of operand 1 (0-15)
 * <dt>D1<dd>Displacement of operand 1 (0-4095)
 * <dt>L1<dd>Length of operand 1 (0-15)
 * <dt>R1<dd>Register containing address of operand 1 (0-15)
 * <dt>B2<dd>Register containing base address of operand 2 (0-15)
 * <dt>D2<dd>Displacement of operand 2 (0-4095)
 * <dt>I2<dd>Immediate value for operand 2 (x'00'-x'FF')
 * <dt>L2<dd>Length of operand 2 (0-15)
 * <dt>R2<dd>Register containing address of operand 2 (0-15)
 * <dt>X2<dd>Register containing index value to be added to base and displacement (0-15)
 * <dt>R3<dd>Register containingg values depending on instruction (0-15)
 * <dt>M3<dd>Mask value
 * </dl>
 */
private const operands;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Result zero; no overflow
 * <dt>1<dd>Result less than zero; no overflow
 * <dt>2<dd>Result greater than zero; no overflow
 * <dt>3<dd>Overflow
 * </dl>
 */
private const rc1;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Result zero, no carry
 * <dt>1<dd>Result not zero; no carry
 * <dt>2<dd>Result zero; carry
 * <dt>3<dd>Result not zero; carry
 * </dl>
 */
private const rc2;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Resulting bits all zero
 * <dt>1<dd>Resulting bits not all zero
 * </dl>
 */
private const rc3;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Operands equal
 * <dt>1<dd>First operand low
 * <dt>2<dd>First operand high
 * </dl>
 */
private const rc4;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Operands equal
 * <dt>1<dd>First operand low & ctl=0 or first operand high & ctl=1
 * <dt>2<dd>First operand high & ctl=0 or first operand low & ctl=1
 * </dl>
 */
private const rc5;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Operands equal (or mask zero, or lengths = 0)
 * <dt>1<dd>Operands not equal
 * </dl>
 */
private const rc6;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>All zero or mask is zero
 * <dt>1<dd>Leftmost bit = 1
 * <dt>2<dd>Not zero but with leftmost bit = 0
 * </dl>
 */
private const rc7;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Zero
 * <dt>1<dd>Less than zero
 * <dt>2<dd>Greater than zero
 * </dl>
 */
private const rc8;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Zero
 * <dt>1<dd>Less than zero
 * </dl>
 */
private const rc9;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Zero
 * <dt>2<dd>Greater than zero
 * <dt>3<dd>Overflow
 * </dl>
 */
private const rc10;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Operand lengths equal
 * <dt>1<dd>First operand shorter
 * <dt>2<dd>First operand longer
 * <dt>3<dd>Operands overlap
 * </dl>
 */
private const rc11;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>1<dd>Not zero; no carry
 * <dt>2<dd>Zero; carry
 * <dt>3<dd>Not zero; carry
 * </dl>
 */
private const rc12;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Leftmost bit zero
 * <dt>1<dd>Leftmost bit one
 * </dl>
 */
private const rc13;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>All zeros or mask is zero
 * <dt>1<dd>Mixed 0's and 1's
 * <dt>3<dd>All 1's
 * </dl>
 */
private const rc14;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>All zeros
 * <dt>1<dd>Not zero, scan incomplete
 * <dt>2<dd>Not zero, scan complete
 * </dl>
 */
private const rc15;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Compare equal at current node on path
 * <dt>1<dd>Path complete, no nodes compared equal
 * <dt>3<dd>Path not complete and comparand register negative
 * </dl>
 */
private const rc16;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Active bits all zero
 * <dt>1<dd>Active bits 0's & 1's
 * <dt>3<dd>Active bits all 1's
 * </dl>
 */
private const rc17;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Source was zero
 * <dt>1<dd>Source was less than zero
 * <dt>2<dd>Source was greater than zero
 * <dt>3<dd>Special case
 * </dl>
 */
private const rc18;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Entire second operand processed
 * <dt>3<dd>CPU-determined amount of second operand processed
 * </dl>
 */
private const rc19;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Function initiated
 * <dt>3<dd>Not operational
 * </dl>
 */
private const rc20;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Remainder complete; normal quotient
 * <dt>1<dd>Remainder complete; quotient overflow or NaN
 * <dt>2<dd>Remainder incomplete; normal quotient
 * <dt>3<dd>Remainder incomplete; quotient overflow or NaN
 * </dl>
 */
private const rc21;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Branch state entry
 * <dt>1<dd>Program-call state entry
 * </dl>
 */
private const rc22;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Function initiated
 * <dt>1<dd>Status-pending with other than intermediate status
 * <dt>2<dd>Busy
 * <dt>3,dd>Not operational
 * </dl>
 */
private const rc23;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>PSW bits 16 and 17 zeros (indicating primary-space mode)
 * <dt>1<dd>PSW bit 16 one and bit 17 zero (indicating secondary-space mode)
 * <dt>2<dd>PSW bit 16 zero and bit 17 one (indicating access-register mode)
 * <dt>3<dd>PSW bits 16 and 17 ones (indicating home-space mode)
 * </dl>
 */
private const rc24;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Operands equal
 * <dt>1<dd>First operand low
 * <dt>2<dd>First operand high
 * <dt>3<dd>Operands unordered
 * </dl>
 */
private const rc25;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Translation and authorization complete; parameters loaded
 * <dt>1,dd>Primary ASN or subspace not available; parameters not loaded
 * <dt>2<dd>Secondary ASN not available or not authorized, or secondary subspace not available; parameters not loaded
 * <dt>3<dd>Space-switch event specified; parameters not loaded
 * </dl>
 */
private const rc26;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Results zero
 * <dt>1<dd>Results less than zero
 * <dt>2<dt>Results greater than zero
 * <dt>3<dt>Results not a number (NaN)
 * </dl>
 */
private const rc27;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Operands equal
 * <dt>1<dd>Operand-control bit zero and operand 1 low, or operand-control bit one and operand 3 low
 * <dt>2<dd>Operand-control bit zero and operand 1 high, or operand-control bit one and operand 3 high
 * </dl>
 */
private const rc28;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Equal substrings of specified length found
 * <dt>1<dd>End of longer operand reached when last bytes compared are equal
 * <dt>2<dd>End of longer operand reached when last bytes compared are unequal
 * <dt>3<dd>Last bytes compared are unequal, and CPU-determined number of bytes compared
 * </dl>
 */
private const rc29;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Result is zero
 * <dt>1<dd>Result less than zero
 * <dt>3<dd>Result is a NaN
 * </dl>
 */
private const rc30;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Result is zero
 * <dt>2<dd>Result is greater than zero
 * <dt>3<dd>Result is an NaN
 * </dl>
 */
private const rc31;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Result is zero
 * <dt>2<dd>Results is greater than zero
 * </dl>
 */
private const rc32;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Translation available
 * <dt>1<dd>Segment-table entry invalid (I bit is one)
 * <dt>2<dd>Page-table entry invalid (I bit is one)
 * <dt>3<dd>Segment-table designation not available or segment- or page-table length exceeded
 * </dl>
 */
private const rc33;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>True length less than or equal to 256
 * <dt>3<dd>True length greater than 256
 * </dl>
 */
private const rc34;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Operand lengths equal; no destructive overlap
 * <dt>1<dd>First-operand shorter; no destructive overlap
 * <dt>2<dd>First-operand longer; no destructive overlap
 * <dt>3<dd>No movement due to destructive overlap
 * </dl>
 */
private const rc35;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>All bytes moved, operand lengths equal
 * <dt>1<dd>All bytes moved, first operand shorter
 * <dt>2<dd>All bytes moved, first operand longer
 * <dt>3<dd>CPU-determined number of bytes moved without reaching end of first operand.
 * </dl>
 */
private const rc36;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Data moved
 * <dt>1<dd>1st operand invalid and 2nd operand valid both operands valid in expanded storage, translation path locked,
 * expanded-storage block unavailable, or expanded-storage data error
 * <dt>2<dd>2nd operand invalid
 * <dt>3<dd>
 * </dl>
 */
private const rc37;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>1<dd>Entire 2nd operand moved.  R1 contains ending character in first operand
 * <dt>3<dd>CPU-determined number of bytes moved.  R1 and R2 point to first unmoved byte and next destination byte.
 * </dl>
 */
private const rc38;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Function initiated
 * <dt>2<dd>Busy
 * <dt>3<dd>Not operational
 * </dl>
 */
private const rc39;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Reference bit zero; change bit zero
 * <dt>1<dd>Reference bit zero; change bit one
 * <dt>2<dd>Reference bit one; change bit zero
 * <dt>3<dd>Reference bit one; change bit one
 * </dl>
 */
private const rc40;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Function initiated
 * <dt>1<dd>Status-pending
 * <dt>2<dd>Function not applicable
 * <dt>3<dd>Not operational
 * </dl>
 */
private const rc41;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Result zero; no overflow
 * <dt>1<dd>Result less than zero; no overflow
 * <dt>2<dd>Result greater than zero; no overflow
 * <dt>3<dd>Overflow
 * </dl>
 */
private const rc42;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Clock value set
 * <dt>1<dd>Clock value secure
 * <dt>3<dd>Clock in not-operational state
 * </dl>
 */
private const rc43;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Order code accepted
 * <dt>1<dd>Status stored
 * <dt>2<dd>Busy
 * <dt>3<dd>Not operational
 * </dl>
 */
private const rc44;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>1<dd>Character found
 * <dt>2<dd>Character not found in operand 2
 * <dt>3<dd>Character not found in CPU-determined number of bytes.
 * </dl>
 */
private const rc45;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Clock is in set state
 * <dt>1<dd>Clock is in not-set state
 * <dt>2<dd>Clock is in error state
 * <dt>3<dd>Clock is in stopped state or not-operational state
 * </dl>
 */
private const rc46;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>CRW stored
 * <dt>1<dd>Zeros stored
 * </dl>
 */
private const rc47;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Result fraction zero
 * <dt>1<dd>Results less than zero
 * <dt>2<dd>Results greater than zero
 * </dl>
 */
private const rc48;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Access-list-entry token (ALET) is x00000000
 * <dt>1<dd>ALET designates the dispatchable-unit access listand does
 * cause exceptions in access-register translation (ART)
 * <dt>2<dd>ALET designates the primary-space access list and does not cause
 * exceptions in ART
 * <dt>3<dd>ALET is x00000001 or causes exceptions in ART
 * </dl>
 */
private const rc49;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Selected bit (in operand 1) is 0 (no match)
 * <dt>1<dd>Selected bit (in operand 1) is 1 (match)
 * </dl>
 */
private const rc50;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Source was zero
 * <dt>1<dd>Source was elss than zero
 * <dt>2<dd>Source was greater than zero
 * <dt>3<dd>Special case
 * </dl>
 */
private const rc51;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Selected bits zero or mask bits all zero
 * <dt>1<dd>Selected bits mixed zeros and ones
 * <dt>2<dd>
 * <dt>3<dd>Selected bits all ones
 * </dl>
 */
private const rc52;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Selected bits zero or mask bits all zero
 * <dt>1<dd>Selected bits mixed zeros and ones, leftmost bit is zero
 * <dt>2<dd>Selected bits mixed zeros and ones, rightmost bit is one
 * <dt>3<dd>Selected bits all ones
 * </dl>
 */
private const rc53;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Interrupt code not stored
 * <dt>1<dd>Interrupt code stored
 * </dl>
 */
private const rc54;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Fetching permitted, storing permitted
 * <dt>1<dd>Fetching permitted, storing not permitted
 * <dt>2<dd>Fetching not permitted, storing not permitted
 * <dt>3<dd>Translation not available (operand 2)
 * </dl>
 */
private const rc55;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>All replacement bytes zero
 * <dt>1<dd>Non-zero replacement byte found, not end of operand 1
 * <dt>2<dd>Non-zero replacement byte found, end of operand 1
 * </dl>
 */
private const rc56;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Leftmost bit 0
 * <dt>1<dd>Leftmost bit 1
 * </dl>
 */
private const rc57;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>IRB stored; subchannel status-pending
 * <dt>1<dd>IRB stored; subchannel not status-pending
 * <dt>3<dd>Not operational
 * </dl>
 */
private const rc58;
/**
 * @resulting-condition-code
 * <dl compact>
 * <dt>0<dd>Equal compare values at currently addressed node
 * <dt>1<dd>No equal compare values found on path, or no comparison made
 * <dt>3<dd>General register 5 nonzero and general register 0 negative
 * </dl>
 */
private const rc59;
/**
 * <dl compact>
 * <dt>cc<dd>Mask Bit
 * <dt>0<dd>8
 * <dt>1<dd>4
 * <dt>2<dd>2
 * <dt>3<dd>1
 * </dl>
 * @example Mask 12 branchs on condition 0 or 1
 */
private const mask;
/**
 * <dl compact>
 * <dt>M3<dd>Rounding method
 * <dt>0<dd>According to current rounding mode
 * <dt>1<dd>Biased round to nearest
 * <dt>4<dd>Round to nearest
 * <dt>5<dd>Round toward 0
 * <dt>6<dd>Round toward +&infinity
 * <dt>7<dd>Round toward -&infinity
 * </dl>
 */
private const roundingmask;
/**
 * <dl compact>
 * <dt>Name<dd>Hex code
 * <dt>Digit Selector<dd>x'20'
 * <dt>Significance starter<dd>x'21'
 * <dt>Field Separator<dd>x'22'
 * <dt>Message byte<dd>any other value
 * </dl>
 * @example x'5B5B6B5B5B214B2020'
 */
private const editpattern;


///////////////////////////////////////////////////////////////////////////
// ASSEMBLER SYSTEM VARIABLES
//

/**
 * Use &SYSADATA_DSN in a macro definition to obtain the name of the data set to
 * which the assembler is writing the associated data.
 * <P>
 * The local system variable symbol &SYSADATA_DSN is assigned a read-only value
 * each time a macro definition is called.
 * <P>
 * When the assembler runs on the MVS/ESA operating systems, the value
 * of the character string assigned to &SYSADATA_DSN is always the value stored in
 * the JFCB for SYSADATA. If SYSADATA is allocated to DUMMY, or a NULLFILE,
 * the value in &SYSADATA_DSN is NULLFILE.
 * <P>
 * For example, &SYSADATA_DSN might be assigned a value such as:
 * <PRE>
 *    VCATR49.SYSADATA
 * </PRE>
 * When the assembler runs on the CMS component of the VM/ESA
 * operating systems, the value of the character string assigned
 * to &SYSADATA_DSN is determined as follows:
 * <UL>
 * <LI><B>CMS file</B> -- 
 * The 8-character filename, the 8-character filetype, and the
 * 2-character filemode of the file, each separated by a blank
 * <LI><B>Dummy file (no physical I/O)</B> -- DUMMY
 * <LI><B>Labeled tape file</B> --
 * The data set name of the tape file
 * <LI><B>Unlabeled tape file</B> --
 * TAP<VAR>n</VAR>, where <VAR>n</VAR> is a value from 0 to 9, or A to F.
 * </DL>
 * <P>
 * For example, &SYSADATA_DSN might be assigned a value such as:
 * <PRE>
 *    SAMPLE SYSADATA A1
 * </PRE>
 * The value of the character string assigned to &SYSADATA_DSN is the disk
 * <P>
 * For example, &SYSADATA_DSN might be assigned a value such as:
 * <PRE>
 *    VCATR49.SYSADAT
 * </PRE>
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSADATA_DSN (T.... &SYSADATA_DSN) is
 * always U.
 * <LI>The value of the count attribute of &SYSADATA_DSN (K.... &SYSADATA_DSN)
 * is equal to the number of characters assigned as a value to
 * &SYSADATA_DSN. In the CMS example above, the count attribute of
 * &SYSADATA_DSN is 20.
 * </OL>
 */
property "&SYSADATA_DSN";
/**
 * The value of &SYSADATA_MEMBER is always null. The value of the
 * type attribute is O, and the value of the count attribute is 0.
 * <P>
 * You can use &SYSADATA_MEMBER in a macro definition to obtain
 * the name of the data set member to which the assembler is writing the associated
 * data.
 * <P>
 * The local system variable symbol &SYSADATA_MEMBER is assigned a read-only
 * value each time a macro definition is called.
 * <P>
 * If the data set to which the assembler is writing the associated data is not an MVS
 * partitioned data set, &SYSADATA_MEMBER is assigned a null character string.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSADATA_MEMBER
 * T.... &SYSADATA_MEMBER) is U, unless &SYSADATA_MEMBER is assigned a
 * null character string, in which case the value of the type attribute is O.
 * <LI>The value of the count attribute of &SYSADATA_MEMBER
 * K.... &SYSADATA_MEMBER) is equal to the number of characters assigned as
 * a value to &SYSADATA_MEMBER. If &SYSADATA_MEMBER is assigned a
 * null character string, the value of the count attribute is 0.
 * </OL>
 */
property "&SYSADATA_MEMBER";
/**
 * Use &SYSADATA_VOLUME in a macro definition to obtain the volume identifier of
 * the first volume containing the data set to which the assembler is writing the
 * associated data.
 * <P>
 * The local system variable symbol &SYSADATA_VOLUME is assigned a read-only
 * value each time a macro definition is called.
 * <P>
 * If the assembler runs on the CMS component of the VM/ESA operating
 * system, and the associated data is being written to a Shared File System CMS file,
 * SYSADATA_VOLUME is assigned the value SFS.
 * <P>
 * If the volume on which the data set resides is not labeled, &SYSADATA_VOLUME
 * is assigned a null character string.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSADATA_VOLUME
 * T.... &SYSADATA_VOLUME) is U, unless &SYSADATA_VOLUME is assigned a
 * null character string, in which case the value of the type attribute is O.
 * <LI>The value of the count attribute of &SYSADATA_VOLUME
 * K.... &SYSADATA_VOLUME) is equal to the number of characters assigned as a
 * value to &SYSADATA_VOLUME. If &SYSADATA_VOLUME is assigned a null
 * character string, the value of the count attribute is 0. The maximum length of
 * this system variable symbol is 6.
 * </OL>
 */
property "&SYSADATA_VOLUME";
/**
 * Use &SYSASM to obtain the name of the assembler being used to assemble your
 * source module. &SYSASM has a global scope. For example, when IBM High
 * Level Assembler for MVS & VM & VSE is used, &SYSASM has the value:
 * <PRE>
 *    HIGH LEVEL ASSEMBLER
 * </PRE>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSASM (T.... &SYSASM) is always U.
 * <LI>The value of the count attribute (K.... &SYSASM) is the number of characters
 * assigned. In the above example, the count attribute of &SYSASM is 20.
 * </OL>
 */
property "&SYSASM";
/**
 * Use &SYSCLOCK to obtain the TOD clock date and time at which the macro was
 * generated.
 * <P>
 * The local system variable symbol &SYSCLOCK is assigned a read-only value each
 * time a macro definition is called.
 * <P>
 * The value of &SYSCLOCK is a 26-character string in the format:
 * <PRE>
 *    YYYY-MM-DD HH:MM:SS mmmmmm
 * </PRE>
 * where:
 * <UL>
 * <LI>YYYY is a four-digit field that gives the year, including the century. It has a value
 * between 0000 and 9999, inclusive.
 * <LI>MM is a two-digit field that gives the month of the year. It has a value between
 * 01 and 12, inclusive.
 * <LI>DD is a two-digit field that gives the day of the month. It has a value between
 * 01 and 31, inclusive.
 * <LI>HH is a two-digit field that gives the hour of the day. It has a value between
 * 00 and 23, inclusive.
 * <LI>MM is a two-digit field that gives the minute of the hour. It has a value
 * between 00 and 59, inclusive.
 * <LI>SS is a two-digit field that gives the second of the minute. It has a value
 * between 00 and 59, inclusive.
 * <LI>mmmmmm is a six-digit field that gives the microseconds. It has a value between
 * 000000 and 999999, inclusive.
 * </UL>
 * <P>
 * <B>Example:</B>
 * <PRE>
 *    2 1-6-8 17:36:3 43284
 * </PRE>
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSCLOCK (T.... &SYSCLOCK) is always U.
 * <LI>The value of the count attribute (K.... &SYSCLOCK) is always 26.
 * </OL>
 */
property "&SYSCLOCK";
/**
 * Use &SYSDATC to obtain the date, including the century, on which your source
 * module is assembled. &SYSDATC has a global scope.
 * <P>
 * The value of &SYSDATC is an 8-character string in the format:
 * <PRE>
 *    YYYYMMDD
 * </PRE>
 * where:
 * <UL>
 * <LI>YYYY is four-digit field that gives the year, including the century. It has a value
 * between 0000 and 9999, inclusive.
 * <LI>MM is two-digit field that gives the month of the year. It has a value between 01
 * and 12, inclusive.
 * <LI>DD is two-digit field that gives the day of the month. It has a value between 01
 * and 31, inclusive.
 * </UL>
 * <P>
 * <B>Example:</B>
 * <PRE>
 *    1995 328
 * </PRE>
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The date corresponds to the date printed in the page heading of listings and
 * remains constant for each assembly.
 * <LI>The value of the type attribute of &SYSDATC (T.... &SYSDATC) is always N.
 * <LI>The value of the count attribute (K.... &SYSDATC) is always 8.
 * </OL>
 */
property "&SYSDATC";
/**
 * Use &SYSDATE to obtain the date, in standard format, on which your source
 * module is assembled. &SYSDATE has a global scope.
 * <P>
 * The value of &SYSDATE is an 8-character string in the format:
 * <PRE>
 *    MM/DD/YY
 * </PRE>
 * where:
 * <UL>
 * <LI>MM is a two-digit field that gives the month of the year. It has a value between
 * 01 and 12, inclusive.
 * <LI>DD is a two-digit field that gives the day of the month. It has a value between
 * 01 and 31, inclusive. It is separated from MM by a slash.
 * <LI>YY is a two-digit field that gives the year of the century. It has a value between
 * 00 and 99, inclusive. It is separated from DD by a slash.
 * </UL>
 * <P>
 * <B>Example:</B>
 * <PRE>
 *    3/28/95
 * </PRE>
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The date corresponds to the date printed in the page heading of listings and
 * remains constant for each assembly.
 * <LI>The value of the type attribute of &SYSDATE (T.... &SYSDATE) is always U.
 * <LI>The value of the count attribute (K.... &SYSDATE) is always 8.
 * </OL>
 */
property "&SYSDATE";
/**
 * Use &SYSECT in a macro definition to generate the name of the current control
 * section. The current control section is the control section in which the macro
 * instruction that calls the definition appears.
 * <P>
 * The local system variable symbol &SYSECT is assigned a read-only value each
 * time a macro definition is called.
 * <P>
 * The value assigned is the symbol that represents the name of the current control
 * section from which the macro definition is called. Note that it is the control section
 * in effect when the macro is called. A control section that has been initiated or
 * continued by substitution does not affect the value of &SYSECT for the expansion
 * of the current macro. However, it does affect &SYSECT for a subsequent macro
 * call. Nested macros cause the assembler to assign a value to &SYSECT that
 * depends on the control section in force inside the outer macro when the inner
 * macro is called.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The control section whose name is assigned to &SYSECT can be defined by a
 * program sectioning statement. This can be a START, CSECT, RSECT,
 * DSECT, or COM statement.
 * <LI>The value of the type attribute of &SYSECT (T.... &SYSECT) is always U.
 * <LI>The value of the count attribute (K.... &SYSECT) is equal to the number of
 * characters assigned as a value to &SYSECT.
 * <LI>Throughout the use of a macro definition, the value of &SYSECT is considered
 * a constant, independent of any program sectioning statements or inner macro
 * instructions in that definition.
 * </OL>
 * <P>
 * The next example shows these rules:
 * <PRE>
 *          MACRO
 *          INNER    &INCSECT
 * INCSECT  CSECT                        Statement 1
 *          DC       A(&SYSECT)          Statement 2
 *          MEND
 * 
 *          MACRO
 *          OUTER1
 * CSOUT1   CSECT                        Statement 3
 *          DS       1C
 *          INNER    INA                 Statement 4
 *          INNER    INB                 Statement 5
 *          DC       A(&SYSECT)          Statement 6
 *          MEND
 * 
 *          MACRO
 *          OUTER2
 *          DC       A(&SYSECT)          Statement 7
 *          MEND
 * --------------------------------------------------------
 * MAINPROG CSECT                        Statement 8
 *          DS       2C
 *          OUTER1                       Statement 9
 *          OUTER2                       Statement 1
 * --------------------------------------------------------
 * MAINPROG CSECT
 *          DS       2C
 * CSOUT1   CSECT
 *          DS       1C
 * INA      CSECT
 *          DC       A(CSOUT1)
 * INB      CSECT
 *          DC       A(INA)
 *          DC       A(MAINPROG)
 *          DC       A(INB)
 * </PRE>
 * <P>
 * In this example:
 * <UL>
 * <LI>Statement 8 is the last program sectioning statement processed before
 * statement 9 is processed. Therefore, &SYSECT is assigned the value
 * MAINPROG for macro instruction OUTER1 in statement 9. MAINPROG is substituted
 * for &SYSECT when it appears in statement 6.
 * <LI>Statement 3 is the program sectioning statement processed before statement 4
 * is processed. Therefore, &SYSECT is assigned the value CSOUT1 for macro
 * instruction INNER in statement 4. CSOUT1 is substituted for &SYSECT when it
 * appears in statement 2.
 * <LI>Statement 1 is used to generate a CSECT statement for statement 4. This is
 * the last program sectioning statement that appears before statement 5.
 * Therefore, &SYSECT is assigned the value INA for macro instruction INNER in
 * statement 5. INA is substituted for &SYSECT when it appears in statement 2.
 * <LI>Statement 1 is used to generate a CSECT statement for statement 5. This is
 * the last program sectioning statement that appears before statement 10.
 * Therefore, &SYSECT is assigned the value INB for macro instruction OUTER2 in
 * statement 10. INB is substituted for &SYSECT when it appears in statement 7.
 * </UL>
 */
property "&SYSECT";
/**
 * Use &SYSIN_DSN in a macro definition to obtain the name of the data set from
 * which the assembler is reading the source module.
 * <P>
 * If concatenated data sets are used to provide the source module,
 * SYSIN_DSN has a value equal to the data set name of the data set that contains
 * the open code source line of the macro call statement, irrespective of the nesting
 * depth of the macro line containing the &SYSIN_DSN reference.
 * <P>
 * The local system variable symbol &SYSIN_DSN is assigned a read-only value each
 * time a macro definition is called.
 * <P>
 * When the assembler runs on the MVS/ESA operating systems, the value of the
 * character string assigned to &SYSIN_DSN is always the value stored in the JFCB
 * for SYSIN.
 * <P>
 * When the assembler runs on the CMS component of the VM/ESA operating
 * systems, the value of the character string assigned to &SYSIN_DSN is determined
 * as follows:
 * <UL>
 * <LI><B>CMS file</B> --
 * The 8-character filename, the 8-character filetype, and the 2-character
 * filemode of the file, each separated by a blank
 * <LI><B>Reader</B> -- READER
 * <LI><B>Terminal</B> -- TERMINAL
 * <LI><B>Labeled tape file</B> -- The data set name of the tape file
 * <LI><B>Unlabeled tape file</B> -- TAP<VAR>n</VAR> , where <VAR>n</VAR>
 * is a value from 0 to 9, or A to F.
 * </UL>
 * <P>
 * When the assembler runs on the VSE operating system, the value of the character
 * string assigned to &SYSIN_DSN is determined as follows:
 * <UL>
 * <LI><B>Job stream (SYSIPT)</B> -- SYSIPT
 * <LI><B>Disk</B> -- The file-id
 * <LI><B>Labeled tape file</B> -- The file-id of the tape file
 * <LI><B>Unlabeled tape file</B> -- SYSIPT
 * </UL>
 * <P>
 * <B>Examples:</B>
 * <P>
 * On MVS, &SYSIN_DSN might be assigned a value such as:
 * <PRE>
 *    VCATR49.ASSEMBLE.SOURCE
 * </PRE>
 * <P>
 * On CMS, &SYSIN_DSN might be assigned a value such as:
 * <PRE>
 *    SAMPLE ASSEMBLE A1
 * </PRE>
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>If the SOURCE user exit provides the data set information then the value in
 * SYSIN_DSN is the value extracted from the Exit-Specific Information block
 * described in the High Level Assembler Programmer's Guide.
 * <LI>The value of the type attribute of &SYSIN_DSN (T.... &SYSIN_DSN) is always U.
 * <LI>The value of the count attribute of &SYSIN_DSN (K.... &SYSIN_DSN) is equal to
 * the number of characters assigned as a value to &SYSIN_DSN. In the CMS
 * example above, the count attribute of &SYSIN_DSN is 20.
 * <LI>Throughout the use of a macro definition, the value of &SYSIN_DSN is
 * considered a constant.
 * </OL>
 */
property "&SYSIN_DSN";
/**
 * On VSE, The value of &SYSIN_MEMBER is always null.
 * <P>
 * The value of the type attribute is O, and the value of the count attribute is 0.
 * <P>
 * You can use &SYSIN_MEMBER in a macro definition to obtain the
 * name of the data set member from which the assembler is reading the source
 * module. If concatenated data sets are used to provide the source module,
 * &SYSIN_MEMBER has a value equal to the name of the data set member that
 * contains the macro instruction that calls the definition.
 * <P>
 * The local system variable symbol &SYSIN_MEMBER is assigned a read-only value
 * each time a macro definition is called.
 * <P>
 * If the data set from which the assembler is reading the source module is not an
 * MVS partitioned data set or a CMS MACLIB, &SYSIN_MEMBER is assigned a null
 * character string.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>If the SOURCE user exit provides the data set information then the value in
 * SYSIN_MEMBER is the value extracted from the Exit-Specific Information
 * block described in the High Level Assembler Programmer's Guide.
 * <LI>The value of the type attribute of &SYSIN_MEMBER (T.... &SYSIN_MEMBER) is
 * U, unless &SYSIN_MEMBER is assigned a null character string, in which case
 * the value of the type attribute is O.
 * <LI>The value of the count attribute of &SYSIN_MEMBER (K.... &SYSIN_MEMBER)
 * is equal to the number of characters assigned as a value to
 * SYSIN_MEMBER. If &SYSIN_MEMBER is assigned a null character string,
 * the value of the count attribute is 0.
 * <LI>Throughout the use of a macro definition, the value of &SYSIN_MEMBER is
 * considered a constant.
 * </OL>
 */
property "&SYSIN_MEMBER";
/**
 * Use &SYSIN_VOLUME in a macro definition to obtain the volume identifier of the
 * first volume containing the data set from which the assembler is reading the source
 * module.
 * <P>
 * If concatenated data sets are used to provide the source module,
 * &SYSIN_VOLUME has a value equal to the volume identifier of the first volume
 * containing the data set that contains the macro call instruction.
 * <P>
 * The local system variable symbol &SYSIN_VOLUME is assigned a read-only value
 * each time a macro definition is called.
 * <P>
 * If the assembler runs on the CMS component of the VM/ESA operating system,
 * and the source module is being read from a Shared File System CMS file,
 * SYSIN_VOLUME is assigned the value SFS.
 * <P>
 * If the volume on which the input data set resides is not labeled, &SYSIN_VOLUME
 * is assigned a null character string.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>If the SOURCE user exit provides the data set information then the value in
 * SYSIN_VOLUME is the value extracted from the Exit-Specific Information
 * block described in the High Level Assembler Programmer's Guide.
 * <LI>The value of the type attribute of &SYSIN_VOLUME (T.... &SYSIN_VOLUME) is
 * U, unless &SYSIN_VOLUME is assigned a null character string, in which case
 * the value of the type attribute is O.
 * <LI>The value of the count attribute of &SYSIN_VOLUME (K.... &SYSIN_VOLUME) is
 * equal to the number of characters assigned as a value to &SYSIN_VOLUME. If
 * SYSIN_VOLUME is assigned a null character string, the value of the count
 * attribute is 0. The maximum length of this system variable symbol is 6.
 * <LI>Throughout the use of a macro definition, the value of &SYSIN_VOLUME is
 * considered a constant.
 * </OL>
 */
property "&SYSIN_VOLUME";
/**
 * Use &SYSJOB to obtain the jobname of the assembly job used to assemble your
 * source module. &SYSJOB has a global scope.
 * <P>
 * When the assembler runs on the CMS component of the VM/ESA operating
 * systems, &SYSJOB is assigned a value of (NOJOB).
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSJOB (T.... &SYSJOB) is always U.
 * <LI>The value of the count attribute (K.... &SYSJOB) is the number of characters
 * assigned.
 * </OL>
 */
property "&SYSJOB";
/**
 * Use &SYSLIB_DSN in a macro definition to obtain name of the data set from which
 * the assembler read the macro definition statements. If the macro definition is a
 * source macro definition, &SYSLIB_DSN is assigned the same value as
 * SYSIN_DSN.
 * <P>
 * The local system variable symbol &SYSLIB_DSN is assigned a read-only value
 * each time a macro definition is called.
 * <P>
 * When the assembler runs on the MVS/ESA operating systems, the value of the
 * character string assigned to &SYSLIB_DSN is always the value stored in the JFCB
 * for SYSLIB.
 * <P>
 * When the assembler runs on the CMS component of the VM/ESA operating
 * systems, and the macro definition is a library macro definition, &SYSLIB_DSN is
 * assigned the file name, file type, and file mode of the data set.
 * <P>
 * When the macro definition is a library macro definition, &SYSLIB_DSN is
 * assigned the library name and sublibrary name of the VSE Librarian file.
 * <P>
 * <B>Examples</B>
 * <P>
 * Under MVS, &SYSLIB_DSN might be assigned a value such as:
 * <PRE>
 *    SYS1.MACLIB
 * </PRE>
 * Under CMS, &SYSLIB_DSN might be assigned a value such as:
 * <PRE>
 *    DMSGPI MACLIB S2
 * </PRE>
 * Under VSE, &SYSLIB_DSN might be assigned a value such as:
 * <PRE>
 *    IJSYSRS.SYSLIB
 * </PRE>
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>If the LIBRARY user exit provides the data set information then the value in
 * SYSLIB_DSN is the value extracted from the Exit-Specific Information block
 * described in the High Level Assembler Programmer's Guide.
 * <LI>The value of the type attribute of &SYSLIB_DSN (T.... &SYSLIB_DSN) is always
 * U.
 * <LI>The value of the count attribute of &SYSLIB_DSN (K.... &SYSLIB_DSN) is equal
 * to the number of characters assigned as a value to &SYSLIB_DSN.
 * <LI>Throughout the use of a macro definition, the value of &SYSLIB_DSN is
 * considered a constant.
 * </OL>
 */
property "&SYSLIB_DSN";
/**
 * Use &SYSLIB_MEMBER in a macro definition to obtain the name of the data set
 * member from which the assembler read the macro definition statements. If the
 * macro definition is a source macro definition, &SYSLIB_MEMBER is assigned the
 * same value as &SYSIN_MEMBER.
 * <P>
 * The local system variable symbol &SYSLIB_MEMBER is assigned a read-only
 * value each time a macro definition is called.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>If the LIBRARY user exit provides the data set information then the value in
 * SYSLIB_MEMBER is the value extracted from the Exit-Specific Information
 * block described in the High Level Assembler Programmer's Guide.
 * <LI>The value of the type attribute of &SYSLIB_MEMBER (T.... &SYSLIB_MEMBER)
 * is U, unless &SYSLIB_MEMBER is assigned a null character string, in which
 * case the value of the type attribute is O.
 * <LI>The value of the count attribute of &SYSLIB_MEMBER
 * K.... &SYSLIB_MEMBER) is equal to the number of characters assigned as a
 * value to &SYSLIB_MEMBER. If &SYSLIB_MEMBER is assigned a null
 * character string, the value of the count attribute is 0.
 * <LI>Throughout the use of a macro definition, the value of &SYSLIB_MEMBER is
 * considered a constant.
 * </OL>
 */
property "&SYSLIB_MEMBER";
/**
 * Use &SYSLIB_VOLUME in a macro definition to obtain the volume identifier of the
 * volume containing the data set from which the assembler read the macro definition
 * statements. If the macro definition is a source macro definition,
 * SYSLIB_VOLUME is assigned the same value as &SYSIN_VOLUME.
 * <P>
 * The local system variable symbol &SYSLIB_VOLUME is assigned a read-only
 * value each time a macro definition is called.
 * <P>
 * If the assembler runs on the CMS component of the VM/ESA operating system,
 * and the source module is being read from a Shared File System CMS file,
 * SYSLIB_VOLUME is assigned the value ** SFS.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>If the LIBRARY user exit provides the data set information then the value in
 * SYSLIB_VOLUME is the value extracted from the Exit-Specific Information
 * block described in the High Level Assembler Programmer's Guide.
 * <LI>The value of the type attribute of &SYSLIB_VOLUME (T.... &SYSLIB_VOLUME)
 * is U, unless &SYSLIB_VOLUME is assigned a null character string, in which
 * case the value of the type attribute is O.
 * <LI>The value of the count attribute of &SYSLIB_VOLUME (K.... &SYSLIB_VOLUME)
 * is equal to the number of characters assigned as a value to
 * SYSLIB_VOLUME. If &SYSLIB_VOLUME is assigned a null character string,
 * the value of the count attribute is 0. The maximum length of this system
 * variable symbol is 6.
 * <LI>Throughout the use of a macro definition, the value of &SYSLIB_VOLUME is
 * considered a constant.
 * </OL>
 */
property "&SYSLIB_VOLUME";
/**
 * Use &SYSLIN_DSN in a macro definition to obtain the name of the data set to
 * which the assembler is writing the object records when assembler option OBJECT
 * or XOBJECT is specified.
 * <P>
 * The local system variable symbol &SYSLIN_DSN is assigned a read-only value
 * each time a macro definition is called.
 * <P>
 * The value of the character string assigned to &SYSLIN_DSN is always
 * the value stored in the JFCB for SYSLIN. If SYSLIN is allocated to DUMMY, or a
 * NULLFILE, the value in &SYSLIN_DSN is NULLFILE.
 * <P>
 * The value of the character string assigned to &SYSLIN_DSN is
 * determined as follows:
 * <UL>
 * <LI><B>CMS file</B> -- The 8-character filename, the
 * 8-character filetype, and the 2-character filemode of the file, each
 * separated by a blank
 * <LI><B>Dummy file (no physical I/O)</B> -- DUMMY
 * <LI><B>Punch</B> -- PUNCH
 * <LI><B>Labeled tape file</B> -- The data set name of the tape file
 * <LI><B>Unlabeled tape file</B> -- TAP<VAR>n</VAR> , where <VAR>n</VAR>
 * is a value from 0 to 9, or A to F.
 * </UL>
 * <P>
 * The value of the character string assigned to &SYSLIN_DSN is
 * determined as follows:
 * <UL>
 * <LI><B>Disk file</B> -- The file-id
 * <LI><B>Labeled tape file</B> -- The file-id of the tape file
 * <LI><B>Unlabeled tape file</B> -- SYSLNK
 * </UL>
 * <P>
 * <B>Examples:</B>
 * <P>
 * On MVS, &SYSLIN_DSN might be assigned a value such as:
 * <PRE>
 *    VCATR49.OBJ
 * </PRE>
 * On CMS, &SYSLIN_DSN might be assigned a value such as:
 * <PRE>
 *    SAMPLE TEXT A1
 * </PRE>
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>If the OBJECT user exit provides the data set information then the value in
 * SYSLIN_DSN is the value extracted from the Exit-Specific Information block
 * described in the High Level Assembler Programmer's Guide.
 * <LI>The value of the type attribute of &SYSLIN_DSN (T.... &SYSLIN_DSN) is always
 * U.
 * <LI>The value of the count attribute of &SYSLIN_DSN (K.... &SYSLIN_DSN) is equal
 * to the number of characters assigned as a value to &SYSLIN_DSN.
 * </OL>
 */
property "&SYSLIN_DSN";
/**
 * On VSE, The value of &SYSLIN_MEMBER is always null.
 * <P>
 * The value of the type attribute is O, and the value of the count attribute is 0.
 * You can use &SYSLIN_MEMBER in a macro definition to obtain the
 * name of the data set member to which the assembler is writing the object module
 * when the assembler option OBJECT or XOBJECT is specified.
 * <P>
 * The local system variable symbol &SYSLIN_MEMBER is assigned a read-only
 * value each time a macro definition is called.
 * <P>
 * If the library to which the assembler is writing the object records is not an MVS
 * partitioned data set, &SYSLIN_MEMBER is assigned a null character string.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>If the OBJECT user exit provides the data set information then the value in
 * SYSLIN_MEMBER is the value extracted from the Exit-Specific Information
 * block described in the High Level Assembler Programmer's Guide.
 * <LI>The value of the type attribute of &SYSLIN_MEMBER (T.... &SYSLIN_MEMBER)
 * is U, unless &SYSLIN_MEMBER is assigned a null character string, in which
 * case the value of the type attribute is O.
 * <LI>The value of the count attribute of &SYSLIN_MEMBER
 * K.... &SYSLIN_MEMBER) is equal to the number of characters assigned as a
 * value to &SYSLIN_MEMBER. If &SYSLIN_MEMBER is assigned a null
 * character string, the value of the count attribute is 0.
 * </OL>
 */
property "&SYSLIN_MEMBER";
/**
 * Use &SYSLIN_VOLUME in a macro definition to obtain the volume identifier of the
 * object data set. The volume identifier is of the first volume containing the data set.
 * SYSLIN_VOLUME is only assigned a value when you specify the OBJECT or
 * XOBJECT assembler option.
 * <P>
 * The local system variable symbol &SYSLIN_VOLUME is assigned a read-only
 * value each time a macro definition is called.
 * <P>
 * If the assembler runs on the CMS component of the VM/ESA operating system,
 * and the assembler listing is being written to a Shared File System CMS file,
 * SYSLIN_VOLUME is assigned the value SFS.
 * <P>
 * If the volume on which the data set resides is not labeled, &SYSLIN_VOLUME is
 * assigned a null character string.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>If the OBJECT user exit provides the data set information then the value in
 * SYSLIN_VOLUME is the value extracted from the Exit-Specific Information
 * block described in the High Level Assembler Programmer's Guide.
 * <LI>The value of the type attribute of &SYSLIN_VOLUME (T.... &SYSLIN_VOLUME)
 * is U, unless &SYSLIN_VOLUME is assigned a null character string, in which
 * case the value of the type attribute is O.
 * <LI>The value of the count attribute of &SYSLIN_VOLUME (K.... &SYSLIN_VOLUME)
 * is equal to the number of characters assigned as a value to
 * SYSLIN_VOLUME. If &SYSLIN_VOLUME is assigned a null character string,
 * the value of the count attribute is 0. The maximum length of this system
 * variable symbol is 6.
 * </OL>
 */
property "&SYSLIN_VOLUME";
/**
 * Use &SYSLIST instead of a positional parameter inside a macro definition; for
 * example, as a point of substitution. By varying the subscripts attached to
 * SYSLIST, you can refer to any sublist entry in a macro call, or any positional
 * operands in a macro call. You can also refer to positional operands for which no
 * corresponding positional parameter is specified in the macro prototype statement.
 * <P>
 * The local system variable symbol &SYSLIST is assigned a read-only value each
 * time a macro definition is called.
 * <P>
 * SYSLIST refers to the complete list of positional operands specified in a macro
 * instruction. &SYSLIST does not refer to keyword operands. However, &SYSLIST
 * cannot be specified as &SYSLIST alone. One of the two following forms must be
 * used as a point of substitution:
 * <OL>
 * <LI>&SYSLIST(n) can be used to refer to the n-th positional operand
 * <LI>If the n-th operand is a sublist, then &SYSLIST(n,m) can be used to refer to the
 * m-th operand in the sublist.
 * </OL>
 * The subscripts n and m can be any arithmetic expression allowed in the operand of
 * a SETA instruction (See SETA Instruction on page 314). The subscript n must
 * be greater than or equal to 0. The subscript m must be greater than or equal to 1.
 * <P>
 * When referring to multilevel (nested) sublists in operands of macro instructions,
 * refer to elements of inner sublists by using the applicable number of subscripts for
 * SYSLIST.
 * <P>
 * The examples below show the values assigned to &SYSLIST according to the
 * value of its subscripts n and m.
 * <PRE>
 * Macro instruction:
 * --------------------------------------------------------
 * NAME     MACALL         ONE,TWO,(3,(4,5,6),,8),,TEN
 *
 * Point of Substitution   Value
 * in Macro Definition:    Substituted:   See note:
 * --------------------    ------------   ---------
 * SYSLIST(2)              TWO
 * SYSLIST(3,1)            3
 * SYSLIST(3,2,2)          5
 * SYSLIST(4)              Null           1
 * SYSLIST(9)              Null           1
 * SYSLIST(3,3)            Null           2
 * SYSLIST(3,5)            Null           2
 * SYSLIST(2,1)            TWO            3
 * SYSLIST(2,2)            Null
 * SYSLIST()               NAME           4
 * SYSLIST(3)              (3,(4,5,6),,8)
 * </PRE>
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>If the position indicated by n refers to an omitted operand, or refers past the
 * end of the list of positional operands specified, the null character string is
 * substituted for &SYSLIST(n).
 * <LI>If the position (in a sublist) indicated by the second subscript, m, refers to an
 * omitted entry, or refers past the end of the list of entries specified in the sublist
 * referred to by the first subscript, n, the null character string is substituted for
 * SYSLIST(n,m).
 * <LI>If the n-th positional operand is not a sublist, &SYSLIST(n,1) refers to the
 * operand. However, &SYSLIST(n,m), where m is greater than 1, causes the
 * null character string to be substituted.
 * <LI>If the value of subscript n is 0, then &SYSLIST(n) is assigned the value
 * specified in the name field of the macro instruction, except when it is a
 * sequence symbol.
 * </OL>
 * <P>
 * Attribute references can be made to the previously described forms of &SYSLIST.
 * The attributes are the attributes inherent in the positional operands or sublist entries
 * to which you refer. However, the number attribute of &SYSLIST (N.... &SYSLIST) is
 * different from the number attribute described in Data Attributes on page 292.
 * One of two forms can be used for the number attribute:
 * <UL>
 * <LI>To indicate the number of positional operands specified in a call, use the form
 * N.... &SYSLIST.
 * <LI>To indicate the number of sublist entries that have been specified in a
 * positional operand, use the form N.... &SYSLIST(n).
 * </UL>
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>N.... &SYSLIST includes any positional operands that are omitted. Positional
 * operands are omitted by coding a comma where an operand is expected.
 * <LI>N.... &SYSLIST(n) includes those sublist entries specifically omitted by specifying
 * the comma that would normally have followed the entry.
 * <LI>If the operand indicated by n is not a sublist, N.... &SYSLIST(n) is 1. If it is
 * omitted, N.... &SYSLIST(n) is 0.
 * </OL>
 * <P>
 * The COMPAT(SYSLIST) assembler option instructs the assembler to treat sublists
 * in macro instruction operands as character strings, not sublists. See the High Level
 * Assembler Programmer's Guide for a description of the COMPAT(SYSLIST)
 * assembler option.
 * <P>
 * <B>Examples of sublists:</B>
 * <PRE>
 * Macro Instruction:          N'&SYSLIST
 * ------------------         ------------
 * MACLST   1,2,3,4                4
 * MACLST   A,B,,D,E               5
 * MACLST   ,A,B,C,D               5
 * MACLST   (A,B,C),(D,E,F)        2
 * MACLST
 * MACLST   KEY1=A,KEY2=B
 * MACLST   A,B,KEY1=C             2
 *
 *                             N'&SYSLIST(2)
 *                            ---------------
 * MACSUB   A,(1,2,3,4,5),B        5
 * MACSUB   A,(1,,3,,5),B          5
 * MACSUB   A,(,2,3,4,5),B         5
 * MACSUB   A,B,C                  1
 * MACSUB   A,,C                   0
 * MACSUB   A,KEY=(A,B,C)          0
 * MACSUB                          0
 * </PRE>
 */
property "&SYSLIST";
/**
 * Use &SYSLOC in a macro definition to generate the name of the location counter
 * in effect. If you have not coded a LOCTR instruction between the macro instruction
 * and the preceding START, CSECT, RSECT, DSECT, or COM instruction, the value
 * of &SYSLOC is the same as the value of &SYSECT.
 * <P>
 * The assembler assigns to the system variable symbol &SYSLOC a local read-only
 * value each time a macro definition containing it is called. The value assigned is the
 * symbol representing the name of the location counter in use at the point where the
 * macro is called.
 * <P>
 * SYSLOC can only be used in macro definitions.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSLOC (T.... &SYSLOC) is always U.
 * <LI>The value of the count attribute (K.... &SYSLOC) is equal to the number of
 * characters assigned as a value to &SYSLOC.
 * <LI>Throughout the use of a macro definition, the value of &SYSLOC is considered
 * a constant.
 * </OL>
 */
property "&SYSLOC";
/**
 * By varying the subscripts attached to the &SYSMAC you can refer to the name of
 * any of the macros called between opencode and the current nesting level, that is,
 * &SYSMAC(&SYSNEST) returns 'OPEN CODE'. Valid subscripts are 0 to
 * &SYSNEST. If &SYSMAC is used with a subscript greater than &SYSNEST, a null
 * character string is returned.
 * <P>
 * &SYSMAC with no subscript is treated as &SYSMAC(0) and so provides the name
 * of the macro being expanded. This is not considered to be an error and so no
 * message is issued.
 * The local system variable symbol &SYSMAC is assigned a read-only value each
 * time a macro definition is called.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSMAC (T.... &SYSMAC(n)) is U, unless
 * &SYSMAC(n) is assigned a null character string, in which case the value of the
 * type attribute is O.
 * <LI>The value of the count attribute (K.... &SYSMAC(n)) is equal to the number of
 * characters assigned as a value to &SYSMAC(n).
 * </OL>
 */
property "&SYSMAC";
/**
 * Use &SYSM_HSEV to get the highest MNOTE severity so far for the assembly.
 * <P>
 * The global system variable symbol &SYSM_HSEV is assigned a read-only value.
 * The assembler compares this value with the severity of MNOTE assembler
 * instructions as they are encountered and, if lower, updates it with the higher value.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSM_HSEV (T.... &SYSM_HSEV) is always N.
 * <LI>The value of the count attribute (K.... &SYSM_HSEV) is always 3.
 * </OL>
 * In Figure 60 on page 251 the &SYSM_HSEV variable is updated immediately an
 * MNOTE is issued with a higher severity.
 */
property "&SYSM_HSEV";
/**
 * Use &SYSM_SEV to get the highest MNOTE severity code for the macro most
 * recently called directly from this level.
 * <P>
 * The global system variable symbol &SYSM_SEV is assigned a read-only value.
 * The assembler assigns a value of zero when a macro is called and when a macro
 * returns (MEND or MEXIT), the highest severity of all MNOTE assembler
 * instructions executed in the called macro is used to update the variable.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSM_SEV (T.... &SYSM_SEV) is always N.
 * <LI>The value of the count attribute (K.... &SYSM_SEV) is always 3.
 * </OL>
 * In Figure 60 the &SYSM_SEV variable has a value of 0 until INNER returns. The
 * OUTER macro uses &SYSM_SEV to determine which statements to generate, and
 * in this case issues an MNOTE to pass the severity back to the open code.
 * <P>
 * Figure 60. Example of the behavior of the &SYSM_HSEV and &SYSM_SEV variables.
 * <PRE>
 *                                    1         MACRO
 *                                    2         OUTER    &SEV
 *                                    3         DC       A(&SYSM_HSEV,&SYSM_SEV)             outer 1
 *                                    4         MNOTE    &SEV,'OUTER - parm severity=&SEV'
 *                                    5         DC       A(&SYSM_HSEV,&SYSM_SEV)             outer 2
 *                                    6         INNER    
 *                                    7         DC       A(&SYSM_HSEV,&SYSM_SEV)             outer 3
 *                                    8         AIF      ('&SEV'GT '&SYSM_SEV').MN
 *                                    9         MNOTE    &SYSM_SEV,'OUTER -returned severity=&SYSM_SEV'
 *                                    10 .MN    ANOP     
 *                                    11        DC       A(&SYSM_HSEV,&SYSM_SEV)             outer 4
 *                                    12        MEND     
 *                                    13        MACRO    
 *                                    14        INNER    
 *                                    15        DC       A(&SYSM_HSEV,&SYSM_SEV)             inner 1
 *                                    16        MNOTE    8,'INNER'
 *                                    17        DC       A(&SYSM_HSEV,&SYSM_SEV)             inner 2
 *                                    18        MEND     
 * 000000                00000 00040  19 E_G    CSECT    
 *                                    20 *,OPEN CODE     an mnote comment -sev=
 *                                    21        DC       A(&SYSM_HSEV,&SYSM_SEV)             open_code
 * 000000 0000000000000000              +       DC       A(,)                                open_code
 *                                    22        OUTER    4
 * 000008 0000000000000000            23+       DC       A(,)                                outer 1
 * ** ASMA254I *** MNOTE ***          24+                4,OUTER -parm severity=4
 * 000010 0000000400000000            25+       DC       A(4,)                               outer 2
 * 000018 0000000400000000            26+       DC       A(4,)                               inner 1
 * ** ASMA254I *** MNOTE ***          27+                8,INNER
 * 000020 0000000800000000            28+       DC       A(8,)                               inner 2
 * 000028 0000000800000008            29+       DC       A(8,8)                              outer 3
 * ** ASMA254I *** MNOTE 3 ***          +                008,OUTER -returned severity=8
 * 000030 0000000800000008            31+       DC       A(8,8)                              outer 4
 *                                    32                 ,OPEN CODE an mnote comment -sev=
 *                                    33        DC       A(&SYSM_HSEV,&SYSM_SEV)             open_code
 * 000038 0000000800000008              +       DC       A(8,8)                              open_code
 *                                    34        END      
 * </PRE>
 */
property "&SYSM_SEV";
/**
 * You can attach &SYSNDX to the end of a symbol inside a macro definition to
 * generate a unique suffix for that symbol each time you call the definition. Although
 * the same symbol is generated by two or more calls to the same definition, the suffix
 * provided by &SYSNDX produces two or more unique symbols. Thus you avoid an
 * error being flagged for multiply defined symbols.
 * <P>
 * The local system variable symbol &SYSNDX is assigned a read-only value each
 * time a macro definition is called from a source module.
 * <P>
 * The value assigned to &SYSNDX is a number from 1 to 9999999. For the
 * numbers 0001 through 9999, four digits are generated. For the numbers 10000
 * through 9999999, the value is generated with no zeros to the left. The value 0001
 * is assigned to the first macro called by a program, and is incremented by one for
 * each subsequent macro call (including nested macro calls).
 * <P>
 * The maximum value for &SYSNDX can be controlled by the MHELP instruction
 * described under MHELP Control on &SYSNDX on page 350.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>&SYSNDX does not generate a valid symbol, and it must:
 * Follow the symbol to which it is concatenated
 * Be concatenated to a symbol containing 59 characters or less
 * <LI>The value of the type attribute of &SYSNDX (T.... &SYSNDX) is always N.
 * <LI>The value of the count attribute (K.... &SYSNDX) is equal to the number of digits
 * generated.
 * </OL>
 * The example that follows, shows the use of &SYSNDX. It is assumed that the first
 * macro instruction processed, OUTER1 , is the 106th macro instruction processed by
 * the assembler.
 * <PRE>
 *          MACRO
 *          INNER1
 *          GBLC     &NDXNUM
 * A&SYSNDX SR       2,5            Statement 1
 *          CR       2,5
 *          BE       B&NDXNUM       Statement 2
 *          B        A&SYSNDX       Statement 3
 *          MEND
 *
 *          MACRO
 * &NAME    OUTER1
 *          GBLC     &NDXNUM
 * &NDXNUM  SETC     '&SYSNDX'      Statement 4
 * &NAME    SR       2,4
 *          AR       2,6
 *          INNER1                  Statement 5
 * B&SYSNDX S        2,=F'1 '       Statement 6
 *          MEND
 * --------------------------------------------------------
 * ALPHA OUTER1 Statement 7
 * BETA OUTER1 Statement 8
 * --------------------------------------------------------
 * ALPHA    SR       2,4
 *          AR       2,6
 * A0107    SR       2,5
 *          CR       2,5
 *          BE       B0106
 *          B        A0107
 * B0106    S        2,=F'1000'
 * BETA     SR       2,4
 *          AR       2,6
 * A0109    SR       2,5
 *          CR       2,5
 *          BE       B0108
 *          B        A0109
 * B0108    S        2,=F'1000'
 * </PRE>
 * <P>
 * Statement 7 is the 106th macro instruction processed. Therefore, &SYSNDX is
 * assigned the number 0106 for that macro instruction. The number 0106 is
 * substituted for &SYSNDX when it is used in statements 4 and 6. Statement 4 is
 * used to assign the character value 0106 to the SETC symbol &NDXNUM Statement 6
 * is used to create the unique name B0106.
 * <P>
 * Statement 5 is the 107th macro instruction processed. Therefore, &SYSNDX is
 * assigned the number 0107 for that macro instruction. The number 0107 is
 * substituted for &SYSNDX when it is used in statements 1 and 3. The number 0106
 * is substituted for the global SETC symbol &NDXNUM in statement 2.
 * <P>
 * Statement 8 is the 108th macro instruction processed. Therefore, each occurrence
 * of &SYSNDX is replaced by the number 0108 . For example, statement 6 is used to
 * create the unique name B0108.
 * <P>
 * When statement 5 is used to process the 108th macro instruction, statement 5
 * becomes the 109th macro instruction processed. Therefore, each occurrence of
 * SYSNDX is replaced by the number 0109 . For example, statement 1 is used to
 * create the unique name A0109.
 */
property "&SYSNDX";
/**
 * Use &SYSNEST to obtain the current macro instruction nesting level.
 * <P>
 * The local system variable symbol &SYSNEST is assigned a read-only value each
 * time a macro definition is called from a source module.
 * <P>
 * The value assigned to &SYSNEST is a number from 1 to 99999999. No leading
 * zeros are generated as part of the number. When a macro is called from open
 * code, the value assigned to &SYSNEST is the number 1. Each time a macro
 * definition is called by an inner macro instruction, the value assigned to &SYSNEXT
 * is incremented by 1. Each time an inner macro exits, the value is decremented by
 * 1.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSNEST (T.... &SYSNEST) is always N.
 * <LI>The value of the count attribute (K.... &SYSNEST) is equal to the number of digits
 * assigned.
 * </OL>
 * The following example shows the values assigned to &SYSNEST:
 * <PRE>
 *          MACRO
 *          OUTER
 *          DC       A(&SYSNEST)    Statement 1
 *          INNER1                  Statement 2
 *          INNER2                  Statement 3
 *          MEND
 *
 *          MACRO
 *          INNER1
 *          DC       A(&SYSNEST)    Statement 4
 *          INNER2                  Statement 5
 *          MEND
 *
 *          MACRO
 *          INNER2
 *          DC       A(&SYSNEST)    Statement 6
 *          MEND
 * --------------------------------------------------------
 *          OUTER                   Statement 7
 *          DC       A(1)
 *          DC       A(2)
 *          DC       A(3)
 *          DC       A(2)
 * <PRE>
 * Statement 7 is in open code. It calls the macro OUTER . &SYSNEST is assigned a
 * value of 1 which is substituted in statement 1.
 * <P>
 * Statement 2, within the macro definition of OUTER , calls macro INNER1 . The value
 * assigned to &SYSNEST is incremented by 1. The value 2 is substituted for
 * SYSNEST in statement 4.
 * <P>
 * Statement 5, within the macro definition of INNER1 , calls macro INNER2 . The value
 * assigned to &SYSNEST is incremented by 1. The value 3 is substituted for
 * SYSNEST in statement 6.
 * <P>
 * When the macro INNER2 exits, the value assigned to &SYSNEST is decremented by
 * <LI>The value of &SYNEST is 2.
 * <P>
 * When the macro INNER1 exits, the value assigned to &SYSNEST is decremented by
 * <LI>The value of &SYSNEST is 1.
 * <P>
 * Statement 3, within the macro definition of OUTER , calls macro INNER2 . The value
 * assigned to &SYSNEST is incremented by 1. The value 2 is substituted for
 * SYSNEST in statement 6.
 */
property "&SYSNEST";
/**
 * You can use &SYSOPT_DBCS to determine if the DBCS assembler option was
 * supplied for the assembly of your source module. &SYSOPT_DBCS is a Boolean
 * system variable symbol, and has a global scope.
 * <P>
 * If the DBCS assembler option was specified, &SYSOPT_DBCS is assigned a value
 * of 1. If the DBCS assembler option was not specified, &SYSOPT_DBCS is
 * assigned a value of 0.
 * <P>
 * For more information about the DBCS assembler option, see the High Level
 * Assembler Programmer's Guide.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSOPT_DBCS (T.... &SYSOPT_DBCS) is
 * always N.
 * <LI>The value of the count attribute (K.... &SYSOPT_DBCS) is always 1.
 * </OL>
 */
property "&SYSOPT_DBCS";
/**
 * Use &SYSOPT_OPTABLE to determine the value that was specified for the
 * OPTABLE assembler option. &SYSOPT_OPTABLE has a global scope.
 * <P>
 * The value that was specified for the OPTABLE assembler option indicates which
 * operation code table the assembler has loaded, and is using.
 * <P>
 * For more information about the OPTABLE assembler option, see your High Level
 * Assembler Programmer's Guide.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSOPT_OPTABLE
 * T.... &SYSOPT_OPTABLE) is always U.
 * <LI>The value of the count attribute (K.... &SYSOPT_OPTABLE) is the number of
 * characters assigned.
 * </OL>
 */
property "&SYSOPT_OPTABLE";
/**
 * Use &SYSOPT_RENT to determine if the RENT assembler option was specified for
 * the assembly of your source module. The RENT option instructs the assembler to
 * check for possible coding violations of program reenterability. &SYSOPT_RENT is
 * a Boolean system variable symbol, and has a global scope.
 * <P>
 * If the RENT assembler option was specified, &SYSOPT_RENT is assigned a value
 * of 1. If the RENT assembler option was not specified, &SYSOPT_RENT is
 * assigned a value of 0.
 * <P>
 * For more information about the RENT assembler option, see your High Level
 * Assembler Programmer's Guide.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSOPT_RENT (T.... &SYSOPT_RENT) is
 * always N.
 * <LI>The value of the count attribute (K.... &SYSOPT_RENT) is always 1.
 * </OL>
 */
property "&SYSOPT_RENT";
/**
 * The &SYSOPT_XOBJECT system variable is set to 1 if XOBJECT is specified,
 * otherwise it is set to 0.
 * <P>
 * &SYSOPT_XOBJECT is a Boolean system variable symbol with global scope.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSOPT_XOBJECT
 * T.... &SYSOPT_XOBJECT) is always N.
 * <LI>The value of the count attribute (K.... &SYSOPT_XOBJECT) is always 1.
 * </OL>
 */
property "&SYSOPT_XOBJECT";
/**
 * Use &SYSPARM to communicate with an assembler source module through job
 * control language (JCL). Through &SYSPARM, you pass a character string into the
 * source module to be assembled from a JCL statement, or from a program that
 * dynamically calls the assembler. Thus, you can set a character value from outside
 * a source module and then examine it as part of the source module during
 * conditional assembly processing.
 * <P>
 * The global system variable symbol &SYSPARM is assigned a read-only value in a
 * JCL statement or in a field set up by a program that dynamically calls the
 * assembler. It is treated as a global SETC symbol in a source module except that
 * its value cannot be changed.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The largest value that &SYSPARM can hold is 255 characters. However, if the
 * PARM field of the EXEC statement is used to specify its value, the PARM field
 * restrictions reduce its maximum possible length.
 * <LI>No values are substituted for variable symbols in the specified value, however,
 * on MVS and VSE, you must use double ampersands to represent a single
 * ampersand.
 * <LI>On MVS and VSE, you must use two single quotation marks to represent a
 * single quotation mark, because the entire EXEC PARM field is enclosed in
 * single quotation marks.
 * <LI>If the SYSPARM assembler option is not specified, &SYSPARM is assigned the
 * default value that was specified when the assembler was installed on your
 * system.
 * <P>
 * If a default value for SYSPARM was not specified when the assembler was
 * installed on your system, &SYSPARM is assigned a value of the null character
 * string.
 * <LI>The value of the type attribute of &SYSPARM (T.... &SYSPARM) is U, unless
 * SYSPARM is assigned a null value, in which case the value of the type
 * attribute is O.
 * <LI>The value of the count attribute (K.... &SYSPARM) is the number of characters
 * assigned as a value to &SYSPARM. If &SYSPARM is assigned a null character
 * string, the value of the count attribute is 0.
 * </OL>
 */
property "&SYSPARM";
/**
 * Use &SYSPRINT_DSN in a macro definition to obtain the name of the data set to
 * which the assembler writes the assembler listing.
 * <P>
 * The local system variable symbol &SYSPRINT_DSN is assigned a read-only value
 * each time a macro definition is called.
 * <P>
 * When the assembler runs on the MVS/ESA operating systems, the value of the
 * character string assigned to &SYSPRINT_DSN is always the value stored in the
 * JFCB for SYSPRINT. If SYSPRINT is allocated to DUMMY, or a NULLFILE, the
 * value in &SYSPRINT_DSN is NULLFILE.
 * <P>
 * When the assembler runs on the CMS component of the VM/ESA operating
 * systems, the value of the character string assigned to &SYSPRINT_DSN is
 * determined as follows:
 * <UL>
 * <LI><B>CMS file</B> -- The 8-character filename, the
 * 8-character filetype, and the 2-character filemode of the file, each
 * separated by a blank
 * <LI><B>Dummy file (no physical I/O)</B> -- DUMMY
 * <LI><B>Printer</B> -- PRINTER
 * <LI><B>Labeled tape file</B> -- The data set name of the tape file
 * Unlabeled tape file TAP n , where n is a value from 0 to 9,
 * or A to F.
 * <LI><B>Terminal</B> -- TERMINAL
 * </UL>
 * <P>
 * When the assembler runs on VSE, the value of the character string assigned to
 * &SYSPRINT_DSN is determined as follows:
 * <UL>
 * <LI><B>Disk file (not for dynamic partitions)</B> -- The file-id
 * <LI><B>Printer</B> -- SYSLST
 * <LI><B>Labeled tape file</B> -- The file-id of the tape file
 * <LI><B>Unlabeled tape file</B> -- SYSLST
 * </UL>
 * Examples:
 * On MVS, &SYSPRINT_DSN might be assigned a value such as:
 * <PRE>
 *    VCATR49.VCATR49A.JOB 6734.D 1 2.?
 * </PRE>
 * On CMS, &SYSPRINT_DSN might be assigned a value such as:
 * <PRE>
 *    SAMPLE LISTING A1
 * </PRE>
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>If the LISTING user exit provides the listing data set information then the value
 * in &SYSPRINT_DSN is the value extracted from the Exit-Specific Information
 * block described in the High Level Assembler Programmer's Guide.
 * <LI>The value of the type attribute of &SYSPRINT_DSN (T.... &SYSPRINT_DSN) is
 * always U.
 * <LI>The value of the count attribute of &SYSPRINT_DSN (K.... &SYSPRINT_DSN) is
 * equal to the number of characters assigned as a value to &SYSPRINT_DSN.
 * </OL>
 */
property "&SYSPRINT_DSN";
/**
 * On VSE, The value of &SYSPRINT_MEMBER is always null.
 * <P>
 * The value of the type attribute is O, and the value of the count attribute is 0.
 * <P>
 * You can use &SYSPRINT_MEMBER in a macro definition to obtain
 * the name of the data set member to which the assembler is writing the assembler
 * listing.
 * <P>
 * The local system variable symbol &SYSPRINT_MEMBER is assigned a read-only
 * value each time a macro definition is called.
 * <P>
 * If the data set to which the assembler is writing the assembler listing is not an MVS
 * partitioned data set, &SYSPRINT_MEMBER is assigned a null character string.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>If the LISTING user exit provides the listing data set information then the value
 * in &SYSPRINT_MEMBER is the value extracted from the Exit-Specific
 * Information block described in the High Level Assembler Programmer's Guide.
 * <LI>The value of the type attribute of &SYSPRINT_MEMBER
 * T.... &SYSPRINT_MEMBER) is U, unless &SYSPRINT_MEMBER is assigned a
 * null character string, in which case the value of the type attribute is O.
 * <LI>The value of the count attribute of &SYSPRINT_MEMBER
 * K.... &SYSPRINT_MEMBER) is equal to the number of characters assigned as a
 * value to &SYSPRINT_MEMBER. If &SYSPRINT_MEMBER is assigned a null
 * character string, the value of the count attribute is 0.
 * </P>
 */
property "&SYSPRINT_MEMBER";
/**
 * Use &SYSPRINT_VOLUME in a macro definition to obtain the volume identifier of
 * the first volume containing the data set to which the assembler writes the
 * assembler listing.
 * <P>
 * The local system variable symbol &SYSPRINT_VOLUME is assigned a read-only
 * value each time a macro definition is called.
 * <P>
 * If the assembler runs on the CMS component of the VM/ESA operating system,
 * and the assembler listing writes to a Shared File System CMS file,
 * SYSPRINT_VOLUME is assigned the value SFS.
 * <P>
 * If the volume on which the data set resides is not labeled, &SYSPRINT_VOLUME
 * is assigned a null character string.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>If the LISTING user exit provides the listing data set information then the value
 * in &SYSPRINT_VOLUME is the value extracted from the Exit-Specific
 * Information block described in the High Level Assembler Programmer's Guide.
 * <LI>The value of the type attribute of &SYSPRINT_VOLUME
 * T.... &SYSPRINT_VOLUME) is U, unless &SYSPRINT_VOLUME is assigned a
 * null character string, in which case the value of the type attribute is O.
 * <LI>The value of the count attribute of &SYSPRINT_VOLUME
 * K.... &SYSPRINT_VOLUME) is equal to the number of characters assigned as a
 * value to &SYSPRINT_VOLUME. If &SYSPRINT_VOLUME is assigned a null
 * character string, the value of the count attribute is 0. The maximum length of
 * this system variable symbol is 6.
 * </OL>
 */
property "&SYSPRINT_VOLUME";
/**
 * Use &SYSPUNCH_DSN in a macro definition to obtain the name of the data set to
 * which the assembler is writing the object records when assembler option DECK is
 * specified.
 * <P>
 * The local system variable symbol &SYSPUNCH_DSN is assigned a read-only value
 * each time a macro definition is called.
 * <P>
 * When the assembler runs on the MVS/ESA operating systems, the value of the
 * character string assigned to &SYSPUNCH_DSN is always the value stored in the
 * JFCB for SYSPUNCH. If SYSPUNCH is allocated to DUMMY, or a NULLFILE, the
 * value in &SYSPUNCH_DSN is NULLFILE.
 * <P>
 * When the assembler runs on the CMS component of the VM/ESA operating
 * systems, the value of the character string assigned to &SYSPUNCH_DSN is
 * determined as follows:
 * <UL>
 * <LI><B>CMS file</B> -- The 8-character filename, the 8-character filetype, and the
 * 2-character filemode of the file, each separated by a blank
 * <LI><B>Dummy file (no physical I/O)</B> -- DUMMY
 * <LI><B>Punch</B> -- PUNCH
 * <LI><B>Labeled tape file</B> -- The data set name of the tape file
 * <LI><B>Unlabeled tape file</B> -- TAP<VAR>n</VAR> , where <VAR>n</VAR>
 * is a value from 0 to 9, or A to F.
 * </UL>
 * On VSE, the value of the character string assigned to &SYSPUNCH_DSN is
 * determined as follows:
 * <UL>
 * <LI><B>Disk file</B> -- The file-id
 * <LI><B>Punch</B> -- SYSPCH
 * <LI><B>Labeled tape file</B> -- The file-id of the tape file
 * <LI><B>Unlabeled tape file</B> -- SYSPCH
 * </UL>
 * <P>
 * <B>Examples:</B>
 * <P>
 * On MVS, &SYSPUNCH_DSN might be assigned a value such as:
 * <PRE>
 *    VCATR49.VCATR49A.JOB 6734.D 1 3.?
 * </PRE>
 * On CMS, &SYSPUNCH_DSN might be assigned a value such as:
 * <PRE>
 *    PUNCH
 * </PRE>
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>If the PUNCH user exit provides the punch data set information then the value
 * in &SYSPUNCH_DSN is the value extracted from the Exit-Specific Information
 * block described in the High Level Assembler Programmer's Guide.
 * <LI>The value of the type attribute of &SYSPUNCH_DSN (T.... &SYSPUNCH_DSN)
 * is always U.
 * <LI>The value of the count attribute of &SYSPUNCH_DSN (K.... &SYSPUNCH_DSN)
 * is equal to the number of characters assigned as a value to SYSPUNCH_DSN.
 * </OL>
 */
property "&SYSPUNCH_DSN";
/**
 * On VSE, the value of &SYSPUNCH_MEMBER is always null.
 * <P>
 * The value of the type attribute is O, and the value of the count attribute is 0.
 * <P>
 * You can use &SYSPUNCH_MEMBER in a macro definition to obtain
 * the name of the data set member to which the assembler is writing the object
 * records when the assembler option DECK is specified.
 * <P>
 * The local system variable symbol &SYSPUNCH_MEMBER is assigned a read-only
 * value each time a macro definition is called.
 * <P>
 * If the data set to which the assembler is writing the object records is not an MVS
 * partitioned data set, &SYSPUNCH_MEMBER is assigned a null character string.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>If the PUNCH user exit provides the punch data set information then the value
 * in &SYSPUNCH_MEMBER is the value extracted from the Exit-Specific
 * Information block described in the High Level Assembler Programmer's Guide.
 * <LI>The value of the type attribute of &SYSPUNCH_MEMBER
 * T.... &SYSPUNCH_MEMBER) is U, unless &SYSPUNCH_MEMBER is assigned
 * a null character string, in which case the value of the type attribute is O.
 * <LI>The value of the count attribute of &SYSPUNCH_MEMBER
 * K.... &SYSPUNCH_MEMBER) is equal to the number of characters assigned as
 * a value to &SYSPUNCH_MEMBER. If &SYSPUNCH_MEMBER is assigned a
 * null character string, the value of the count attribute is 0.
 * </OL>
 */
property "&SYSPUNCH_MEMBER";
/**
 * Use &SYSPUNCH_VOLUME in a macro definition to obtain the volume identifier of
 * the object data set. The volume identifier is of the first volume containing the data
 * set. &SYSPUNCH_VOLUME is only assigned a value when you specify the DECK
 * assembler option.
 * <P>
 * The local system variable symbol &SYSPUNCH_VOLUME is assigned a read-only
 * value each time a macro definition is called.
 * <P>
 * If the assembler runs on the CMS component of the VM/ESA operating system,
 * and the object records are being written to a Shared File System CMS file,
 * SYSPUNCH_VOLUME is assigned the value SFS.
 * <P>
 * If the volume on which the data set resides is not labeled, &SYSPUNCH_VOLUME
 * is assigned a null character string.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>If the PUNCH user exit provides the punch data set information then the value
 * in &SYSPUNCH_VOLUME is the value extracted from the Exit-Specific
 * Information block described in the High Level Assembler Programmer's Guide.
 * <LI>The value of the type attribute of &SYSPUNCH_VOLUME
 * T.... &SYSPUNCH_VOLUME) is U, unless &SYSPUNCH_VOLUME is assigned
 * a null character string, in which case the value of the type attribute is O.
 * <LI>The value of the count attribute of &SYSPUNCH_VOLUME
 * K.... &SYSPUNCH_VOLUME) is equal to the number of characters assigned as
 * a value to &SYSPUNCH_VOLUME. If &SYSPUNCH_VOLUME is assigned a
 * null character string, the value of the count attribute is 0. The maximum length
 * of this system variable symbol is 6.
 * </OL>
 */
property "&SYSPUNCH_VOLUME";
/**
 * Use &SYSSEQF in a macro definition to obtain the value of the
 * identification-sequence field of the macro instruction in open code that caused,
 * directly or indirectly, the macro to be called.
 * <P>
 * The local system variable symbol &SYSSEQF is assigned a read-only value each
 * time a macro definition is called from a source module.
 * <P>
 * The value assigned to &SYSSEQF is determined as follows:
 * <OL>
 * <LI>If no ICTL instruction has been specified and sequence checking is not active,
 * the contents of columns 73 to 80 inclusive of the source statement are
 * assigned to &SYSSEQF.
 * <LI>If an ICTL instruction has been specified, but sequence checking is not active,
 * the contents of the columns of the source statement to the right of the
 * continuation-indicator column are assigned to &SYSSEQF. If the end column or
 * the continuation-indicator column is 80, &SYSSEQF is assigned a null
 * character string.
 * <LI>If an ISEQ instruction with operands has been specified to start sequence
 * checking, the contents of columns specified in the ISEQ instruction operand are
 * assigned to &SYSSEQF.
 * <LI>If an ISEQ instruction without an operand has been specified to end sequence
 * checking, steps (1) and (2) are used to determine the value assigned to
 * SYSSEQF.
 * </OL>
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSSEQF (T.... &SYSSEQF) is U, unless
 * SYSSEQF is assigned a null character string, in which case the value of the
 * type attribute is O.
 * <LI>The value of the count attribute of &SYSSEQF (K.... &SYSSEQF) is equal to the
 * number of characters assigned as a value to &SYSSEQF. If &SYSSEQF is
 * assigned a null character string, the value of the count attribute is 0.
 * <LI>Throughout the use of a macro definition, the value of &SYSSEQF is
 * considered a constant.
 * </OL>
 */
property "&SYSSEQF";
/**
 * Use &SYSSTEP to obtain the stepname of the job step used to assemble your
 * source module. &SYSSTEP has a global scope.
 * <P>
 * On VSE the value of &SYSSTEP is always (NOSTEP).
 * <P>
 * On CMS, &SYSSTEP is assigned a value of (NOSTEP).
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSSTEP (T.... &SYSSTEP) is always U.
 * <LI>The value of the count attribute (K.... &SYSSTEP) is the number of characters
 * assigned.
 * </P>
 */
property "&SYSSTEP";
/**
 * Use &SYSSTMT to obtain the next statement number that is assigned to a
 * statement by the assembler. &SYSSTMT has a global scope.
 * <P>
 * The value assigned to &SYSSTMT is an 8-character string, padded on the left with
 * leading zeros. The following example shows the value assigned to &SYSSTMT. It
 * assumes that the DC statement is in open code, and is the 23rd statement in the
 * source module.
 * <PRE>
 *    23 DCC '&SYSSTMT'
 *    DCC '24'
 * </PRE>
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSSTMT (T.... &SYSSTMT) is always N.
 * <LI>The value of the count attribute of &SYSSTMT (K.... &SYSSTMT) is always 8.
 * </OL>
 */
property "&SYSSTMT";
/**
 * Use &SYSSTYP in a macro definition to generate the type of the current control
 * section. The current control section is the control section in which the macro
 * instruction that calls the definition appears.
 * <P>
 * The local system variable symbol &SYSSTYP is assigned a read-only value each
 * time a macro definition is called.
 * <P>
 * The value assigned is the symbol that represents the type of the current control
 * section in effect when the macro is called. A control section that has been initiated
 * or continued by substitution does not affect the value of &SYSSTYP for the
 * expansion of the current macro. However, it does affect &SYSSTYP for a
 * subsequent macro call. Nested macros cause the assembler to assign a value to
 * SYSSTYP that depends on the control section in force inside the calling macro
 * when the inner macro is called.
 * <P>
 * The control section whose type is assigned to &SYSSTYP can be defined by a
 * program sectioning statement. This can be a START, CSECT, RSECT, DSECT, or
 * COM statement, or, for the first control section, any instruction described in First
 * Control Section on page 52. Depending upon the instruction used to initiate the
 * current control section, the value assigned to &SYSSTYP is either CSECT, RSECT,
 * DSECT, or COM. If the current control section is an executable control section
 * initiated by other than a CSECT or RSECT instruction, the value assigned to
 * SYSSTYP is CSECT.
 * <P>
 * If a control section has not been initiated, &SYSSTYP is assigned a null character
 * string.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSSTYP (T.... &SYSSTYP) is U, unless
 * SYSSTYP is assigned a null character string, in which case the value of the
 * type attribute is O.
 * <LI>The value of the count attribute of &SYSSTYP (K.... &SYSSTYP) is equal to the
 * number of characters assigned as a value to &SYSSTYP. If &SYSSTYP is
 * assigned a null character string, the value of the count attribute is 0.
 * <LI>Throughout the use of a macro definition, the value of &SYSSTYP is
 * considered a constant.
 * </OL>
 */
property "&SYSSTYP";
/**
 * Use &SYSTEM_ID to obtain the name and release of the operating system under
 * which your source module is being assembled. &SYSTEM_ID has a global scope.
 * <P>
 * For example, on MVS, &SYSTEM_ID might contain one of the following:
 * <PRE>
 *    MVS/ESA SP 4.3.
 *    MVS/ESA SP 5.1.
 *    etc.
 * </PRE>
 * on CMS, &SYSTEM_ID might contain one of the following:
 * <PRE>
 *    CMS 7
 *    CMS 9
 *    CMS 11
 *    etc.
 * </PRE>
 * on VSE, &SYSTEM_ID might contain one of the following:
 * <PRE>
 *    VSE/AF 5.1.2
 *    VSE/AF 6.1.
 *    etc.
 * </PRE>
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSTEM_ID (T.... &SYSTEM_ID) is always U.
 * <LI>The value of the count attribute (K.... &SYSTEM_ID) is the number of characters
 * assigned.
 * </OL>
 */
property "&SYSTEM_ID";
/**
 * Use &SYSTERM_DSN in a macro definition to obtain the name of the data set to
 * which the assembler is writing the terminal records.
 * <P>
 * The local system variable symbol &SYSTERM_DSN is assigned a read-only value
 * each time a macro definition is called.
 * <P>
 * When the assembler runs on the MVS/ESA operating systems, the value of the
 * character string assigned to &SYSTERM_DSN is always the value stored in the
 * JFCB for SYSTERM. If SYSTERM is allocated to DUMMY, or a NULLFILE, the
 * value in &SYSTERM_DSN is NULLFILE.
 * <P>
 * When the assembler runs on the CMS component of the VM/ESA operating
 * systems, the value of the character string assigned to &SYSTERM_DSN is
 * determined as follows:
 * <UL>
 * <LI><B>CMS file</B> -- The 8-character filename, the
 * 8-character filetype, and the 2-character filemode of the file, each
 * separated by a blank
 * <LI><B>Dummy file (no physical I/O)</B> -- DUMMY
 * <LI><B>Printer</B> -- PRINTER
 * <LI><B>Labeled tape file</B> -- The data set name of the tape file
 * <LI><B>Unlabeled tape file</B> -- TAP<VAR>n</VAR> , where <VAR>n</VAR>
 * is a value from 0 to 9, or A to F.
 * <LI><B>Terminal</B> -- TERMINAL
 * </OL>
 * <P>
 * On VSE, the value of the character string assigned to &SYSTERM_DSN is always
 * SYSLOG.
 * <P>
 * <B>Examples:</B>
 * <P>
 * On MVS, &SYSTERM_DSN might be assigned a value such as:
 * <PRE>
 *    VCATR49.VCATR49A.JOB 6734.D 1 4.?
 * </PRE>
 * On CMS, &SYSTERM_DSN might be assigned a value such as:
 * <PRE>
 *    TERMINAL
 * </PRE>
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>If the TERM user exit provides the terminal data set information then the value
 * in &SYSTERM_DSN is the value extracted from the Exit-Specific Information
 * block described in the High Level Assembler Programmer's Guide.
 * <LI>The value of the type attribute of &SYSTERM_DSN (T.... &SYSTERM_DSN) is
 * always U.
 * <LI>The value of the count attribute of &SYSTERM_DSN (K.... &SYSTERM_DSN) is
 * equal to the number of characters assigned as a value to &SYSTERM_DSN.
 * </OL>
 */
property "&SYSTERM_DSN";
/**
 * On VSE, The value of &SYSTERM_MEMBER is always null.
 * <P>
 * The value of the type attribute is O, and the value of the count attribute is 0.
 * <P>
 * You can use &SYSTERM_MEMBER in a macro definition to obtain
 * the name of the data set member to which the assembler is writing the terminal
 * records.
 * <P>
 * The local system variable symbol &SYSTERM_MEMBER is assigned a read-only
 * value each time a macro definition is called.
 * <P>
 * If the data set to which the assembler is writing the terminal records is not an MVS
 * partitioned data set, &SYSTERM_MEMBER is assigned a null character string.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>If the TERM user exit provides the terminal data set information then the value
 * in &SYSTERM_MEMBER is the value extracted from the Exit-Specific
 * Information block described in the High Level Assembler Programmer's Guide.
 * <LI>The value of the type attribute of &SYSTERM_MEMBER
 * T.... &SYSTERM_MEMBER) is U, unless &SYSTERM_MEMBER is assigned a
 * null character string, in which case the value of the type attribute is O.
 * <LI>The value of the count attribute of &SYSTERM_MEMBER
 * K.... &SYSTERM_MEMBER) is equal to the number of characters assigned as a
 * value to &SYSTERM_MEMBER. If &SYSTERM_MEMBER is assigned a null
 * character string, the value of the count attribute is 0.
 * </OL>
 */
property "&SYSTERM_MEMBER";
/**
 * On VSE, The value of &SYSTERM_VOLUME is always null.
 * <P>
 * The value of the type attribute is U, and the value of the count attribute is 0.
 * <P>
 * You can use &SYSTERM_VOLUME in a macro definition to obtain the
 * volume identifier of the first volume containing the data set to which the assembler
 * is writing the terminal records.
 * <P>
 * The local system variable symbol &SYSTERM_VOLUME is assigned a read-only
 * value each time a macro definition is called.
 * <P>
 * If the assembler runs on the CMS component of the VM/ESA operating system,
 * and the terminal records are being written to a Shared File System CMS file,
 * SYSTERM_VOLUME is assigned the value SFS.
 * <P>
 * If the volume on which the data set resides is not labeled, &SYSTERM_VOLUME is
 * assigned a null character string.
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>If the TERM user exit provides the terminal data set information then the value
 * in &SYSTERM_VOLUME is the value extracted from the Exit-Specific
 * Information block described in the High Level Assembler Programmer's Guide.
 * <LI>The value of the type attribute of &SYSTERM_VOLUME
 * T.... &SYSTERM_VOLUME) is U, unless &SYSTERM_VOLUME is assigned a
 * null character string, in which case the value of the type attribute is O.
 * <LI>The value of the count attribute of &SYSTERM_VOLUME
 * K.... &SYSTERM_VOLUME) is equal to the number of characters assigned as a
 * value to &SYSTERM_VOLUME. If &SYSTERM_VOLUME is assigned a null
 * character string, the value of the count attribute is 0. The maximum length of
 * this system variable symbol is 6.
 * </OL>
 */
property "&SYSTERM_VOLUME";
/**
 * Use &SYSTIME to obtain the time at which your source module is assembled. It is
 * assigned a read-only value.
 * <P>
 * The value of &SYSTIME is a 5-character string in the format:
 * <PRE>
 *    HH.MM
 * </PRE>
 * where:
 * <UL>
 * <LI>HH is two-digit field that gives the hour of the day. It has a value between 00
 * and 23, inclusive.
 * <LI>MM is two-digit field that gives the minute of the hour. It has a value between 00
 * and 59, inclusive. It is separated from HH by a period.
 * </UL>
 * <P>
 * <B>Example:</B>
 * <PRE>
 *    9.45
 * </PRE>
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The time corresponds to the time printed in the page heading of listings and
 * remains constant for each assembly.
 * <LI>The value of the type attribute of &SYSTIME (T.... &SYSTIME) is always U.
 * <LI>The value of the count attribute (K.... &SYSTIME) is always 5.
 * </OL>
 */
property "&SYSTIME";
/**
 * Use &SYSVER to obtain the version, release, and modification level of the
 * assembler being used to assemble your source module. &SYSVER has a global
 * scope. For example, when IBM High Level Assembler for MVS & VM & VSE
 * Release 3.0 is used, &SYSVER has the value:
 * <PRE>
 *    1.3.
 * </PRE>
 * <P>
 * <B>Notes:</B>
 * <OL>
 * <LI>The value of the type attribute of &SYSVER (T.... &SYSVER) is always U.
 * <LI>The value of the count attribute (K.... &SYSVER) is the number of characters
 * assigned. In the above example, the count attribute of &SYSVER is 5.
 * </OL>
 */
property "&SYSVER";

