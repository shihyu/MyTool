/**
 * 
 * @return Returns a variable-length character string equal to the
 * account under which the user is logged into Model 204.
 * If the login feature is
 * not in use, $ACCOUNT returns the string 'NO ACCOUNT'
 * 
 * <P>
 * Example<P>
 * <pre>
 * BEGIN
 *    SET HEADER 1 'MORTON CORPORATION' -
 *    AT COLUMN 10
 *    SET HEADER 2
 *    SET HEADER 3 'ACCOUNT: ' AT COLUMN 10 -
 *    WITH $ACCOUNT
 *    .
 *    .
 *    .
 * </pre>
 */
function STRING $ACCOUNT();

/**
 * 
 * @return Returns a variable-length character string equal to the user ID under
 *         which the user is logged into Model 204. If the login feature is not in use,
 *         $ACCT returns 'NO ACCOUNT'.
 */
function STRING $ACCT();

/**
 * The $ALPHA function verifies whether a string is composed only of characters
 * which are valid in the specified (or default) language
 * 
 * @param text   String input parameter and must be one of the following:
 *               <ul>
 *               <LI>Quoted literal
 *               <LI>%variable
 *               <LI>Unquoted field name, in which case the current value of the field is verified. In this case, the function call must be embedded in a FOR EACH
 *               RECORD loop.
 *               </UL>
 * @param LanguageName
 *               (optional) specifies the language to use. Options are:
 *               <OL>
 *               <LI>Omitting this argument, which instructs Model 204 to perform the validation
 *               for U.S. English, even if the value of the LANGUSER parameter
 *               is not NLANG.
 *               <LI>A quoted asterisk ('*'), which instructs Model 204 to use the value of the
 *               LANGUSER parameter to determine which language to use.
 *               <LI>The quoted literal name of a valid language, for example: NLANGFR1
 *               for French Canadian, Version 1. The request is cancelled with an error
 *               message, if the name is not present in NLANG$.
 *               </UL>
 * @return 
 * A 1 is returned if the
 * condition is true; otherwise, a 0 is returned (for a false condition). A 0 is
 * returned if there are any spaces or punctuation marks in the string, or if the
 * string is null.
 * <PRE>
 * Example
 * 
 * $ALPHA ('JOHN') = 1
 * $ALPHA ('JOHN SMITH') = 0
 * $ALPHA ('12A') = 0
 * </PRE>
 * Example
 * <P>This request sorts and prints the names of agents whose name contains
 * nonalphabetic characters. The quoted asterisk in the $ALPHA call causes
 * Model 204 to verify the contents of the field AGENT against whatever language
 * is indicated by the value of the LANGUSER parameter:
 * <PRE>
 * BEGIN
 * POL.HOLDERS:  FIND ALL RECORDS FOR WHICH
 *               RECTYPE = POLICYHOLDER
 *               END FIND
 *               FOR EACH RECORD IN POL.HOLDERS
 *               IF NOT $ALPHA (AGENT, '*') THEN
 *               PLACE RECORD ON LIST BADNAME
 *               END IF
 *               END FOR
 * ORDERED.LIST: SORT RECORDS ON LIST BADNAME BY AGENT
 *               FOR EACH RECORD IN ORDERED.LIST
 *               PRINT AGENT
 *               END FOR
 *               END
 * </PRE>
 * <B>Note</B>: For upward compatibility reasons, $ALPHA and {@link $ALPHNUM} do
 * not recognize lowercase English letters as alphabetic characters
 * unless a non-null language parameter is specified.
 */
function BOOLEAN $ALPHA(STRING text,STRING LanguageName='U.S. English');




/**
 *  The $ALPHNUM function verifies whether a string is composed only of
 *  characters which are valid in the specified (or default) language, and digits 0
 *  through 9.
 * 
 * @param text   String input parameter and must be one of the following:
 *               <ul>
 *               <LI>Quoted literal
 *               <LI>%variable
 *               <LI>Unquoted field name, in which case the current value of the field is verified. In this case, the function call must be embedded in a FOR EACH
 *               RECORD loop.
 *               </UL>
 * @param LanguageName
 *               (optional) specifies the language to use. Options are:
 *               <OL>
 *               <LI>Omitting this argument, which instructs Model 204 to perform the validation
 *               for U.S. English, even if the value of the LANGUSER parameter
 *               is not NLANG.
 *               <LI>A quoted asterisk ('*'), which instructs Model 204 to use the value of the
 *               LANGUSER parameter to determine which language to use.
 *               <LI>The quoted literal name of a valid language, for example: NLANGFR1
 *               for French Canadian, Version 1. The request is cancelled with an error
 *               message, if the name is not present in NLANG$.
 *               </UL>
 * @return A 1 is returned if the condition is true; otherwise, a 0 is returned (for
 *         a false condition). A 0 is returned if there are any spaces or punctuation marks
 *         in the string, or if the string is null.
 * <PRE>
 * Example
 * 
 * $ALPHA ('JOHN') = 1
 * $ALPHA ('JOHN SMITH') = 0
 * $ALPHA ('12A') = 1
 * </PRE>
 * Example
 * This request sorts by name and processes records whose designated field
 * value does not meet the $ALPHNUM criteria. The second argument in the
 * $ALPHNUM call causes Model 204 to use U.S. English to perform the
 * validation:
 * <PRE>
 * BEGIN
 *            %SEARCH = $READ('ENTER FIELD NAME')
 * FIND.RECS: FIND ALL RECORDS FOR WHICH
 *                RECTYPE = POLICYHOLDER
 *            END FIND
 *            PLACE RECORDS IN FIND.RECS ON LIST BAD
 *            FOR EACH RECORD IN FIND.RECS
 *                IF $ALPHNUM(%%SEARCH, 'NLANG') THEN
 *                   REMOVE RECORD FROM LIST BAD
 *                END IF
 *            END FOR
 * SORT.RECS: SORT RECORDS ON LIST BAD BY FULLNAME
 *            FOR EACH RECORD IN SORT.RECS
 *            .
 *            .
 *            .
 * END
 * </PRE>
 * <B>Note</B>: For upward compatibility reasons, {@link $ALPHA} and $ALPHNUM do
 * not recognize lowercase English letters as alphabetic characters
 * unless a non-null language parameter is specified.
 */
function BOOLEAN $ALPHNUM(STRING text,STRING LanguageName='U.S. English');


/**
 * Determines the number of elements in a particular dimension of an array.
 * <p>This function is useful for users who pass entire
 * arrays as parameters to a subroutine and then must know the size of the array
 * supplied as the actual argument. For more information about passing arrays to
 * a subroutine, refer to 'Index loops'.
 * 
 * @param name      is a string that specifies the name of an array.
 * @param dimension is a number that indicates the dimension of the named array for
 *                  which the number of elements should be returned. Dimension can contain
 *                  an expression whose value is 1, 2, or 3.
 * @return  Returns the number of elements in a particular
 * dimension of a named array.
 * <PRE>
 * Example
 * 
 * FOR %I FROM 1 TO $ARRSIZE ('%COMM.ARRAY',1)
 * <PRE>
 * 
 * Causes %I to iterate from 1 to the number of elements in dimension 1 of the
 * array %COMM.ARRAY.
 */
function INTEGER $ARRSIZE (STRING name, INTEGER dimension);


/**
 * Converts an input string from EBCDIC to ASCII.
 * <p>The translation table can be modified when necessary at customer sites. The
 * source code is delivered in the FUNU module.
 * <P>
 * Not all strings are for display. There is no function to convert ASCII characters
 * to EBCDIC characters. Question marks are usually the results of trying to print
 * ASCII characters on an EBCDIC machine.
 * 
 * @param text   Input string to be translated
 * @return Returns text converted to ASCII
 * <PRE>
 * Example
 *
 * %X = $ASCII(%X)
 * </PRE>
 */
function STRING $ASCII(STRING text);


/**
 * The $BINARY function converts the character string representation of a
 * number into its equivalent fixed-point binary representation.
 * 
 * @param string    The character string to be converted.
 * @param precision (optional) Indicates the number of binary digits (bits) desired in the
 *                  result of the function. Precision must be between 1 and 31. If the precision
 *                  argument is greater than 15, a default value of 31 is used. If the precision
 *                  argument is omitted, a default value of 15 (halfword) is used.
 * @param scale     (optional) Indicates the number of fractional binary digits assumed in
 *                  the result of the function. If the scale argument is omitted, a default value of
 *                  0 (integer) is used.
 *                  
 * @return Returns the character string converted to its equivalent fixed-point
 *         binary representation.  A value of binary -1 is returned if the string argument 
 *         does not represent a valid number, if an invalid precision or scale value is
 *         specified, or if an overflow occurs.
 */
function FLOAT $BINARY(STRING string,INTEGER precision=15,INTEGER scale=0);

/**
 * The $BLDPROC function enables a request or series of requests to build a
 * temporary procedure. $BLDPROC is similar to the PROCEDURE system
 * control command.
 * <p>The procedure built by $BLDPROC can contain arbitrary commands or User
 * Language statements or other text. You can execute this procedure after the
 * building request has ended, or you can edit the temporary procedure into a
 * permanent procedure. For more information on temporary procedures, see
 * "Working with temporary procedures".
 * You can build only one procedure at a time. To add text to more than one
 * procedure in rotation, you must close one procedure and reopen the next
 * procedure.
 * @param ProcNumber is a temporary procedure number. The number of procedures
 * or requests saved for a user is controlled by the NORQS parameter, which
 * has a default value of 5. Procedure number 0 is the request currently being
 * entered. Procedure -1 refers to the request entered before the most recent
 * one, -2 to the one before that, and so on. Therefore, proc number must
 * have a value between 0 and -NORQS+1.
 * @param text is usually a single line to be appended to the temporary procedure. A
 * single call to $BLDPROC can add more than one line of text by imbedding
 * LINEND parameter characters (usually semicolons) in the text argument. If
 * the text argument is null, the procedure is not changed.
 * @param action must be one of the options listed in the following table. Building a
 * temporary procedure is similar to building a sequential file in that the
 * procedure must be opened before any text can be added to it. When all of
 * the desired text has been added, the procedure should be closed.
 * <p>Choose from these options:
 * <DL compact>
 * <DT>APPEND<DD> Adds the text to the end of an already opened procedure.
 * <DT>CLOSE<DD> Closes the temporary procedure, disallowing further APPENDs.
 * Model 204 automatically closes any procedure left open at the end of
 * execution of the request. Text specified in a CLOSE call is added before
 * the close.
 * <DT>OPEN<DD> Creates a new temporary procedure. If the procedure already exists, the
 * old text is automatically deleted. Text specified in the same
 * $BLDPROC call as OPEN is added after the procedure is opened.
 * <DT>REOPEN<DD> Prepares an existing procedure for the addition of text. REOPEN locates
 * the end of the old text so that new text is appended. OPEN and REOPEN
 * are identical for a new procedure. Text specified in the same $BLDPROC
 * call as REOPEN is added after the procedure is opened.
 * </DL>
 * A null or omitted action argument is the same as APPEND.
 * @return
 * How $BLDPROC works
 * $BLDPROC returns a 0 for success and a 1 for any of the following errors:
 * <UL>
 * <LI>The proc number argument is not numeric or is not in the range of valid
 * temporary procedure numbers.
 * <LI> The specified temporary procedure is being included.
 * <LI> Where a previous USE PROC command is also directing output to the
 * same temporary procedure.
 * <LI> The action argument is not one of the valid choices.
 * <LI> The action argument is OPEN or REOPEN and there is already an open
 * temporary procedure.
 * <LI> The action argument is APPEND or CLOSE and there is no open
 * procedure.
 * <LI> The action argument is APPEND or CLOSE and the proc number argument
 * does not match the currently opened procedure.
 * </UL>
 * <p><b>Example</b>
 * <p>This sample request saves the size of the global variable table (GTBL) before
 * the table is reset with the UTABLE command. (See "User Language internal
 * work areas" for information on the UTABLE command and
 * GTBL.) By saving the LGTBL value, the table can be returned to its original size
 * at a later time. This is particularly useful in a subsystem where the LGTBL
 * parameter is normally reset.
 * <pre>
 * BEGIN
 *          X = $BLDPROC(-1,'BEGIN','OPEN')
 *          X = $BLDPROC(-1,'%A = $SETG(''GTBL'',' WITH -
 *          $VIEW('LGTBL') WITH ')')
 *          IF %A THEN
 *          PRINT 'GLOBAL TABLE FULL'
 *          END IF
 *          X = $BLDPROC(-1,'END','CLOSE')
 *          IF %X THEN
 *          PRINT 'BLDPROC ERROR'
 *          END IF
 * END
 * UTABLE LGTBL 15000
 * </pre>
 * After the preceding request executes, procedure -1 contains the following
 * statements:
 * <pre>
 * BEGIN
 *          A = $SETG('GTBL',704)
 * END
 * </pre>
 */
function INTEGER $BLDPROC(INTEGER ProcNumber,STRING text,STRING action);

/**
 * 
 * @return Returns the number of unused entries within the
 *         resource enqueuing table. The return value must be more than the number of
 *         noncritical resources needed by the next statement(s) in the request. All
 *         resources except the following are noncritical:
 *         <UL>
 *         <LI>DIRECT
 *         <LI>EXISTENCE
 *         <LI>INDEX
 *         <LI>RECORD ENQUEUE
 *         </UL>
 *         The function has no input and returns a single number. For example, 'PRINT
 *         $CENQCT' displays the number of unused entries.
 */
function INTEGER $CENQCT();

/**
 * Use the $CHKMOD function after a READ SCREEN or REREAD SCREEN
 * statement to determine whether the terminal operator entered data for any full-screen
 * input fields or for a specific input field. See section
 * "Full-screen processing" for more information.
 * 
 * <p>If screenname and/or inputname are quoted strings, the name must be
 * enclosed in single quotation marks: 
 * <pre>
 * $CHKMOD('EMPSCRN', 'NAME')
 * </pre>
 * 
 * 
 * @param screenname Name of the screen.  This is a string expression which can 
 *         include quoted strings, %variables,  field names, or functions.
 * @param inputname  (optional) Name of the input field.  This is a string expression which can 
 *         include quoted strings, %variables,  field names, or functions.
 * @return If inputname (representing an input field on the specified screen) is not
 *         included in the function call, $CHKMOD returns the number of input fields
 *         for which the terminal operator entered data.
 *         <P>If inputname is specified, $CHKMOD returns a value of 0 if the input field
 *         was not modified. $CHKMOD returns a value of 1 if the field was modified.
 */
function INTEGER $CHKMOD(STRING screenname,STRING inputname=null);

/**
 * The $CHKPAT function verifies the syntax of a pattern.
 * Without $CHKPAT, pattern syntax errors caused cancellation of the request or
 * required the coding of sometimes awkward ON units.
 * $CHKPAT supports language-sensitive specification of patterns through an
 * optional second parameter (such as {@link $ALPHA} and
 * {@link $ALPHNUM}).
 * 
 * @param pattern Character string pattern to check.   This is a string expression which can 
 *         include quoted strings, %variables,  field names, or functions.
 * @param LanguageName
 *               (optional) specifies the language to use. Options are:
 *               <OL>
 *               <LI>Omitting this argument, which instructs Model 204 to perform the validation
 *               for U.S. English, even if the value of the LANGUSER parameter
 *               is not NLANG.
 *               <LI>A quoted asterisk ('*'), which instructs Model 204 to use the value of the
 *               LANGUSER parameter to determine which language to use.
 *               <LI>The quoted literal name of a valid language, for example: NLANGFR1
 *               for French Canadian, Version 1. The request is cancelled with an error
 *               message, if the name is not present in NLANG$.
 *               </UL>
 * @return Returns '' if the pattern is syntactally correct.  Otherwise an error message
 * is returned.
 * <P>
 * <B>Example</B>
 * <PRE>
 * X = CHKPAT(%PAT)
 * IF %X NE '' THEN
 *    PRINT %X
 *    JUMP TO ERROR.RETURN
 * END IF
 * </PRE>
 */
function INTEGER $CHKPAT(STRING pattern,string LanguageName='U.S. English');

/**
 * Returns information about checkpointing. It takes one argument, which
 * specifies what information to return.
 * 
 * @param ReturnRequest
 *               Integer value specifying information to return.
 * @return 
 * <B>ReturnRequest Parameter Value and Return Value</B>
 * <DL compact>
 * <DT>0<DD>Returns checkpointing status
 * <p><B>Return Value and Meaning</B>
 * 
 * <DL compact>
 * <DT>0<DD>Not active
 * <DT>1<DD>Currently being taken (by CPTIME or by CHECKPOINT command)
 * <DT>2<DD>Active, but no auto checkpoints; CPTIME=0
 * <DT>3<DD>Active and CPTIME does not equal 0
 * </DL>
 * <DT>1<DD> Time for the next checkpoint attempt (scheduled by the
 * CPTIME argument)
 * <p><B>Return Value and Meaning</B>
 * <DL>
 * <DT><B>9999/99/99 99:99:99.99</B><DD>Not active
 * <DT><B>9999/99/99 99:99:99.99</B><DD>CPTIME=0
 * Current date-time In progress
 * <DT><B>yyyy/mm/dd hh:mm:ss.hh</B><DD>Scheduled date/time
 * </DL>
 * <DT>2<DD>Seconds till the next checkpoint attempt
 * (scheduled by the CPTIME parameter)
 * <p><B>Return Value and Meaning</B>
 * <DL>
 * <DT><B>999999999</B><DD>Not active
 * <DT><B>999999999</B><DD>CPTIME=0
 * <DT><B>0</B><DD>In progress
 * <DT><B>sss:hh</B><DD>Scheduled in this many seconds
 * </DL>
 * <DT>3<DD>Time of last successful checkpoint
 * <p><B>Return Value and Meaning</B>
 * <DL>
 * <DT><B>Date-time of last checkpoint as yyyy/mm/dd hh:mm:ss.hh</B>
 * <DD>Due to CPTIME parameter or CHECKPOINT command
 * <DT><B>0000/00/00 00:00:00.00</B><DD>Not active
 * </DL>
 * <DT>4<DD>Seconds since the last successful checkpoint
 * <DL>
 * <DT><B>Time in seconds of checkpointing as sss:hh</B>
 * <DD>Due to CPTIME parameter or the CHECKPOINT command
 * <DT><B>999999999</B><DD>Not active
 * </DL>
 * </DL>
 * Example
 * <p>The following procedure illustrates using the $CHKPINF function.
 * <pre>
 * BEGIN
 *       PRINT $CHKPINF(0) WITH ' CURRENT CHECKPOINTING STATUS' AT 25
 *       PRINT $CHKPINF(1) WITH ' NEXT SCHEDULED CHECKPOINT ' AT 25
 *       PRINT $CHKPINF(2) WITH ' SECONDS UNTIL NEXT SCHEDULED CHECKPOINT' AT 25
 *       PRINT $CHKPINF(3) WITH ' LAST SUCCESSFUL CHECKPOINT TAKEN' AT 25
 *       PRINT $CHKPINF(4) WITH ' SECONDS SINCE LAST SUCCESSFUL CHECKPOINT ' AT 25
 * END
 * </pre>
 * Model 204 displays the following output:
 * <DL>
 * <DT><B>3</B><DD>CURRENT CHECKPOINTING STATUS
 * <DT><B>1998/10/21 14:59:13.48</B><DD>NEXT SCHEDULED CHECKPOINT
 * <DT><B>2030.01</B><DD> SECONDS UNTIL NEXT SCHEDULED CHECKPOINT
 * <DT><B>1998/10/21 13:59:13.41</B><DD> LAST SUCCESSFUL CHECKPOINT TAKEN
 * <DT><B>1570.07</B><DD>SECONDS SINCE LAST SUCCESSFUL CHECKPOINT
 * </DL>
 */
function STRING $CHKPINF(INTEGER ReturnRequest);

/**
 * Use the $CHKSFLD function to determine whether a display attribute is applied
 * to a screen item for a specified type of screen processing.
 * 
 * @param ScreenName String expression which can include quoted strings, %variables, field names, or
 *                   functions.
 * @param ItemName   String expression which can include quoted strings, %variables, field names, or
 *                   functions.
 * @param DisplayAttribute
 *                   <p><B>Value and Meaning</B>
 *                   <DL compact>
 *                   <DT>'ASK'<DD>Auto-skip
 *                   <DT>'BLI'<DD> Blink
 *                   <DT>'BLU'<DD> Blue color
 *                   <DT>'BRI'<DD> Bright
 *                   <DT>'DEF'<DD> Default color
 *                   <DT>'GRE'<DD> Green color
 *                   <DT>'INV'<DD> Invisible
 *                   <DT>'NUM'<DD> Numeric field
 *                   <DT>'PIN'<DD> Pink color
 *                   <DT>'PRO'<DD> Protected
 *                   <DT>'RED'<DD> Red color
 *                   <DT>'REV'<DD> Reverse image
 *                   <DT>'TUR'<DD> Turquoise color
 *                   <DT>'USC'<DD> Underscore
 *                   <DT>'WHI'<DD> White color
 *                   <DT>'YEL'<DD> Yellow color
 *                   </DL>
 * @param ProcessType
 *                   one of the following values:
 *                   <DL>
 *                   <DT>'PRINT'
 *                   <DT>'READ' (the default)
 *                   <DT>'REREAD'
 *                   <DT>'TAG'
 *                   </DL>
 * @return <UL>
 * <LI>1 if the attribute is ON for the type specified.
 * <LI>0 if the attribute is OFF for the type specified.
 * </UL>
 * 
 * <p>For example, if you want to check whether the POLNO (policy number) field in
 * the screen MAIN is displayed in blue in reread processing, enter the following
 * command:
 * <PRE>
 * BEGIN
 *       SCREEN MAIN
 *       INPUT POLNO AT 10 LEN 20 RED
 *       END SCREEN
 *       MODIFY %MAIN:POLNO TO BLUE FOR REREAD
 *       PRINT $CHKSFLD('MAIN','POLNO','BLU','REREAD')
 * END
 * </PRE>
 * Produces the following output: 
 * <BLOCKQUOTE><B>1</B></BLOCKQUOTE>
 * <p><B>Nonfatal errors</B>
 * <p>If you do not specify colors within the Model 204 screen definition, the color
 * displayed on your terminal is the default color display. For example, you might
 * be looking at a pink display, but when you invoke the $CHKSFLD function,
 * checking for 'PIN' does not return a '1' because pink was not assigned by the
 * Model 204 screen definition.
 * <P>The following messages might be issued:
 * <PRE>
 * M204.2462: INVALID ATTRIBUTE SPECIFIED: < attribute>
 * M204.2462: INVALID ATTR.TYPE SPECIFIED: < attr.TYPE>
 * M204.0329: SCREEN OR IMAGE ITEM NAME NOT FOUND: < name>
 * M204.0324: SCREEN, MENU, OR IMAGE NAME NOT DEFINED: < name>
 * M204.0247: SCREEN, MENU, OR IMAGE NAME NOT SPECIFIED
 * </PRE>
 */
function INTEGER $CHKSFLD(STRING ScreenName,STRING ItemName,STRING DisplayAttribute,STRING ProcessType='READ');

/**
 * Use the $CHKTAG function to determine whether any full-screen input fields
 * that resulted in error conditions were entered by the terminal operator. 
 * <p>The full-screen input fields either did not pass the automatic validation tests specified
 * for the fields, or contained errors detected by the request.
 * 
 * <p>If screenname and/or inputname are quoted strings, the name must be
 * enclosed in single quotation marks, as shown below:
 * <blockquote>
 * <pre>
 * $CHKTAG(%SCRNAME, 'ACCNTNO')
 * </pre></blockquote>
 * 
 * @param ScreenName Name of the screen.  This is a string expression which can 
 *         include quoted strings, %variables,  field names, or functions.
 * @param InputName  (optional) Name of the input field.  This is a string expression which can
 *                   include quoted strings, %variables,  field names, or functions.
 * @return 
 * If inputname (representing an input field on the specified screen) is not
 * included in the function call, $CHKTAG returns the number of input items
 * with tags on. If inputname is included, $CHKTAG returns a value of 0 if the
 * specified input item's tag is not on. $CHKTAG returns a value of 1 if the
 * item's tag is on.
 * <p><B>Example</B>
 * <pre>
 * IF $CHKTAG('ACCTG') GT 0
 *    THEN REREAD SCREEN ACCTG
 * </pre>
 */
function INTEGER $CHKTAG(STRING ScreenName,STRING InputName=null);

/**
 * The $CODE function, along with {@link $DECODE}, provides an encoding/decoding
 * facility in User Language.
 * <P>$CODE and $DECODE operate on code tables that
 * are defined, created, and controlled by the system manager. These tables can
 * be searched but not changed by User Language functions.
 * <P>$CODE and $DECODE search tables that are external to a Model 204 file.
 * These tables are independent of a field's CODED/NON-CODED attribute,
 * which affects how the field is stored internally in the Model 204 file.
 * The $CODE function takes two arguments:
 * 
 * @param TableName  Name of the table to be searched.
 * @param TableEntry An entry name in the table.
 * @return Returns the code for the character string value contained in the
 * TableEntry specified.  A null value is returned if the string is not contained
 * within the table or if the table does not exist. A nonexistent table also
 * causes the nonfatal message:
 * <BLOCKQUOTE><PRE>
 * INVALID CODE TABLE IDENTIFIER=X.
 * </PRE></BLOCKQUOTE>
 * <B>Example</B>
 * <P>This request prompts the user for the full name of a state but performs the
 * record search on the coded value for that state.
 * <PRE>
 * BEGIN
 *           STCD = $CODE ('STATE', $READ ('ENTER STATE NAME'))
 * GET.RECS: FIND ALL RECORDS FOR WHICH
 *               STATE = %STCD
 *           END FIND
 *           FOR EACH RECORD IN GET.RECS
 * </PRE>
 */
function STRING $CODE(STRING TableName,STRING TableEntry);

/**
 * 
 * @return Returns the remote file specification (filename AT location).
 * Where location is a name for the node where the remote file resides.
 * You can use {@link $SUBSTR} to extract the name or the location.
 * 
 * Returns the name of the file from which the current
 * record has been selected.
 * If the file is remote, $CURFILE also returns the
 * location of the file (in the form filename AT location).
 * 
 * <P>You can use $CURFILE in two places:
 * <OL>
 * <LI>In arithmetic and PRINT specifications within a record loop
 * <LI>In an IN clause to override a default file or group in a STORE RECORD statement
 * </OL>
 * 
 * You cannot use an IN clause that includes both MEMBER and $CURFILE. See
 * "IN GROUP MEMBER clause" for more information about the
 * IN GROUP MEMBER clause.
 * <P><b>Example 1</b>
 * <P>This sequence illustrates the use of a temporary group with an update file:
 * <PRE>
 * CREATE TEMP GROUP FISCAL FROM FY89, FY90, FY91
 *     PARAMETER UPDTFILE = FY91, PROCFILE = FY89
 * END
 * OPEN GROUP FISCAL
 * BEGIN
 * GET.ACCT.NO:  %A = $READ('ENTER ACCT NO OR "CR"')
 *               IF %A EQ " THEN
 *                  JUMP TO TOT.CT
 *               END IF
 *               %B = $READ('ENTER AMOUNT')
 *               IF %B EQ " THEN
 *                  JUMP TO TOT.CT
 *               END IF
 * FIND.ACCT.RECS: IN $UPDATE FIND ALL RECORDS FOR WHICH
 *                   ACCT NO = %A
 *               END FIND
 * CT:           COUNT RECORDS IN FIND.ACCT.RECS
 *               IF COUNT IN CT GT 1 THEN
 *                   PRINT 'ACCT MULTIPLY DEFINED' AND %A
 *                   JUMP TO END.REQUEST
 *               END IF
 * COMPUTE.B:    FOR EACH RECORD IN FIND.ACCT.RECS
 *                   %B = %B + AMT
 *                   CHANGE AMT TO %B
 *                   JUMP TO GET.ACCT.NO
 *               END FOR
 * ADD.REC:      STORE RECORD
 *                   ACCT NO = %A
 *                   AMT = %B
 *               END STORE
 * GET.NEXT:     JUMP TO GET.ACCT.NO
 * TOT.CT:       FIND AND PRINT COUNT
 * END.REQUEST:
 * END
 * </PRE>
 * The request searches the group update file (FY91) for an account number to
 * match the one entered by the user.
 * <ul>
 * <li>If there is more than one record with that number, the request ends.
 * <li>If a single record exists, the amount entered by the user is added to that
 * record. The request then asks for a new account number.
 * <li>If no record exists with a particular account number, the FOR loop falls
 * through to the ADD.REC statement. The STORE RECORD statement does
 * not contain an IN clause and thus stores the new record in the update file,
 * FY91.
 * </ul>
 * When the user indicates that updating is finished by pressing a carriage return
 * in response to the first prompt, execution proceeds to the TOT.CT statement.
 * The TOT.CT statement contains neither an explicit reference to another
 * statement nor an IN clause, so the request prints a single combined count of
 * the number of records in the three files in the group.
 * <P><b>Example 2</b>
 * <P>The next example creates an ad hoc group from the open files HISTORY and
 * FY90. The COMPUTE.TOT statement causes the amount fields from both files
 * to be added to a grand total to be printed at the end of the request. The
 * CHANGE.CAT statement uses the $CURFILE function to limit the budget
 * category change to records in the history file.
 * <PRE>
 * BEGIN
 * A.CAT:        IN HISTORY, FY80 FIND ALL RECORDS FOR WHICH
 *                    BUDGET CAT = A OR AA
 *               END FIND
 *               FOR EACH RECORD IN A.CAT
 * COMPUTE.TOT:      %TOT = AMT + %TOT
 * CHANGE.CAT:       IF $CURFILE EQ 'HISTORY' AND -
 *                      BUDGET CAT EQ 'AA' THEN
 *                      CHANGE BUDGET CAT TO 'A'
 *                   END IF
 *               END FOR
 *               PRINT 'TOTAL DOLLARS THRU 1990: ' WITH %TOT
 * END
 */
function STRING $CURFILE();

/**
 * The $CURREC function returns an integer equal to the internal number of the
 * current record.
 * <p>At the beginning of a request, $CURREC is set to minus one, an invalid record
 * number. The STORE RECORD statement sets $CURREC to the record
 * number of the new record.
 * <p>At the beginning of each pass through a FOR loop, $CURREC is set to the
 * record number of the record to be processed in that pass. When the FOR loop
 * is exited, because all records have been processed or because a LOOP END
 * or JUMP statement has been encountered, $CURREC is restored to its value
 * prior to the FOR statement. $CURREC takes no arguments.
 * <p>You should be aware of these facts when using $CURREC:
 * <UL>
 * <LI> In a record loop on the records of a SORT statement, $CURREC is set to
 * the record number of the record from which the temporary sort copy was
 * made.
 * <LI>Record numbers are not unique within a file group. The number returned by
 * $CURREC is valid only in reference to the file from which the record came.
 * </UL>
 * <P><b>Example</b>
 * <P>This request prints the record number of a new record:
 * <PRE>
 * BEGIN
 * GET.RECS:    FIND ALL RECORDS
 *              END FIND
 *              FOR 5 RECORDS IN GET.RECS
 *                  PRINT 'THE INTERNAL RECORD NO IS ' -
 *                      WITH $CURREC
 *                  END FOR
 *              END
 * </PRE>
 * 
 * @return 
 * Returns an integer equal to the internal number of the
 * current record.
 */
function INTEGER $CURREC();

/**
 * The $C2X function translates each byte within a character string into two-byte
 * hexadecimal-equivalent characters.
 *
 * <p>A character string is returned that is twice as long as the original string. The maximum input length is 126 bytes. If
 * the input length is more than 126 bytes, a null string is returned.
 * 
 * @param charstr the input character string (either a %variable or a quoted literal)
 * @return Returns hexadecimal-equivalent of the input string given
 * 
 * <P><B>Example</B>
 * <BLOCKQUOTE><PRE>
 * PRINT $C2X('YES')
 * </PRE></BLOCKQUOTE>
 * results in this output:
 * <BLOCKQUOTE><PRE>
 * E8C5E2
 * </PRE></BLOCKQUOTE>
 */
function STRING $C2X(STRING charstr);

/**
 * 
 * @param YearFormat Controls the format of the year based on the
 *                   following input values:
 *                   <DL compact>
 *                   <DT>0<DD>YY.  Last two digits of year
 *                   <DT>1<DD>YYYY.  Four digits of year.
 *                   <DT>2<DD>CYY.  Last three digits of year.
 *                   </DL>
 *                   <p>CYY represents the Century-year format. The first digit represents the
 *                   century since 1900. The CYY format can be manipulated using the
 *                   CUSTOM parameter. Please consult the Model 204 Command Reference
 *                   Manual for a discussion of the CUSTOM parameter.
 * @param FillCharacter Indicates a 1-byte fill character to place
 * between the date components, as in the following examples:
 * <p><B>Example: July 11,2013</B>
 * <pre>
 * $DATE(2,' ')='113 07 11'
 * $DATE(2,'Z')='113z07z11'
 * </pre>
 * @return Returns an 8- or 10-character string equal to the current
 * date in yy-mm-dd format (for example, 90-09-20) or yyyy-mm-dd format (for
 * example, 1990-09-20). The default is 8 characters. If $DATE is stored as a field
 * value, you can use this form to sort records chronologically.
 * 
 * <P>When using $DATE in field values, make sure that all values of $DATE are in
 * the same format. You will get incorrect results when sorting records if you mix
 * yyyy and yy formats.
 * <p>If Model 204 encounters an error, the function returns all asterisks (*).
 * <p>{@link $DATECHG}, {@link $DATECHK}, {@link $DATECNV}, and {@link $DATEDIF} recognize a format of
 * CYY as representing the century-year format as returned from the $DATE
 * function. Conversion to and from the CYY format is fully supported.
 */
function STRING $DATE(INTEGER YearFormat,STRING FillCharacter);

/**
 * 
 * @param format Specifies the format of the input date. The format can be a
 *               combination of these elements:
 *               <DL compact>
 *               <DT>DD<DD>Gregorian numeric day
 *               <DT>DDD<DD>Julian numeric date
 *               <DT>MM<DD>Numeric month
 *               <DT>MON<DD> Abbreviated month name
 *               <DT>MONTH<DD> Full month name
 *               <DT>YY<DD> Last two digits of numeric year (assumes that the year prefix is 19)
 *               <DT>YYYY<DD> Full numeric year
 *               <DT>CYY<DD>The century, plus the year. Century (C) is a single digit, where 0 represents
 *               1900, 1 represents 2000, and so on.
 *               </DL>
 *               <p>Valid formats are:
 *               <UL>
 *               <LI>A format that has a month, day, and year element
 *               <LI>A Julian date format that has a year element and a day element in the
 *               format DDD
 *               </UL>
 *               <p>Any EBCDIC characters except single quotes are allowed within the format.
 *               The format can be as many as 32 characters in length.
 * @param date   Specifies a date in the format indicated by the format argument. The
 *         date can be as many as 36 characters in length.
 * @param NumberOfDays  Indicates the number of days to be added or deducted from
 *         the date. The number must be an integer.
 * @return 
 * The $DATECHG function adds or subtracts a specified number of days from a
 * given date. The result is returned in the format of the input date.
 * <p><b>Separators and leading zeros</B>
 * <UL>
 * <LI>The separators in the format argument must match the separators in the
 * date argument. For example:
 * <BLOCKQUOTE><PRE>
 * $DATECHG('MONTH - DD - YYYY','JANUARY - 05 - 1986', 20)
 * </PRE></BLOCKQUOTE>
 * <LI> When necessary, you must pad the month or date in the date argument with
 * leading zeros to match the length of the format. For example:
 * <BLOCKQUOTE><PRE>
 * $DATECHG('YY DDD','86 023',22)
 * </PRE></BLOCKQUOTE>
 * </UL>
 * <p><B>How $DATECHG works</B>
 * <UL>
 * <LI>If the number of days is a positive integer, the number is added to the date.
 * <LI>If number of days is a negative integer, the number is deducted from the
 * date.
 * <LI>If an error occurs, all asterisks (*) are returned.
 * </UL>
 *
 * <p><B>Example</B>
 * <BLOCKQUOTE><PRE>
 * PRINT $DATECHG('MON. DD, YYYY','JAN. 10, 1999', 15)
 * </PRE></BLOCKQUOTE>
 * prints this value:
 * <BLOCKQUOTE><PRE>
 * JAN. 25, 1999
 * </PRE></BLOCKQUOTE>
 */
function STRING $DATECHG(STRING format,STRING date, INTEGER NumberOfDays);

/**
 * The $DATECHK function determines whether a given date is valid.
 * @param format Specifies the format of the input date. The format can be a
 *               combination of these elements:
 *               <DL compact>
 *               <DT>DD<DD>Gregorian numeric day
 *               <DT>DDD<DD>Julian numeric date
 *               <DT>MM<DD>Numeric month
 *               <DT>MON<DD> Abbreviated month name
 *               <DT>MONTH<DD> Full month name
 *               <DT>YY<DD> Last two digits of numeric year (assumes that the year prefix is 19)
 *               <DT>YYYY<DD> Full numeric year
 *               <DT>CYY<DD>The century, plus the year. Century (C) is a single digit, where 0 represents
 *               1900, 1 represents 2000, and so on.
 *               </DL>
 *               <p>Valid formats are:
 *               <UL>
 *               <LI>A format that has a month, day, and year element
 *               <LI>A Julian date format that has a year element and a day element in the
 *               format DDD
 *               </UL>
 *               <p>Any EBCDIC characters except single quotes are allowed within the format.
 *               The format can be as many as 32 characters in length.
 * @param date   Specifies a date in the format indicated by the format argument. The
 *               date can be as many as 36 characters in length.
 * @return  Returns a 1 if the date is valid. A 0 is returned if either the date is
 * invalid or if the date does not match a format you specify.
 * <P><b>Example</b>
 * <BLOCKQUOTE><PRE>
 * PRINT $DATECHK('MON. DD, YYYY','FEB. 30, 1999')
 * </PRE></BLOCKQUOTE>
 * <P>prints the value 0 because the month of February does not have 30 days.
 */
function BOOLEAN $DATECHK(STRING format,STRING date);


/**
 * The $DATECNV function converts an input date from its current format to a
 * format you specify and, also, determines whether the input date is valid. If a
 * format error occurs or the input date is not valid, the function returns all
 * asterisks (*). $DATECNV supports both a 2- and a 4-digit year format; the year
 * prefix can come from one of four places.
 * 
 * @param InputFormat
 *                  Specifies the format of the input date. The format can be a
 *                  combination of these elements:
 *                  <DL compact>
 *                  <DT>DD<DD>Gregorian numeric day
 *                  <DT>DDD<DD>Julian numeric date
 *                  <DT>MM<DD>Numeric month
 *                  <DT>MON<DD> Abbreviated month name
 *                  <DT>MONTH<DD> Full month name
 *                  <DT>YY<DD> Last two digits of numeric year (assumes that the year prefix is 19)
 *                  <DT>YYYY<DD> Full numeric year
 *                  <DT>CYY<DD>The century, plus the year. Century (C) is a single digit, where 0 represents
 *                  1900, 1 represents 2000, and so on.
 *                  </DL>
 *                  <p>Valid formats are:
 *                  <UL>
 *                  <LI>A format that has a month, day, and year element
 *                  <LI>A Julian date format that has a year element and a day element in the
 *                  format DDD
 *                  </UL>
 *                  <p>Any EBCDIC characters except single quotes are allowed within the format.
 *                  The format can be as many as 32 characters in length.
 * @param OutputFormat 
 * Specifies the format of the output date. The format
 * requirements are the same as those for the InputFormat argument. Using a
 * 2-digit year (YY) in the OutputFormat leaves you with no way to distinguish
 * between centuries. For example:
 * <blockquote><pre>
 * $DATECNV('MON DD, YYYY', 'YY DDD', 'JAN 10, 2005')
 * </pre></blockquote>
 * <p>produces the following output:
 * <blockquote><pre>
 * 05 010
 * </pre></blockquote>
 * <p>However, the output is exactly the same if the input date is January 10,
 * 1905 or January 10, 2105.
 * @param InputDate Specifies the input date in the format indicated by the input format
 *                  argument. The input date can be as many as 36 characters in length.
 * @param defcent   (optional) Specifies the DEFCENT value to use; it
 *                  overrides all other DEFCENT and CENTSPLT parameter values. This
 *                  argument cannot be specified with the centsplt argument, unless one of the
 *                  values is NULL.
 * @param centsplt  (optional) Specifies the CENTSPLT value to use; it
 *                  overrides all other DEFCENT and CENTSPLT parameter values. This
 *                  argument cannot be specified with the defcent argument, unless one of the
 *                  values is NULL.
 * @return Return InputDate converted to the specified date format
 * 
 * <P>The following example illustrates the use of the $DATECNV converting dates
 * in various centuries.
 * <PRE>
 * PROCEDURE CENTSPLT
 * BEGIN
 *          %INPUT_FORMAT = 'YYDDD'
 *          %OUTPUT_FORMAT = 'YYYY MM DD'
 *          %INPUT_VALUE = '9633'
 *          %CENTSPLT = 97
 *          %DEFCENT = ' '
 *          CALL PIT
 *          %CENTSPLT = ' '
 *          %DEFCENT = 19
 *          CALL PIT
 *          %INPUT_FORMAT = 'YYYYDDD'
 *          %INPUT_VALUE = '2006333'
 *          CALL PIT
 * PIT: SUBROUTINE
 *          PRINT %INPUT_FORMAT ' ' %OUTPUT_FORMAT ' ' %INPUT_VALUE -
 *              ' ' %DEFCENT ' ' %CENTSPLT
 *          PRINT $DATECNV(%INPUT_FORMAT, %OUTPUT_FORMAT,%INPUT_VALUE, -
 *              %DEFCENT, %CENTSPLT)
 *          RETURN
 * END SUBROUTINE
 * END
 * END PROCEDURE
 * </PRE>
 * For an explanation of the DEFCENT and CENTSPLT parameters processing
 * see Model 204 Command Reference Manual in the chapter on parameters.
 * <p><b>Separators and leading zeros</B>
 * <p>Use separators and leading zeros as specified here:
 * <UL>
 * <LI>Separators in the input format argument must match the separators in the
 * input date argument. For example:
 * <PRE>
 * $DATECNV('MONTH - DD - YYYY','MON DD, YYYY', -
 *     'JANUARY - 05 - 1990')
 * </PRE>
 * <LI> When necessary, you must pad the month or date in the input date
 * argument with leading zeros to match the length of input format. For
 * </UL>
 * example:
 * <PRE>
 * $DATECNV('YY DDD','MON DD, YYYY','90 023')
 * </PRE>
 * Example
 * <PRE>
 * PRINT $DATECNV('DDMMYY','MON DD, YYYY','010790')
 * </PRE>
 * prints this value:
 * <PRE>
 * JUL 01, 1990
 * </PRE>
 */
function STRING $DATECNV(STRING InputFormat, STRING OutputFormat,STRING InputDate,STRING defcent,STRING centsplt);

/**
 * 
 * 
 * @param date_1_format
 *                 Specifies the format of the date_1 argument. The format can be a
 *                 combination of these elements:
 *                 <DL compact>
 *                 <DT>DD<DD>Gregorian numeric day
 *                 <DT>DDD<DD>Julian numeric date
 *                 <DT>MM<DD>Numeric month
 *                 <DT>MON<DD> Abbreviated month name
 *                 <DT>MONTH<DD> Full month name
 *                 <DT>YY<DD> Last two digits of numeric year (assumes that the year prefix is 19)
 *                 <DT>YYYY<DD> Full numeric year
 *                 <DT>CYY<DD>The century, plus the year. Century (C) is a single digit, where 0 represents
 *                 1900, 1 represents 2000, and so on.
 *                 </DL>
 *                 <p>Valid formats are:
 *                 <UL>
 *                 <LI>A format that has a month, day, and year element
 *                 <LI>A Julian date format that has a year element and a day element in the
 *                 format DDD
 *                 </UL>
 *                 <p>Any EBCDIC characters except single quotes are allowed within the format.
 *                 The format can be as many as 32 characters in length.
 * @param date_1   Specifies the date in the format indicated by the date_1_format
 *                 argument. The date can be as many as 36 characters in length.
 * @param date_2_format
 *                 (optional) Specifies the format of the data_2 parameter.
 * @param date_2   Specifies the date in the format indicated by the date_2_format
 *                 argument. The date can be as many as 36 characters in length.
 * @param defcent  (optional) Specifies the DEFCENT value to use; it
 *                 overrides all other DEFCENT and CENTSPLT parameter values. This
 *                 argument cannot be specified with the centsplt argument, unless one of the
 *                 values is NULL.
 * @param centsplt (optional) Specifies the CENTSPLT value to use; it
 *                 overrides all other DEFCENT and CENTSPLT parameter values. This
 *                 argument cannot be specified with the defcent argument, unless one of the
 *                 values is NULL.
 * @return The $DATEDIF function returns the difference in days between the two dates.
 * <P><b>Dates in differing centuries</b>
 * <P>In the following procedure Date_Difference, the $DATEDIF function calculates
 * the difference between dates twice. Before the first PRINT command, the
 * CUSTOM parameter is set to 1, so the century defaults to the current century.
 * Before the second PRINT command, the DEFCENT parameter is set to 20.
 * <PRE>
 * PROCEDURE DATE_DIFFERENCE
 * RESET CUSTOM =(1
 * BEGIN
 *         PRINT $DATEDIF('CYYDDD','96333','YY MM DD','97 06 22',-
 *             %DEFCENT,%CENTSPLT)
 *             %DEFCENT = 20
 *         PRINT $DATEDIF('CYYDDD','096333','YY MM DD','97 06 22',-
 *             %DEFCENT,%CENTSPLT)
 * END
 * END PROCEDURE
 * </PRE>
 * For an explanation of the DEFCENT and CENTSPLT parameters processing
 * see Model 204 Command Reference Manual in the chapter on parameters.
 * <P><b>Separators and leading zeros</b>
 * <ul>
 * <li>The separators in each format must match the separators in the
 * corresponding date. For example:
 * <PRE>
 * $DATEDIF('MON DD, YYYY','JAN 08, 1990', -
 *     'YY:DDD', '88:210')
 * </PRE>
 * <li>When necessary, pad the month or date in the date argument with leading
 * zeros to match the length of corresponding format argument. For example:
 * <PRE>
 * $DATEDIF('YY DDD','90 034',,'90 007')
 * </PRE>
 * </UL>
 * <P><b>How $DATEDIF works</b>
 * <ul>
 * <li> If date1 is the same as date2, 0 is returned.
 * <li> If date1 is earlier than date2, a negative integer is returned.
 * <li> If date1 is later than date2, a positive integer is returned.
 * <li> If an error occurs, 999999999 is returned.
 * </UL>
 * Example
 * <PRE>
 * PRINT $DATEDIF('MMDDYY','010790',,'040891')
 * </PRE>
 * prints this value:
 * <PRE>
 * -456
 * </PRE>
 */
function INTEGER $DATEDIF(STRING date_1_format,STRING date_1,STRING date_2_format,STRING date_2,STRING defcent,STRING centsplt);

/**
 * 
 * @param YearFormat Controls the format of the year based on the
 *                   following input values:
 *                   <DL compact>
 *                   <DT>0<DD>YY.  Last two digits of year
 *                   <DT>1<DD>YYYY.  Four digits of year.
 *                   <DT>2<DD>CYY.  Last three digits of year.
 *                   </DL>
 *                   <p>CYY represents the Century-year format. The first digit represents the
 *                   century since 1900. The CYY format can be manipulated using the
 *                   CUSTOM parameter. Please consult the Model 204 Command Reference
 *                   Manual for a discussion of the CUSTOM parameter.
 * @param FillCharacter Indicates a 1-byte fill character to place
 * between the date components, as in the following examples:
 * <p><B>Example: July 11,2013</B>
 * <pre>
 * $DATEJ(1,'-')='2013-192'
 * $DATEJ(1,'')='2013192'
 * </pre>
 * @return 
 * The $DATEJ function returns the current Julian date as a 5- to 7-character
 * string in yy-ddd, format, for example, 97-342; or cyy-ddd format, for example,
 * 097-342; or yyyy-ddd format, for example, 1997-342. The default is 5
 * characters. If $DATEJ is stored as a field value, you can use this form to sort
 * records chronologically.
 * <p>When using $DATEJ in field values, make sure that all values of $DATEJ are
 * in the same format. You get incorrect results when sorting records if you mix
 * yyyy, cyy, and yy formats.
 * <p>If Model 204 encounters an error, the function returns all asterisks (*).
 */
function STRING $DATEJ(INTEGER YearFormat,STRING FillCharacter);

/**
 * 
 * @return 
 * The $DATEP function returns a 9-character or 11-character string equal to the
 * current date in either "dd mon yy" format (for example, 04 AUG 91) or "dd mon
 * yyyy" format (for example, 04 AUG 1991). The default is 9 characters.
 * 
 * @param YearFormat (optional) can be:
 * <DL compact>
 * <DT>0<DD> The default; indicates that $DATEP returns a 9-character string equal to the current date
 * in the dd mon yy format.
 * <DT>1<DD> Indicates that $DATEP returns an 11-character string equal to the current date in the
 *  dd mon yyyy format.
 * </DL>
 * <p>If Model 204 encounters an error, the function returns all asterisks (*).
 * See "Overview of $DATE functions" for more information.
 * <p><B>Example</B>
 * <PRE>
 * BEGIN
 *        SET HEADER 1 'TRIAL BALANCE' WITH $DATEP AT COLUMN 30
 *        NEW PAGE
 *        .
 *        .
 *        .
 * </PRE>
 */
function STRING $DATEP(INTEGER YearFormat=0);

/**
 * 
 * @param DayNumber is the number for the day of the week (1-SUN,2-MON,...7-SAT).
 *        DayNumber can also be 9 to represent the string 'MON-FRI'      
 * @return 
 * The $DAY function takes an input day number and returns a 3-byte string
 * containing the name of the day in ascending order beginning with Sunday. The
 * return values are: SUN, MON, TUE, WED, THR, FRI, and SAT.
 * <p>For example, if you enter the following command:
 * <pre>
 * PRINT $DAY(5)
 * </pre>
 * The Model 204 displays:
 * <pre>
 * 'THR'
 * </pre>
 * If CUSTOM=3 is selected, $DAY function takes an input day number from 2
 * through 8 representing in ascending order, Monday through Sunday. A string
 * containing the full name of the day is returned, for example, if you enter the
 * following command:
 * <pre>
 * PRINT $DAY(5)
 * </pre>
 * The Model 204 displays:
 * <pre>
 * 'FRIDAY'
 * </pre>
 * Also, 9 represents the string 'MON-FRI'.
 */
function STRING $DAY(INTEGER DayNumber);

/**
 * 
 * @param InputDate is a string in the format CYYDDD. (C is the century; YY is the
 *                  year, and DDD is the julian day.)
 * @param CenturySplit
 *                  (optional) is the 2-digit number representing the lowest year in the
 *                  current century. (Valid values are 00 to 99.)
 *                  
 * @return 
 *         The $DAYI function takes an input day number and the CenturySplit and
 *         resolves the date. The value returned is a number (1..7) reflecting the day of the week
 *         for the given date. (1-SUN,2-MON,...7-SAT) 
 *         <p>If the century (C) value is omitted, the century is determined by one of the
 *         following:
 *         <UL>
 *         <LI> The supplied century split value
 *         <LI> The system defined century split value (CENTSPLT)
 *         <LI> The system default century (DEFCENT)
 *         </UL>
 *         If the year is omitted, the current Model 204 defined year is used. The Julian
 *         day is required.
 *         <p>The default operation is CUSTOM=0, where the week days are numbered from
 *         1 through 7, representing Sunday through Saturday. If CUSTOM=3 is selected,
 *         the week consists of 2 through 8, representing Monday through Sunday.
 */
function STRING $DAYI(STRING InputDate,STRING CenturySplit);

/**
 * The $DEBLANK function is equivalent to the {@link $SUBSTR} function, except that
 * the resulting string is stripped of leading and trailing blanks. See {@link $SUBSTR}
 * for more information.
 * <P>The position and length arguments are rounded to positive integers.
 * 
 * @param InputString   the input string from which the substring is derived.
 * @param position the position in the string at which the substring is to begin (first position is 1).
 * @param length   (optional) The maximum length of the substring. If this argument is omitted,
 *                 a default value of 255 is used.
 * @return Returns a substring of the InputString given.
 */
function STRING $DEBLANK(STRING InputString,INTEGER position,INTEGER length=255);

/**
 * The $DECODE function performs a table lookup and returns a decoded
 * character string value. $DECODE is useful for printing descriptive information
 * on reports when the records themselves contain only coded values.
 * $DECODE conserves space and minimizes the keystrokes required for
 * requests by retaining only codes for fields.
 * 
 * @param table_name is the name of a table.
 * @param resolve    The code that is to be decoded.
 * @return Returns a decoded character string value
 * <p><B>Example</B>
 * <p>The state field contains a 2-character code. Full state names are printed.
 * <PRE>
 * BEGIN
 * STATE:       FOR EACH VALUE OF STATE IN ORDER
 * STATE.VAL:       FIND ALL RECORDS FOR WHICH
 *                      STATE = VALUE IN STATE
 *                  END FIND
 * NO.IN.EACH:      COUNT RECORDS IN STATE.VAL
 *                  SKIP 1 LINE
 *                  PRINT $DECODE ('STATE', VALUE IN STATE) -
 *                  WITH COUNT IN NO.IN.EACH AT COLUMN 30
 *              END FOR
 * END
 */
function STRING $DECODE(STRING table_name,STRING resolve);

/**
 * Deletes information stored in the global variable table by a {@link $SETG} function in
 * the same or an earlier request.
 * 
 * @param GlobalVariableName Specifies the name of the global variable to delete.
 * If an asterisk (*) is appended to the the variable, all global
 * variables with the same common prefix are deleted. You cannot delete all global variables
 * by specifying just '*' for this argument.
 * @return $DELG returns a completion code indication success or failure of the operation.
 * <p><B>Code and Meaning</B>
 * <dl compact>
 * <DT>0<DD>Successful. Global variable(s) deleted.
 * <dt>1<dd> Not found. No global variable found that matches the supplied argument.
 * <dt>2<dd> Unsucessful.
 * </DL>
 * <B>Examples</B>
 * <pre>
 * * The following statement removes the global
 * * variable 'DELETE' from the table.
 * %RC = $DELG('DELETE')
 * * The following statement removes all global variables 
 * * starting with GVAR including GVAR, from the global 
 * * variable table.
 * %RC = $DELG('GVAR*')
 * </pre>
 *
 */
function INTEGER $DELG(STRING GlobalVariableName);

/**
 * The functionality of the $DSCR function is superseded by the $LSTFLD and
 * $FDEF functions. $DSCR is still supported, however.
 * @param FieldName String expression representing a field name
 * @return The $DSCR function interprets its character string argument as a field name. It
 * returns a variable-length character string describing the specified field. Each
 * letter in the returned string represents a particular field attribute. Attributes are
 * listed below.
 * <p><B>Character Attribute</B>
 * <DL compact>
 * <DT>A<DD> ORDERED CHARACTER
 * <DT>C<DD> CODED
 * <DT>D<DD> DEFERRABLE
 * <DT>F<DD> FRV
 * <DT>I<DD> INVISIBLE
 * <DT>K<DD> KEY
 * <DT>L<DD> LEVEL
 * <DT>M<DD> MANY-VALUED
 * <DT>N<DD> ORDERED NUMERIC
 * <DT>O<DD> OCCURS
 * <DT>P<DD> UPDATE IN PLACE
 * <DT>Q<DD> UNIQUE
 * <DT>R<DD> NUMERIC RANGE
 * <DT>S<DD> STRING
 * <DT>T<DD> FLOAT
 * <DT>W<DD> AT-MOST-ONE
 * </DL>
 * <p><B>How $DSCR works</B>
 * <p>When $DSCR is invoked in file context, the returned string represents the
 * description of the specified field in the current file.
 * Each letter that appears in the return value corresponds to an attribute in the
 * field description. For example, if K is one of the letters in the returned string,
 * then the field is KEY.
 * <p>If a particular letter does not appear in the result of a $DSCR call, then either
 * the corresponding attribute does not apply or the attribute's opposite is in effect.
 * For example, if M (many-valued) does not appear, the field is NON-CODED
 * and NON-FRV, in which case M does not apply, or it is FEW-VALUED. You can
 * resolve this by looking for C and F in the returned string.
 * <p>When $DSCR is invoked in group context, the returned string represents a
 * composite description of the field in all of the files of the current group. Some
 * of the letters imply that the corresponding field attribute is present in all of the
 * files in the group; others imply that the attribute is present in some (at least one)
 * file in the group. If the field specified as the $DSCR argument is not defined in
 * the current file or group, $DSCR returns the character string "U" (undefined).
 * The table below lists the individual letters and their meanings in group context.
 * <DL compact>
 * <DT>A<DD> ORDERED CHARACTER in some
 * <DT>C<DD> CODED in all
 * <DT>D<DD> DEFERRABLE in some
 * <DT>F<DD> FRV in some
 * <DT>I<DD> INVISIBLE in all
 * <DT>K<DD> KEY in all
 * <DT>L<DD> LEVEL in some
 * <DT>M<DD> MANY-VALUED in all
 * <DT>N<DD> ORDERED NUMERIC in some
 * <DT>O<DD> OCCURS in some
 * <DT>P<DD> UPDATE IN PLACE in some
 * <DT>Q<DD> UNIQUE in some
 * <DT>R<DD> NUMERIC RANGE in all
 * <DT>S<DD> STRING in all
 * <DT>T<DD> FLOAT in some
 * <DT>W<DD> AT-MOST-ONE in all
 * <DT>U<DD> undefined
 * </DL>
 * 
 * <p><B>Example</B>
 * <p>This request determines the attributes of a field and performs one of three types
 * of searches, depending on the results of $DSCR.
 * <pre>
 * BEGIN
 *              %A = $READ ('FIELD NAME')
 *              %B = $READ ('FIELD VALUE')
 *              %C = $DSCR (%A)
 *              IF %C EQ 'U' THEN
 *                  PRINT 'ILLEGAL FIELD'
 *                  JUMP TO STOP
 *              END IF
 *              *CHECK FOR NON-KEY
 *              IF $INDEX (%C, 'K') EQ 0 THEN
 *                  JUMP TO NUM.RNG.CHK
 *              END IF
 *              FIND AND PRINT COUNT
 *                  %%A = %B
 *              END FIND
 *              JUMP TO STOP
 *              *CHECK FOR NUMERIC RANGE
 * NUM.RNG.CHK: IF $INDEX (%C, 'R') EQ 0 THEN
 *                  JUMP TO ALL.RECS
 *              END IF
 *              FIND AND PRINT COUNT
 *                  %%A IS %B
 *              END FIND
 *              JUMP TO STOP
 *              *NEITHER KEY FOR NUMERIC RANGE
 * ALL.RECS:    FIND ALL RECORDS
 *              END FIND
 *              FOR EACH RECORD IN ALL.RECS
 *                  IF %%A = %B THEN
 *                      PLACE RECORD ON LIST OK
 *                  END IF
 *              END FOR
 * OKS:         COUNT RECORDS ON LIST OK
 *              PRINT COUNT IN OKS
 * STOP:        END
 * END
 * </pre>
 */
function STRING $DSCR(STRING FieldName);


/**
 * $DSN is useful with Model 204 files that are comprised of multiple datasets.
 * You specify the Model 204 file's DD name and the ordinal number (first,
 * second, third, and so on) of one of the file's datasets, and $DSN returns the
 * dataset's name.
 * 
 * @param ddname is a Model 204 file DD or file name.
 * @param dsnnum  is a positive integer that represents the ordinal number of a
 * dataset. For example, specify 3 for dsnnum if you want the name of the third
 * of the multiple datasets that comprise the Model 204 file.
 * 
 * @return 
 * If no file or DD name is specified, if the dataset number is too large, and if
 * Model 204 cannot find the dataset name, the system returns a counting error
 * message.
 * <p><B>Examples</B>
 * <p>An example using $DSN follows:
 * <pre>
 * FOR %I FROM 1 TO $DSNNUM('FU',%I) BY 1
 *    PRINT $DSN('FU',%I)
 * END FOR
 * <pre>
 * The next example does a straight $DSN call for a file mapped to one dataset.
 * <pre>
 * FILENAME IS STRING LEN 8
 * FILENAME = 'VEHICLES'
 * PRINT 'FILE ' WITH %FILENAME WITH ' IS CONTAINED IN -
 *     DATASET ' WITH $DSN(%FILENAME,1)
 * </pre>
 */
function STRING $DSN(STRING ddname,INTEGER dsnnum);

/**
 * $DSNNUM is useful with Model 204 files that are comprised of multiple
 * datasets. You specify the Model 204 file's DD name or file name and
 * $DSNNUM returns the total number of datasets defined for the file.
 * 
 * @param ddname is a file or dataset's DD name.
 * @return  Returns the total number of datasets defined for the file specified.
 * $DSNNUM returns a zero if the file or dataset is not found. It returns a -1 for an
 * argument syntax error.
 * <p>For a sequential file, the number of dataset names is always one.
 * The following example combines the use of $DSNNUM to identify the number
 * of datasets that a file maps to, and then uses $DSN to print out the dataset
 * name.
 * <pre>
 * FILENAME IS STRING LEN 8
 * FILENAME = 'MYFILE'
 * PRINT 'FILE ' WITH %FILENAME WITH -
 *     'IS CONTAINED IN THE FOLLOWING DSNS ' -
 * PRINT
 * FOR %I FROM 1 TO $DSNNUM(%FILENAME)
 *     PRINT $DSN(%FILENAME,%1)
 * END
 * </pre>
 */
function INTEGER $DSNNUM(STRING ddname);

/**
 * The $EDIT function performs numeric and alphanumeric editing. This function
 * returns a string modified according to a user-specified edit pattern. $EDIT
 * enables you to perform the types of editing listed below:
 * 
 * <DL>
 * <DT>Numeric <DD>In a manner similar to numeric editing in COBOL. Note the following
 * differences:
 * <UL>
 * <LI>Exponential notation, the scale position character (P), the sign
 * character (S), and repetition notation (the use of parentheses to
 * enclose an integer) are not supported by $EDIT.
 * <LI>The B character is not supported. However, a blank (a space) in the
 * mask provides the same functionality as the B character.
 * <LI>A colon is supported as a simple edit character.
 * <LI>Overflow (to the left of the decimal point) is handled by returning a
 * string of # characters.
 * </UL>
 * <DT>Alphanumeric<DD>
 * <UL>
 * <LI> Inserting characters at designated points
 * <LI> Removing blanks from the input string
 * <LI> Truncating the output at designated points either conditionally or
 * unconditionally
 * </UL>
 * </DL>
 * 
 * @param input    specifies the input data to be edited. The input can be either numeric
 *                 or string.
 *                 <UL>
 *                 <LI>If numeric editing is performed, string input is converted to numerics
 *                 prior to editing.
 *                 <LI>If alphanumeric editing is performed, numeric input is converted to a
 *                 string prior to editing.
 *                 </UL>
 * @param mask     specifies the edit mask. The mask can be either numeric or
 *                 alphanumeric. The characters that can be used to define each type of edit
 *                 mask are discussed below.
 * @param justification
 *                 specifies the direction in which the input and mask are
 *                 processed. Justification options are:
 *                 <UL>
 *                 <LI>L for left-justification, the default for alphanumeric editing
 *                 <LI>R for right-justification, the default for numeric editing
 *                 </UL>
 * @param EditType specifies the type of editing. Edit type options are N for numeric
 *                 editing and A for alphanumeric editing. The default edit type is N.
 * @return Returns the input string edited as specified.
 * <p><B>Numeric edit mask</B>
 * <p>The numeric edit mask can contain up to 255 characters and have as many as 15
 * digit positions. Justification of the result defaults to right justification for numeric.
 * editing. Left justification causes all leading and trailing blanks to be removed
 * from the resulting string. If the result of a numeric edit is all blanks and left
 * justification has been requested, a null string is returned. A numeric edit mask
 * consists of one or more of the characters listed below. The use of the
 * characters within each character type is described after the table.
 * <DL compact>
 * <DT>9<DD> (type=Data) The position contains a number (0-9).
 * <DT>blank <DD>(type=Simple) A blank is embedded in the specified position.
 * <DT>0<DD> (type=Simple) A numeric zero appears in the specified position.
 * <DT>, <DD> (type=Simple) A comma appears in the specified position.
 * <DT>/ <DD> (type=Simple) A slash appears in the specified position.
 * <DT>: <DD> (type=Simple) A colon appears in the specified position.
 * <DT>.<DD> (type=Actual decimal)
 * A decimal point (period) appears in the position and specifies
 * decimal alignment. A period can appear only once in a mask.
 * <DT>CR <DD> (type=Fixed) CR appears in the output string if the input argument is
 * negative. If the input argument is positive, two spaces appear
 * rather than CR. CR can be specified only once in a mask and
 * must be specified in the right-most position of the mask.
 * <DT>DB <DD> (type=Fixed) DB appears in the output string if the input argument is
 * negative. If the input argument is positive, two spaces appear
 * rather than DB. DB can be specified only once in a mask and
 * must be specified in the right-most position of the mask.
 * <DT>$ <DD>(type=Fixed or float)
 * A dollar sign appears in the specified position in the output
 * string for a fixed $. For a float $, the position might contain
 * either a dollar sign, a digit, or a space depending upon the
 * location of the float character.
 * <DT>+ <DD> (type=Fixed or float)
 * The sign of the output string with a fixed + can be either
 * positive or negative, depending on the value of the input
 * argument. A plus or minus sign is placed in the specified
 * position in the output string. For a float +, a plus sign, minus
 * sign, digit, or space might be placed in the output string
 * depending upon the location of the float character.
 * <DT>- <DD> (type=Fixed or float)
 * A minus sign is placed in the output string for a fixed - only
 * Float if the value of the input argument is negative. For a float
 * -, a minus sign, digit, or a space might be placed, depending
 * upon the location of the float character. If the input argument
 * is a positive value, a space replaces a minus sign.
 * <DT>Z<DD> (type=Suppress) Any leading character position that contains a zero is to be
 * replaced by a space.
 * <DT>*<DD> (type=Suppress) Any leading character position that contains a zero is to be
 * replaced with an asterisk.
 * <DT>V<DD> (type=Assumed decimal)
 * The position of an assumed decimal point. The V character
 * can appear only once in a character string.The V does not
 * denote an actual character position; space is not reserved for
 * it in storage.
 * </dl>
 * Each character type (data, simple insertion, actual decimal, fixed, float,
 * suppression, and assumed decimal) is discussed in detail below.
 * <Ul>
 * <li><b>Data</b>-- When a data edit character (9) is used, the numeric value in the
 * input string replaces the appropriate data character in the mask. If the input
 * argument has fewer characters than the mask, a 0 is returned in each
 * unfilled position. For example:
 * <PRE>
 *    $EDIT(2573,'99999')
 * </PRE>
 * returns the value:
 * <PRE>
 *    02573.
 * </PRE>
 * <li> <b>Simple insertion</b>-- When a simple insertion character (a blank, zero,
 * comma, slash, or colon) is used, the specified mask positions are reserved
 * and replaced by the appropriate character in the output string. For example:
 * <PRE>
 *    $EDIT(2573478977,'9,999,999,999')
 * </PRE>
 * returns the value:
 * <PRE>
 *    2,573,478,977.
 * </PRE>
 * <li> <b>Actual decimal</b>-- When the actual decimal character (the period) is used,
 * the specified decimal position is reserved and placed in the output string
 * and the input string is decimal aligned. For example:
 * <PRE>
 *    $EDIT(25.734,'99999.99')
 * </PRE>
 * returns the value:
 * <PRE>
 *    00025.73.
 * </PRE>
 * <P>Note: If the mask contains fewer digits to the right of the decimal point
 * than the input argument, the input argument is scaled by dropping
 * the excess digits to the right of the decimal point.
 * <LI><B>Fixed</B>-- When a fixed edit character (CR, DB, $, +, -) is used, the specified
 * leading or trailing position is reserved and replaced with the appropriate
 * character in the output string. A fixed edit character can occur only once in
 * a mask. For example:
 * <PRE>
 *    $EDIT(-457.22,'$999.99CR')
 * </PRE>
 * returns the value:
 * <PRE>
 *    $457.22CR.
 * </PRE>
 * 
 * Consider the following when using fixed edit characters:
 * <UL>
 * <LI> A mask can contain at most one fixed sign character (+, -, CR, or DB).
 * <LI> If the edit mask contains a trailing fixed sign character and that charac-ter
 * is set to blanks in the result, right justification causes the trailing
 * blank to be retained.
 * <LI> When a + or - is specified, it must be the first or last character in the
 * mask.
 * <LI> No more than one $ and one +, -, CR, or DB can be specified within a
 * mask. The $ must either be specified in the left-most position of the
 * mask or be preceded only by a + or -.
 * </UL>
 * <LI> <B>Float</B>-- When float edit characters ($, +, or -) are used, the specified
 * positions are reserved in the output string. (A float mask must contain at
 * least two consecutive float characters of the same type.) Float characters
 * can be specified in any leading character position to the left of the decimal
 * point. Float characters also can be specified in any trailing character
 * position to the right of the decimal point only if all digit positions are
 * represented by the float character.
 * The float character is inserted immediately to the left of either the first
 * significant digit, a digit position specified with a 9, or a decimal point,
 * whichever is furthest to the left. All positions to the left of the inserted float
 * character are replaced with blanks. For example:
 * <PRE>
 *   $EDIT(-8283.56,'$$$$$$999.99CR')
 * </PRE>
 * returns the value:
 * <PRE>
 *    $8283.56CR.
 * </PRE>
 * Note the following considerations when using float edit characters:
 * <UL>
 * <LI> Floating $, +, and - characters are mutually exclusive within the mask.
 * <LI> The float mask can be interrupted by one or more simple characters or
 * by an assumed or actual decimal point. Simple insertion characters to
 * the left of the floating character actually used in the output string are
 * converted to blanks in the output string. For example:
 * <PRE>
 *    $EDIT(-123456.789, '++,+++,999.99')
 * </PRE>
 * returns a value of:
 * <PRE>
 *    -123,456.78.
 * </PRE>
 * <li>If float characters appear in all the numeric data positions and the value
 * of the input argument is zero, the output string contains all spaces. For
 * example:
 * <PRE>
 *    $EDIT(0000.00, '$$,$$$,$$$.$$')
 * </PRE>
 * returns a null string.
 * </UL>
 * <LI> <B>Suppression</B>-- When a suppression character (Z or *) is used, the
 * specified position is reserved and replaced with the appropriate character
 * in the output string. One or more suppression characters can be specified
 * in a mask; however, Z and * are mutually exclusive.
 * <P>A suppression character can be specified in any leading character position
 * to the left of the decimal point. A suppression character also can be
 * specified in any trailing character position to the right of the decimal point
 * only if all positions to the right are represented by the suppression
 * character.
 * <P>$EDIT returns the value of the suppression character (a blank for each Z or
 * an asterisk for each *) for each leading position that has a value of 0,
 * stopping at the left-most position that either contains nonzero data or is an
 * actual decimal point.
 * <P>For example:
 * <PRE>
 *    $EDIT(+84783.56,'$Z,ZZZ,ZZZ.ZZ')
 * </PRE>
 * <p>returns the value $84,783.56. Note that any simple edit characters (a blank,
 * zero, comma, slash, or colon) to the left of the stopping point are replaced
 * with the suppression character (blank or *).
 * <p>In addition, if all data positions in the mask are represented by suppression
 * characters and the value of the input is zero, all characters in the mask
 * (including simple insertion characters) are replaced with the suppression
 * character. For example:
 * <PRE>
 *    $EDIT(0,'$ZZ,ZZZ')
 * </PRE>
 * returns all blanks.
 * <li> <b>Assumed decimal</b>-- When the assumed decimal character is used, the
 * input is decimal aligned. However, the decimal does not occupy an output
 * position. For example:
 * <PRE>
 *    $EDIT(.12345,'999V 99')
 * </PRE>
 * returns the value:
 * <PRE>
 *    000 12.
 * </PRE>
 * Note these additional considerations when defining a numeric edit mask:
 * <UL>
 * <li> The mask must contain at least one occurrence of 9, Z, or * or more
 * than one occurrence of +, -, or $.
 * <li> All characters except the assumed decimal character (V) are counted in
 * the size of the output string.
 * <li> The special character (.) and the assumed character (V) are mutually
 * exclusive within a mask.
 * <li> The $ fixed character and the + or - floating characters are mutually
 * exclusive.
 * <li> Floating edit characters and suppression characters are all mutually
 * exclusive.
 * <li> Floating edit characters and suppression characters to the left of an
 * actual or assumed decimal point cannot be preceded by the data edit
 * character (9). A suppression character to the left of an actual or
 * assumed decimal point also cannot be preceded by a float character.
 * <li> The mask should be large enough to accommodate the input string or
 * truncation occurs. If the mask contains fewer digits to the right of the
 * decimal point than the input argument, the input argument is scaled by
 * dropping the excess digits to the right of the decimal point.
 * </UL>
 * </UL>
 * <P><b>Alphanumeric edit mask</b>
 * <P>An alphanumeric edit mask can contain up to 255 characters and as many as
 * 255 edit character positions. Justification of the result defaults to left
 * justification for alphanumeric editing. If the input string is a null string, the mask
 * is still processed. If the string is longer than the number of character positions
 * indicated in the mask, the excess characters in the input string are ignored. An
 * alphanumeric edit mask can consist of one or more of these character types:
 * <P><b>Character Used in alphanumeric edit masks</b>
 * <DL compact>
 * <dt>Insertion <dd>Any character can be an insertion character. However, if the insertion
 * character is not a letter (A-Z, a-z), a digit (0-9), or a blank, it must be
 * preceded by an escape character.
 * <dt>Escape (!) <dd>The escape character indicates that the next character in the edit mask is
 * interpreted literally (as an inserted character rather than as a selection
 * character). The escape character must precede non-alphanumeric
 * insertion characters.
 * <ul>
 * <li> If the justification argument is R (processing from right to left), the
 * escape character must be to the right of the insertion character.
 * <li> If the justification argument is L (processing from left to right), the
 * escape character must be to the left of the insertion character.
 * <li> If the escape character is the last character in the mask, it is ignored.
 * <li> If the escape character is omitted before a non-alphanumeric
 * insertion character, the mask is considered invalid, a null result is
 * returned, and an error message is issued.
 * </ul>
 * <dt>Simple selection <dd>See Special simple selection characters below.
 * <dt>Special selection<dd>See Special selection characters below.
 * </DL>
 * <p><B>Simple selection characters</B>
 * <DL compact>
 * <DT>+<DD>Single input character. If no input characters remain, a blank is inserted and
 * processing continues with the next character in the mask.
 * <DT>*<DD>All remaining input characters. If no input characters remain, a blank is not
 * inserted and processing continues with the next character in the mask.
 * <DT> <DD>Next non-blank character in the input string. If no input characters remain, a
 * blank is not inserted and processing continues with the next character in the
 * mask.
 * </DL>
 * <p><B>Special selection characters</B>
 * <DL compact>
 * <DT>< <DD>Whether to continue processing or truncate the result, depending on
 * processing direction. (See the discussion that follows for details concerning
 * processing direction.)
 * <DT>) <DD>The placement of a single character. If no input characters remain, a blank
 * is inserted and processing of the mask is terminated.
 * <DT>- <DD>The placement of a single character. If no input characters remain, a blank
 * is inserted and all subsequent insertion characters are replaced with blanks.
 * </DL>
 * When a special selection character is used, truncation is handled in the
 * following manner:
 * <UL>
 * <LI> The processing direction (in the direction specified by the justification
 * option) determines how the < or > character is handled:
 * When a < or > character points in the processing direction, it acts as a
 * continuation character and is handled as follows:
 * <UL>
 * <LI> The next remaining input character is placed in the result and the next
 * character in the mask is processed.
 * <LI> For no remaining input characters, the result is unaffected and the next
 * character in the mask is processed.
 * </UL>
 * <p>If a < or > points in the direction opposite from the processing direction, it
 * acts as a truncation character and is handled as follows:
 * <UL>
 * <li> For several remaining input characters, the next input character is
 * placed in the result and the next character in the mask is processed.
 * <LI> For one remaining input character, that character is placed in the result
 * and the result is truncated after the character.
 * <LI> For no remaining input characters, the result is truncated after the pre-vious
 * result character.
 * </UL>
 * <LI> The | character has the following effect:
 * <UL>
 * <LI> For several remaining input characters, the next input character is
 * placed in the result and the next character in the mask is processed.
 * <LI> For one remaining input character, that character is placed in the result
 * and the result is truncated after the character.
 * <LI> For no remaining input characters, a blank is placed in the result and
 * the result is truncated after the blank.
 * </UL>
 * <LI> The _ (underscore) character has the following effect:
 * <UL>
 * <LI> If there are several remaining input characters, the next input character
 * is placed in the result and the next character in the mask is processed.
 * <LI> If there is only one remaining input character, that character is placed in
 * the result and all subsequent insertion characters are replaced with
 * blanks.
 * <LI> If there are no remaining input characters, a blank is placed in the result
 * and all subsequent insertion characters are replaced with blanks.
 * </UL>
 * </UL>
 * <P><B>Example 1</B>
 * <p>This example illustrates the use of a right-justified edit mask to format a phone
 * number with an area code:
 * <PRE>
 *    $EDIT(6171234567,'(!+++)! >++-!++++','R','A')
 * </PRE>
 * results in the following output:
 * (617) 123-4567
 * <P><B>Example 2</B>
 * <P>If the same edit mask were used for a string that did not contain an area code,
 * as shown below:
 * <PRE>
 *    $EDIT(2344567,'(!+++)! >++-!++++','R','A')
 * </PRE>
 * the following output would result:
 * <PRE>
 *    234-4567
 * </PRE>
 * <P><B>Example 3</B>
 * <P>This example illustrates the use of a left-justified edit mask for formatting phone
 * numbers, some of which have extensions of two, three, or four digits:
 * <PRE>
 *    $EDIT(%PHONE,'!(+++!) +++!-+++ EXT ++++',,'A')
 * </PRE>
 * <P>The value of the input argument and the output that would result from using the
 * preceding example are listed in this table:
 * Input/Output
 * <DL compact>
 * <DT>61712345671111 <DD>(617) 123-4567 EXT 1111
 * <DT>2122344567 <DD>(212) 234-4567
 * <DT>516765432134 <DD>(516) 765-4321 EXT 34
 * </DL>
 * <P><B>Error conditions</B>
 * <p>Certain errors that can occur when using $EDIT produce the following results:
 * <UL>
 * <LI>A null string is returned if the input argument or edit mask is omitted, or if
 * the edit mask is invalid, or if data is incompatible with the edit type (for
 * example, alpha data when the edit mask is numeric).
 * <LI> The default for the type of editing indicated by the edit mask is used if the
 * justification option is invalid.
 * <LI> A string of # characters (with a length equal to the number of output
 * positions in the edit mask) is returned if a numeric editing overflow occurs
 * to the left of the decimal point.
 * </UL>
 * Other error conditions for $EDIT generate a Model 204 error message.
 */
function STRING $EDIT(STRING input,STRING mask,STRING justification,STRING EditType);

/**
 * The $EFORMAT function converts numeric values to exponent notation. 
 * <P>For a detailed discussion of exponent format refer to "Exponent notation"
 * in the manual.
 * @param value must contain the numeric value to be formatted. If this
 * argument is passed to $EFORMAT with a nonnumeric or invalid value,
 * $EFORMAT returns a zero.
 * @param SignificantDigits must contain a positive integer identifying the
 * number of significant digits to print. The default is 15. If this argument is
 * passed to $EFORMAT with an invalid value, $EFORMAT returns a null
 * string.
 * @param FractionalDigits (optional) must contain a positive integer identifying the
 * number of significant digits to print to the right of the decimal point. The
 * number of digits specified is always printed to the right of the decimal point,
 * even if the digits are zero.
 * If this argument is omitted, all significant digits are printed with one digit
 * placed to the left of the decimal point in the form hn.nn through nEnn. If this
 * argument is passed to $EFORMAT with an invalid value, $EFORMAT
 * returns a null string.
 * @example
 * <pre>
 * BEGIN
 * GET.FLOAT:    FIND ALL RECORDS FOR WHICH
 *                   FLOATFLD1 = 3444300E15
 *               END FIND
 *               FOR EACH RECORD IN GET.FLOAT
 *                   PRINT 'E FORMAT NUMBER IS ' WITH -
 *                  $EFORMAT(FLOATFLD1,5,2)
 *               END FOR
 * END
 * </pre>
 * results in this output:
 * <pre>
 *    E FORMAT NUMBER IS 344.43E19
 * </pre>
 * 
 * @return Returns the numeric value in the exponent notation specified.
 */
function STRING $EFORMAT(FLOAT value,INTEGER SignificantDigits,INTEGER FractionalDigits);

/**
 * The $ENCRYPT function performs a one-way encryption of a zero to eight-character
 * string.  
 * <p>$ENCRYPT accepts the second argument ( parameter) so that the same
 * source string can be encrypted to different strings in different systems.
 * 
 * @param textstr   The character string to encrypt.  If the length of this string is
 *   longer then 8 characters, the string is truncated.
 * @param parameter (optional) a positive integer greater than 0.  Defaults to 15.
 *                  <p>Note: You should use a parameter value of less than 1000 for best per-formance;
 *                  numbers significantly larger than 1000 can cause seri-ous
 *                  performance degradation.
 * @return Returns the input string encrypted in an 8 byte string. A null
 * string is returned and an error message is issued if a parameter of zero or a
 * negative value is specified.
 * <p><B>Example</B>
 * <PRE>
 *    $ENCRYPT($READINV('ENTER PASSWORD'),%PARAM)
 * </PRE>
 * <p>returns one encrypted value if %PARAM equals 28 and another value if
 * PARAM equals 18.
 */
function STRING $ENCRYPT(STRING textstr,INTEGER parameter=15);

/**
 * The $ENTER function provides efficient terminal dialogue with users of data
 * entry applications.
 * <P>$ENTER prompts the terminal operator with the value entered in the prompt
 * string argument.
 * <P>The operator enters a single line of input which is read by Model 204. This line
 * is parsed into individual values using the value of the separator argument as
 * the delimiter.
 * 
 * @param NumberOfValues
 *                   Indicates the number of values assigned by $ENTER.
 * @param PromptString
 *                   (optional) String expression to use as the prompt.  Defaults to 'ENTER DATA'
 * @param DefaultValue  (optional)If any values are omitted, the value specified
 *                   in the DefaultValue argument is assigned to the appropriate %variables. If
 *                   the DefaultValue argument is omitted, a single blank character is the
 *                   default.
 * @param Separator  (optional)must be a single character. If it is omitted, a
 * comma is used as the default separator. If an input value is longer than 255
 * characters, a warning message is issued and the value is truncated. The
 * input values are assigned in the order of %variables using the value of the
 * name prefix argument as follows:
 * <pre>
 *    %name prefix 01, %name prefix 02, %name prefix 03,...
 * </pre>
 * @param NamePrefix (optional) If the name prefix argument is omitted, the %variables are named %01,
 *                   %02, %03, and so on. All %variable names generated by $ENTER must
 *                   appear elsewhere in the request so that the variables can be allocated
 *                   during compilation.
 * @return If $ENTER completes successfully, it returns a value of 0. If it fails for any of
 * these reasons, $ENTER returns a value of 1 and prints an explanatory
 * message:
 * <UL>
 * <li> Too many values are included on the input line.
 * <li> The number of values argument is less than 1 or greater than 99.
 * <li> Required %variables were not allocated during compilation (a %variable
 * used in $ENTER does not appear elsewhere in the request).
 * </UL>
 * <p><B>Example 1</B>
 * <p>Suppose a request contains the following function call:
 * <PRE>
 *    %X = $ENTER(3, 'ENTER 3 VALUES', '99999' ,, 'ZZ')
 * </PRE>
 * The following prompt is displayed at the terminal:
 * <PRE>
 *    ENTER 3 VALUES
 * </PRE>
 * The user enters:
 * <PRE>
 *    A1,,C3
 * </PRE>
 * $ENTER returns a value of 0. This result is equivalent to the following:
 * <PRE>
 *    %ZZ01 = 'A1'
 *    %ZZ02 = '99999'
 *    %ZZ03 = 'C3'
 * </PRE>
 * <p><B>Example 2</B>
 * <PRE>
 *    %Y = $ENTER (4,,,'/',)
 * </PRE>
 * This default prompt is displayed:
 * <PRE>
 *    ENTER DATA
 * </PRE>
 * The user enters:
 * <PRE>
 *    ONE/TWO/THREE/FOUR
 * </PRE>
 * $ENTER returns a value of 0, which is equivalent to:
 * <PRE>
 *    %01 = 'ONE'
 *    %02 = 'TWO'
 *    %03 = 'THREE'
 *    %04 = 'FOUR'
 * </PRE>
 */
function STRING $ENTER(INTEGER NumberOfValues,
                       STRING PromptString='ENTER DATA',STRING DefaultValue=' ',
                       STRING Separator=',',STRING NamePrefix);

/**
 * @return 
 * The $ERRMSG function returns a variable length string of up to 79 characters
 * containing the prefix and text of the last counting error message or request
 * cancellation message received by the user.
 * A null value is returned if no counting error or request cancellation message
 * has been received since the beginning of the user's Model 204 session. Refer
 * to the Model 204 Messages Manual for more information on counting
 * messages. This function takes no arguments.
 * <P><b>Example</b>
 * <P>A sample $ERRMSG function with an ON ERROR unit follows.
 * <PRE>
 * BEGIN
 * ERROR.PROC:  ON ERROR
 *                 PRINT 'THE REQUEST IS ENDING'
 *                 PRINT 'THE LAST ERROR MESSAGE RECEIVED WAS:'
 *                 PRINT $ERRMSG
 *              END ON
 * GET.RECS:    FIND ALL RECORDS FOR WHICH
 *              AGENT = CASOLA
 *              END FIND
 *              FOR EACH RECORD IN GET.RECS
 *                  .
 *                  .
 *                  .
 *              END FOR
 * END
 * </PRE>
 */
function STRING $ERRMSG();

/**
 * The $FDEF function lets you access the attributes of a field from within a
 * Model 204 procedure.
 * 
 * @param FileExpression  
 * <pre>
 *    [FILE] filename [AT location]  
 * </pre>
 * <UL>
 * <LI>filename is a %variable or a literal name of the file. A file synonym name
 * can also be used. When filename=groupname the $FDEF function
 * assumes that the name passed is a file name, not a group name.
 * <LI> location is the name of the remote node where the file is located.
 * </UL>
 * @param FieldName String expression representing a field name
 * @return 
 * 
 * <P>$FDEF maps the attributes of a field, whose values can
 * then be read via an image similar to the ZFIELD image described below.
 * Unlike $DSCR, which $FDEF supplants, the attributes are
 * displayed in a readable fashion without parsing. $FDEF works only for files (not
 * groups).
 * <p>If the field specified in the $FDEF argument is not defined in the opened file
 * specified by filename, $FDEF returns a U (undefined) in the second image item
 * (DEFER.Y_N). If the file is not open, a U is returned in the second
 * (DEFER.Y_N) image item and an N is returned in the third (FRV.Y_N) image
 * item.
 * <p>The field code, which is returned in the 21st image item, is unique for each field
 * within a file. However, this value cannot remain constant for any one field over
 * time, and it cannot be the same for the same field name in different files. Field
 * names do not always hash to the same field codes because of deleted fields
 * and hash collisions. The field code which is returned in the ZFIELD image is the
 * same as that which appears in CCAJRNL RECTYPE=6 entries. This
 * information is valuable for CCA support in case you need to run REGENERATE
 * but cannot because you are missing one or more CCAJRNL datasets since
 * your last DUMP of the file.
 * <p><B>The ZFIELD image</B>
 * <p>An image is required by the $FDEF and $LSTFLD functions. The ZFIELD
 * image, which can give you complete field attribute information (see the $FDEF
 * example below), is provided on the Model 204 installation tape by CCA.
 * <p><B>Note</B>: When using ZFIELD, be aware that $FDEF output maps to the
 * image of ZFIELD. Therefore, do not change the order of the
 * image items in ZFIELD.
 * <p>The location of ZFIELD for your site is listed in this table:
 * <DL compact>
 * <DT>MVS<DD> The JCL library
 * <DT>VM<DD> The 2nd tape file (193) as an EXEC
 * <DT>VSE<DD> The JCL library
 * </DL>
 * <p><B>Example</B>
 * <p>In the example on the next page, you provide a field name and Model 204
 * displays output that indicates if the field is KEY or preallocated. If the field is
 * preallocated, Model 204 also displays the number of occurrences and the
 * length of the field. This procedure maps the $FDEF output to the ZFIELD image
 * shown on the following page). Therefore, if the field is KEY, then the KEY.Y_N
 * image item contains a 'Y'.
 * <pre>
 * PROCEDURE DISPFLD
 * OPEN DAILY
 * OPENC VEHICLES
 * 
 * BEGIN
 *       %FIELD IS STRING LEN 50
 *       %FIELD = $READ('ENTER FIELDNAME')
 * 
 *       **
 *       * include the ZFIELD proc and prepare the ZFIELD image
 *       **
 * 
 *       INCLUDE ZFIELD
 *       PREPARE IMAGE ZFIELD
 * 
 *       **
 *       * use the FDEF image item in ZFIELD to check the fieldname
 *       **
 * 
 *       %ZFIELD:FDEF = $FDEF('VEHICLES',%FIELD)
 *       IF %ZFIELD:KEY.Y_N = 'Y' THEN
 *           PRINT %FIELD ' IS KEY'
 *       ELSE
 *           PRINT %FIELD ' IS NOT A KEY FIELD'
 *       END IF
 *       IF %ZFIELD:OCCURS > '0' THEN
 *           PRINT %FIELD ' IS PREALLOCATED, WITH ' -
 *           %ZFIELD:OCCURS ' VALUES'
 *           PRINT 'THE LENGTH OF ' %FIELD ' IS ' %ZFIELD:LENGTH
 *       ELSE
 *           PRINT %FIELD ' IS NOT PREALLOCATED'
 *       END IF
 * END
 * </pre>
 * The following is the output produced by the procedure DISPFLD for the field
 * <pre>
 * DEDUCTIBLE:
 * INCLUDE DISPFLD
 * ??ENTER FIELD NAME
 * <B>DEDUCTIBLE</B>
 * DEDUCTIBLE IS KEY
 * DEDUCTIBLE IS PREALLOCATED WITH 1 VALUES
 * THE LENGTH OF DEDUCTIBLE IS 3
 * </pre>
 * <p>ZFIELD image for $FDEF and $LSTFLD
 * The following image can be used by the $FDEF and $LSTFLD functions. If you
 * write your own image, be aware that $FDEF maps to the locations of the image
 * items, rather than the names.
 * <pre>
 * IMAGE ZFIELD
 *    NAME           IS STRING LEN 255
 *    DEFER.Y_N      IS STRING LEN 1
 *    FRV.Y_N        IS STRING LEN 1
 *    KEY.Y_N        IS STRING LEN 1
 *    MANY.VALUED.Y_N IS STRING LEN 1
 *    CODED.Y_N      IS STRING LEN 1
 *    STRING.Y_N     IS STRING LEN 1
 *    NUMERIC.RANGE.Y_N IS STRING LEN 1
 *    INVISIBLE.Y_N  IS STRING LEN 1
 *    SECURED.Y_N    IS STRING LEN 1
 *    UPDATE.IN.PLACE.Y_N IS STRING LEN 1
 *    OCCURS.Y_N     IS STRING LEN 1
 *    FLOAT.Y_N      IS STRING LEN 1
 *    ORD.NUM.Y_N    IS STRING LEN 1
 *    ORD.CHAR.Y_N   IS STRING LEN 1
 *    PURE.DBCS.Y_N  IS STRING LEN 1
 *    MIXED.DBCS.Y_N IS STRING LEN 1
 *    UNIQUE.Y_N IS STRING LEN 1
 *    OCCURS.ONCE.Y_N IS STRING LEN 1
 *    FUTURE.EXPANSION IS STRING LEN 36
 *    FIELD.CODE     IS BINARY LEN 4 UNSIGNED
 *    ORDERED.Y_N    IS STRING LEN 1
 *    LENGTH         IS BINARY LEN 1 UNSIGNED
 *    LEVEL          IS BINARY LEN 1 UNSIGNED
 *    LRESERVE       IS BINARY LEN 1 UNSIGNED
 *    NRESERVE       IS BINARY LEN 1 UNSIGNED
 *    SPLITPCT       IS BINARY LEN 1 UNSIGNED
 *    NO.OF.IMMEDIATES IS BINARY LEN 1 UNSIGNED
 *    OCCURS         IS BINARY LEN 1 UNSIGNED
 *    PAD.CHAR       IS STRING LEN 1
 *    FDEF           IS STRING LEN 67 AT DEFER.Y_N
 *    BIN1           IS BINARY LEN 4 UNSIGNED
 *    BIN2           IS BINARY LEN 4 UNSIGNED
 *    BIN3           IS BINARY LEN 4 UNSIGNED
 *    BIN4           IS BINARY LEN 4 UNSIGNED
 *    LOOPVAR        IS STRING LEN 16 AT BIN1
 * END IMAGE
 * </pre>
 */
function STRING $FDEF(FILEEXPR FileExpression,STRING FieldName);

/**
 * The $FLOAT function assigns a 4-byte floating point number to a 4-byte string,
 * without any conversion. This function is intended for use in writing a floating
 * point value to a USE dataset. The $FLOAT function takes one argument
 * containing a numeric value. If the argument is omitted, a value of 0 is returned.
 * <p>Model 204 maintains 15 significant decimal digits of precision for 8-byte
 * floating-point numbers and 6 significant digits of precision for 4-byte floating-point
 * numbers. For an expanded discussion of rounding numbers, please refer
 * to the section "Mapping and precision adjustment" in the manual.
 * <p><B>Note</B>: CCA does not recommend using $FLOAT in new applications,
 * although this function is supported for compatibility reasons.
 * 
 * @param number 4-byte floating point number
 * @return  If the number argument is given, a 4-byte string floating point string is
 *    returned. Otherwise 0 is returned.
 */
function STRING $FLOAT(FLOAT number);

/**
 * The $FLOATD function assigns an 8-byte floating point number to an 8-byte
 * string, without any conversion. Like $FLOAT, this function is intended to be
 * output to a USE dataset. The $FLOATD function takes one argument
 * containing a numeric value.
 * <p><B>Note</B>: CCA does not recommend using $FLOATD in new applications,
 * although this function is supported for compatibility reasons.
 * 
 * @param number  8-byte floating point number
 * @return If the number argument is given, a 8-byte string floating point string is
 *    returned. Otherwise 0 is returned.
 */
function STRING $FLOATD(FLOAT number);

/**
 * The $FLSACC function, combined with the $FLSCHK function, allows a User
 * Language request to check for field-level security access violations before they
 * occur. This reduces evaluation-time errors and request cancellations, and it
 * helps to ensure that the files being updated are not left in a logically
 * inconsistent state ("Resolution of field types and levels" in the manual).
 * <p>$FLSACC can determine a user's access rights to a particular field or to all
 * fields in a file or group.
 * 
 * @param fieldname (optional) character string that is interpreted as the name of the field
 *                  whose access is being checked.
 *                  <p>If this argument is omitted or null, every field in the file or group specified in
 *                  the name argument is checked. In this case, the output string returned by
 *                  $FLSACC contains an access indication (S, R, U, A) only if that level of
 *                  access applies to every field in the file or group. This use of $FLSACC is
 *                  costly system overhead because all field descriptions must be examined.
 * @param FileExpression (optional) Controls the file or group context of the function.
 * <p>The format for this argument is:
 * <pre>
 *    FILE | [PERM | TEMP] GROUP] name [AT location]
 *     $CURFILE | $UPDATE]
 * </pre>
 *         <p>If access for the current file of a FOR loop is desired, $CURFILE can be
 *         used as the second argument. $UPDATE can be used to indicate the name
 *         of the update file in the current group. $CURFILE and $UPDATE are
 *         described in detail in "$CURFILE and $UPDATE functions" in the manual.
 *         For single file context, the field level security access rights are well defined.
 *         If a field name is specified in group context, $FLSACC returns the
 *         maximum access rights for the group. If the name argument is omitted or
 *         null, the context used for the check is the context of the statement that
 *         contains the function.
 * @return The function returns a character string representing the
 *         user's access rights to the specified field(s). If the field is not defined in the file
 *         or group, a null string is returned. The string normally contains a combination
 *         of the characters listed in this table:
 *         <DL compact>
 *         <DT>S<DD> SELECT access rights
 *         <DT>R<DD> READ access rights
 *         <DT>U<DD> UPDATE access rights
 *         <DT>A<DD> ADD access rights
 *         </DL>
 */
function STRING $FLSACC(STRING fieldname="",FILEEXPR FileExpression);

/**
 * The $FLSCHK function, combined with the $FLSACC function, allows a
 * request to check for field-level security access violations before they occur.
 * <p>$FLSCHK is designed for use with the IF statement and can determine whether
 * a given set of field-level security accesses is valid for a specified field or for all
 * fields in a file or group.
 * 
 * @param fieldname
 * @param access    the desired access or set of accesses; the argument can include:
 *                  <DL compact>
 *                  <DT>S<DD> SELECT access rights
 *                  <DT>R<DD> READ access rights
 *                  <DT>U<DD> UPDATE access rights
 *                  <DT>A<DD> ADD access rights
 *                  </DL>
 * @param FileExpression can be used to control the file or group context of
 *                  the function. The format for the filename argument is:
 * <pre>
 *    FILE | [PERM | TEMP] GROUP] name [AT location]
 *     $CURFILE | $UPDATE]
 * </pre>
 *         <p>If access for the current file of a FOR loop is desired, $CURFILE can be
 *         used as the second argument. $UPDATE can be used to indicate the name
 *         of the update file in the current group. $CURFILE and $UPDATE are
 *         described in detail in "$CURFILE and $UPDATE functions" in the manual.
 *         For single file
 *         context, the field level security access rights are well defined. In group
 *         context, this function returns a 1 if the indicated access would compile
 *         without error. If access for the current file of a FOR loop is desired,
 *         $CURFILE can be used as the third argument. If this argument is omitted
 *         or null, the context used for the check is the context of the statement
 *         containing the function.
 * @return This function returns a 1 if the specified set of accesses
 *         is valid.
 *         If the access argument contains an invalid character (not S, R, U, or A), a
 *         warning message is issued and 0 is returned. If a set of accesses is
 *         specified, such as SR, a 1 is returned only if all accesses in the set are
 *         allowed for the indicated field or fields.   In group
 *         context, this function returns a 1 if the indicated access would compile
 *         without error.
 */
function string $FLSCHK(STRING fieldname,STRING access,FILEEXPR FileExpression);

/**
 * 
 * @return 
 * The $FSTERR function returns a variable length string of up to 79 characters
 * that contains the prefix and the first counting error message or request
 * cancellation message you received since the last time that the count was reset
 * to zero. If Model 204 has not received a counting error or request cancellation
 * message since the beginning of your Model 204 session, $FSTERR returns a
 * null value.
 * <p>For more information about counting errors or request cancellation messages,
 * refer to the Model 204 Messages Manual. To return the most recent error
 * message, refer to the $ERRMSG function. $FSTERR is not available for Host
 * Language Interface applications. The $FSTERR function takes no arguments.
 * <p>The $FSTERR function requires an additional 88 bytes in the fixed portion of
 * the server.
 * <p><B>Example</B>
 * <p>An example of the $FSTERR function with an ON ERROR unit follows. For
 * more information, refer to "ON units" in the manual.
 * <pre>
 * BEGIN
 * FSTERR.PROC:  ON ERROR
 *                   PRINT 'THE REQUEST IS ENDING'
 *                   PRINT 'THE FIRST ERROR MESSAGE WAS:'
 *                   PRINT $FSTERR
 *               END ON
 * GET.RECS:     FIND ALL RECORDS FOR WHICH
 *                   AGENT = BLAKE
 *               END FIND
 *               FOR EACH RECORD IN GET.RECS
 *                   .
 *                   .
 *                   .
 *               END FOR
 * END
 * </pre>
 */
function STRING $FSTERR();



/**
 * @return
 * The $GETG function retrieves information stored by a {@link $SETG} function in the
 * same request or an earlier request.
 * <p>
 * Refer to "Using global variables to tailor a request" on page 20-12 for a detailed
 * explanation of global variables and examples of the $GETG function within a
 * request.
 *
 * @param global_var 
 * The $GETG function takes a global variable name as its one argument. The
 * global variable table is searched for a variable with the name given by the
 * argument. The value of the function is the value of the global variable if it is
 * found or a null string (two quotes with no space between them) if it is not found.
 * $GETG ('X') does not distinguish between the following situations:
 * <ul>
 * <LI> There is no variable with the name X in the table.
 * <li> There is a variable in the table with the name X whose value is a null string
 *      (a $SETG ('X','') that had been executed earlier).
 * </ul>
 */
function STRING $GETG(STRING global_var);


/**
 * @return
 * The $GETL function returns the line number of the current line on the page on
 * the user's terminal or on the output dataset specified by a USE command. The
 * first line on a page is line number 1 and is the line on which header 0 appears.
 * The current line is the line actually being printed if $GETL is invoked:
 * <ul>
 * <li> From a PRINT statement
 * <li> After a PRINT statement that ends with an ellipsis (...).
 * </ul>
 * Otherwise, the current line is the next line to be printed. The current line
 * becomes line 1 as soon as the bottom line of a page has been printed. $GETL
 * takes no arguments.
 */
function INTEGER $GETL();


/**
 * @return
 * The $GETP function returns the page number currently on the user's terminal
 * or on the output dataset specified by a USE command. When the current output
 * device is the normal device (no USE command is in effect), the value returned
 * by $GETP matches the current value of the OUTPNO parameter, which
 * indicates the current output page number. Otherwise, the value returned by
 * $GETP is the current page number on the USE dataset. $GETP takes no
 * arguments.
 */
function INTEGER $GETP();


/**
 * @return
 * The $GRMLOC function returns the location of a missing group member.
 * See the Parallel Query Option/204 User's Guide for more information on the
 * {@link $GRMLOC}, {@link $GRMNAME}, {@link $GRNLEFT}, and {@link $GRNMISS} functions.
 */
function STRING $GRMLOC();


/**
 * @return
 * The $GRMNAME function returns the file name of a missing group member.
 */
function STRING $GRMNAME();


/**
 * @return
 * The $GRNLEFT function returns the number of optional files that might fail
 * before the value of the MAXFAIL parameter is exceeded.
 */
function INTEGER $GRNLEFT();


/**
 * @return
 * The $GRNMISS function returns the number of missing group members.
 */
function INTEGER $GRNMISS();


/**
 * @return
 * The $GROUPFILES function returns the number of files in an open group,
 * or 0 if error or file context.  
 * <p>
 * Supports PERM/TEMP/GROUP/FILE/AT keywords. Supports file synonyms.
 *
 * @param file_or_group_context is a character string argument representing a group name.
 *
 * @example
 * <pre>
 * BEGIN
 * %GROUP-CONTEXT_STRING='PERM GROUP MYGROUP'
 * %X=$GROUPFILES(%GROUP_CONTEXT_STRING)
 * PRINT 'THERE ARE' WITH %X WITH ' FILES IN THE GROUP'
 * END
 * </pre>
 * Produces the following output:
 * <pre>
 * THERE ARE 5 FILES IN THE GROUP
 * </pre>
 */
function INTEGER $GROUPFILES(STRING file_or_group_context);


/**
 * @return
 * The $HPAGE function returns a string of special characters whose length is
 * equal to the value specified as the $HPAGE argument. $HPAGE is usually
 * used in a line replacing header 0 (see "Formatting page headers and trailers"
 * on page 6-14). When you use $HPAGE in a SET HEADER or SET TRAILER
 * statement, it is replaced by the current page number when the header or trailer
 * is printed.
 *
 * @example
 * This $HPAGE statement:
 * <pre>
 *    SET HEADER 1 'AUDIT REPORT' WITH 'PAGE' TO COLUMN 30 -
 *    WITH $HPAGE (2) TO COLUMN 33
 * </pre>
 * produces a header in the format:
 * <pre>
 *    AUDIT REPORT PAGE 13
 * </pre>
 * The number 13 is generated by Model 204. To set the value of the page
 * number to 0 or another value, use the {@link $SETP} function.
 */
function STRING $HPAGE();


/**
 * @return
 * The $HSH function lets you convert a string into a hash value, which is a
 * distinct numeric representation of a given string value. You can use $HSH to
 * build a memory-resident hash table to be used to join on keys without sorting
 * and merging.
 * 
 * @param string is an alphanumeric string or a string referenced by a VALUE IN statement.
 *
 * @example
 * <pre>
 * BEGIN
 * *
 * * INPUT CUSTOMER CONTROL DATA IMAGE:
 * *
 * IMAGE CUST_REC
 *    NAME IS STRING LEN 20
 *    RATE IS STRING LEN 8
 *    DISCOUNT IS STRING LEN 8
 * END IMAGE
 * *
 * * MEMORY-RESIDENT HASH TABLE ARRAY:
 * *
 * IMAGE CUST_ARRAY
 *    ARRAY OCCURS 500
 *       NAME IS STRING LEN 20
 *       RATE IS FLOAT
 *       DISCOUNT IS FLOAT
 *    END ARRAY
 * END IMAGE
 * *
 * PREPARE IMAGE CUST_REC
 * PREPARE IMAGE CUST_ARRAY
 * *
 * * OPEN INPUT DATASET
 * *
 * OPEN DATASET CUSTINFO FOR INPUT
 * *
 * READ IMAGE CUST_REC FROM CUSTINFO
 * REPEAT WHILE $STATUS = 0
 * *
 * * INDEX INTO HASH TABLE IS REMAINDER OF HASH OF KEY / SIZE OF
 * * TABLE
 * *
 *    %IDX = $MOD($HSH(%CUST_REC:NAME),500)
 *    IF %CUST_ARRAY:NAME(%IDX) EQ '' THEN
 *       %CUST_ARRAY:NAME(%IDX) = %CUST_REC:NAME
 *       %CUST_ARRAY:RATE(%IDX) = %CUST_REC:RATE
 *       %CUST_ARRAY:DISCOUNT(%IDX) = %CUST_REC:DISCOUNT
 *    ELSE
 * *
 * * HAVE A HASH CONFLICT, RETRY A FINITE NUMBER OF TIMES
 * *
 *       FOR %RETRY FROM 1 TO 5
 *          %IDX = $MOD($HSH(%IDX),500)
 *          IF %CUST_ARRAY:NAME(%IDX) EQ '' THEN
 *             %CUST_ARRAY:NAME(%IDX) = %CUST_REC:NAME
 *             %CUST_ARRAY:RATE(%IDX) = %CUST_REC:RATE
 *             %CUST_ARRAY:DISCOUNT(%IDX) = %CUST_REC:DISCOUNT
 *             JUMP TO READNEXT
 *          END IF
 *       END FOR
 *       PRINT 'MAKE THE HASH TABLE LARGER TO AVOID CONFLICTS'
 *       STOP
 *    END IF
 *
 * READNEXT:
 *    READ IMAGE CUST_REC FROM CUSTINFO
 * END REPEAT
 * *
 * * NOW FIND ORDER RECORDS, NO NEED TO SORT
 * *
 * FDORD: IN ORDERS FIND ALL RECORDS WHERE -
 *                     ORD DATE IS NUM IN RANGE FROM 89120 TO 89150
 *                     STATUS = 'SHIPPED'
 *                  END FIND
 * FORORD: FOR EACH RECORD IN FDORD
 *            %IDX = $MOD($HSH(CUST NAME))
 *            IF %CUST_ARRAY:NAME(%IDX) EQ CUST NAME THEN
 *               CALL PRINT_INVOICE
 *            ELSE
 * *
 * * HAVE A HASH CONFLICT, RETRY A FINITE NUMBER OF TIMES
 * *
 *            FOR %RETRY FROM 1 TO 5
 *               %IDX = $MOD($HSH(%IDX),500)
 *               IF %CUST_ARRAY:NAME(%IDX) EQ CUST NAME THEN
 *                  CALL PRINT_INVOICE
 *                  JUMP TO NEXTREC
 *               END IF
 *            END FOR
 *            PRINT 'CUSTOMER NAME NOT FOUND =' AND CUST NAME
 * NEXTREC:
 *         END FOR
 * END
 * </pre>
 */
function INTEGER $HSH(STRING string);


/**
 * $INCRG performs simple arithmetic on global variables. Global variables are
 * discussed in Chapter 20.
 * <p>
 * <b>How $INCRG works</b>
 * <p>
 * $INCRG adds the value specified in the increment argument to the global
 * variable specified in the global name argument and returns a completion code.
 * The $INCRG operation preserves up to 15 digits of precision. Both the global
 * value and the increment are treated as signed quantities. Thus, if the increment
 * is less than 0, the function performs subtraction.
 * <p>
 * Model 204 converts the global value set by $INCRG to floating point and then
 * converts it back to a string. Thus, any leading and trailing zeros, plus signs, and
 * internal spaces are lost. The decimal point is also lost unless it is followed by a
 * nonzero decimal digit before the 15th digit place. If the global variable does not
 * exist, $INCRG creates one with a value equal to the increment. If a value is not
 * specified as the decimal_places argument in the function call, the created
 * global variable have no decimal places.
 * <p>
 * $INCRG returns a completion code indicating the success or failure of the
 * operation, along with an explanatory message. Possible codes are:
 * <dl compact>
 * <dt><b>Code</b> <dd><b>Meaning</b>
 * <dt>0 <dd>$INCRG completed normally
 * <dt>1 <dd>Global value is not numeric
 * <dt>2 <dd>No room for new value of global (size of global can change after increment)
 * </dl>
 * <p>
 * <b>IF statements</b>
 * <p>
 * In an IF statement of the form "IF expression", the THEN clause is evaluated if
 * expression has any value other than 0. Thus, IF $INCRG ('X') THEN JUMP TO
 * ERROR.ROUTINE transfers control to the ERROR.ROUTINE statement on
 * either of the two possible error conditions. If different actions are to be taken for
 * each distinct condition, this technique is recommended:
 * <pre>
 *    JUMP TO (ERROR.TYPE1,ERROR.TYPE2) $INCRG ('X')
 * </pre>
 * In this case, no jump is taken if $INCRG completes successfully and returns 0.
 * 
 * @example
 * <pre>
 *    PRINT $INCRG ('GLOBAL')
 * </pre>
 * prints 0 if the operation is successful and increases the value of GLOBAL by 1.
 * <pre>
 *    PRINT $INCRG ('X', -.5)
 * </pre>
 * prints 0 if the operation is successful and decreases the value of global X by.5.
 * 
 * @param global_name must be specified as a string.
 * @param increment is an optional numeric value; the default value is 1.
 * @param decimal_places is optional and specifies the number of decimal places to be
 * preserved in the result of the operation. The fractional part of the result is
 * truncated (not rounded) or padded with zeros as appropriate. If this
 * argument is omitted, the $INCRG result has the same number of decimal
 * places as the original global value.
 *
 * @return completion code, 0 indicates success.
 */
function INTEGER $INCRG(STRING global_name,
                        INTEGER increment=1, INTEGER decimal_places=0);

/**
 * @return
 * $INDEX compares two character strings and returns a number equal to the first
 * position within the first string at which the second string appears.
 * 
 * @param haystack      character string to search
 * @param needle        string to search for
 * 
 * @example
 * <p>
 * $INDEX ('OTHER', 'THE') equals 2
 * $INDEX ('SAME', 'SAME') equals 1
 * </pre>
 * 
 * If the second string is not contained in the first or is a null string, zero is
 * returned:
 * <pre>
 * $INDEX ('SAME', 'OTHER') equals 0
 * $INDEX ('SOME', 'SOMEMORE') equals 0
 * $INDEX ('ABC', ") equals 0
 * </pre>
 * 
 * This request uses $INDEX to separate the last name from a field containing a
 * full name in the form "last name, first name":
 * <pre>
 * BEGIN
 * FIND.RECS: FIND ALL RECORDS FOR WHICH
 *               DATE OF BIRTH IS LESS THAN 660000
 *            END FIND
 *            FOR EACH RECORD IN FIND.RECS
 *               %LASTNAME = -
 *               $SUBSTR (FULLNAME, 1, -
 *               $INDEX (FULLNAME,',')-1)
 *               ADD LAST NAME = %LASTNAME
 *                .
 *                .
 * </pre>
 * 
 * @see $SCAN
 */
function INTEGER $INDEX(STRING haystack, STRING needle);


/**
 * @return
 * The $ITSOPEN function lets you determine whether a file is open. $ITSOPEN
 * only checks files, not groups of files. The return codes are:
 * <dl compact>
 * <dt>0 <dd>the file is not open
 * <dt>1 <dd>the file is open
 * </dl>
 *
 * @param name (optional) is a %variable or a literal name of the file or group. You
 * must enter the filename in uppercase. A file synonym name can also be used.
 * @param location (optional) If you do not enter a location (specifying a null argument), Model 204 uses the
 * reference context (at compile time) of the statement which calls the function.
 * <p>
 * The format for the $ITSOPEN function is:
 * <pre>
 * $ITSOPEN({[FILE] name [AT location]
 * | [PERM | TEMP] [GROUP] name})
 * </pre>
 *
 * @example
 * <pre>
 * BEGIN
 * %FILE IS STRING
 * %FILE = $READ('ENTER THE FILENAME')
 * IF $ITSOPEN(%FILE) THEN
 *    PRINT %FILE ' IS OPEN'
 * ELSE
 *    PRINT %FILE ' IS NOT OPEN'
 * END
 * </pre>
 */
function INTEGER $ITSOPEN(STRING name, STRING location='');


/**
 * @return
 * The $ITSREMOTE function (valid in PQO only) lets you determine whether a
 * file is remote or whether a group is scattered. The return codes are:
 * <dl compact>
 * <dt>0 <dd>the file is not remote or the group is not scattered
 * <dt>1 <dd>the file is remote or the group is scattered
 * </dl>
 *
 * @param name is a %variable or a literal name of the file name, file synonym or
 * group name. You must enter the filename in uppercase. If you specify a null for
 * name, Model 204 uses the file or group context at the compilation of the
 * statement containing the $function as the default argument.
 * @param location (optional) If you do not enter a location (specifying a null argument), Model 204 uses the
 * reference context (at compile time) of the statement which calls the function.
 * <p>
 * The format for the $ITSREMOTE function is:
 * <pre>
 * $ITSREMOTE({[FILE] name [AT location]
 * | [PERM | TEMP] [GROUP] name})
 * </pre>
 *
 * @example
 * <pre>
 * BEGIN
 * %NAME IS STRING
 * %NAME = $READ('ENTER THE FILE OR GROUP NAME')
 * IF $ITSREMOTE(%NAME) THEN
 *    PRINT %NAME ' IS REMOTE'
 * ELSE
 *    PRINT %NAME ' IS NOT REMOTE'
 * END
 * </pre>
 */
function INTEGER $ITSREMOTE(STRING name, STRING location='');


/**
 * The $JOBCODE function allows a request that is part of one step of a
 * Model 204 batch run to communicate with a subsequent step. $JOBCODE can
 * be used both to examine and to set a completion code by invoking $JOBCODE
 * with the desired completion code as its one argument.
 * <p>
 * The completion code must fall within the range 0-4095. If the specified
 * completion code exceeds 4095, Model 204 forces the completion code to
 * 4095. No message is output.
 * <p>
 * Model 204 returns the current step completion code and sets the completion
 * code to the specified value if that value is greater. You can examine the step
 * completion code without changing it by invoking $JOBCODE without an
 * argument or with a null argument.
 * <p>
 * <b>Using with Online runs</b>
 * <p>
 * You can include calls to $JOBCODE in the CCAIN stream. In Online sessions,
 * Model 204 maintains two return code values for each user:
 * <ul>
 * <li> Highest batch return code value received
 * <li> Highest Online value
 * </ul>
 * 
 * @return
 * When $JOBCODE is used to set the return code for a user, it sets both values.
 * The value returned from the function, however, is always the batch value.
 * <p>
 * When $JOBCODE was invoked by an Online user in V4R1.1 and earlier, it
 * always returned 0 and did not set the return code.
 * <p>
 * The $JOBCODE return codes set in an Online run are local to the user who
 * invoked $JOBCODE; they do not affect the return code for other users or for
 * the Model 204 Online.
 *
 * @param code    the desired completion code
 *
 * @example
 * In the following example the first $JOBCODE value, 9, returns a value of 16
 * because 9 is less that 16, so batch return code is not reset by $JOBCODE(9).
 * The second $JOBCODE value, 21, returns a value of 21 because 21 is greater
 * than 16, so batch return code was reset by $JOBCODE(21).
 * <pre>
 *    >MSGCTL M204.1030 RETCODEO=8 RETCODEB=16
 *    
 *    >@#$%^
 *    
 *    *** 1 M204.1030: INVALID MODEL 204 COMMAND
 *    
 *    >B;PRINT $JOBCODE(9);END
 *    
 *    16
 *    
 *    >B;PRINT $JOBCODE(21);END
 *    
 *    21
 * </pre>
 * See "BATCH2 facility" on page 18-63 for syntax details.
 * <p>
 * <b>Use to avoid completing jobs</b>
 * <p>
 * You can use $JOBCODE in conjunction with other functions to avoid
 * completing large jobs that would produce incorrect or unusable results.
 * Suppose a Model 204 run includes a PRINT ALL INFORMATION (PAI)
 * statement that causes all of the fields in a record to be output. A PAI statement
 * sometimes is used to dump the contents of a file before the file is reorganized.
 * After the PAI, new parameters can be specified and the file can be loaded
 * again.
 * <p>
 * The file manager often does this with the File Load utility (see the Model 204
 * File Manager's Guide for details). If the file being dumped has field level
 * security, it is possible for the PAI run to omit certain fields without issuing error
 * messages. The missing fields are those for which the user does not have
 * READ access. If the output from the PAI run is then reentered to a File Load
 * run, fields are lost. The following technique can be used to avoid this type of
 * problem.
 * <pre>
 * OPEN MYFILE
 * BEGIN
 *             IF $FLSCHK (,'R') THEN
 *                JUMP TO END.PROCESS
 *             END IF
 *             PRINT 'INVALID ACCESS TO FILE'
 *             PRINT 'STEP COMPLETION CODE WAS' AND -
 *                   $JOBCODE (16)
 *             PRINT 'IT MAY HAVE BEEN SET TO 16'
 *             STOP
 * END.PROCESS: IF $JOBCODE () THEN
 *                STOP
 *             END IF
 * FIND.RECS:  FIND ALL RECORDS
 *                .
 *                .
 *             END FIND
 * END
 * </pre>
 * A File Load step in the same job could be skipped if it were based on a nonzero
 * step completion code. If it is desirable to trigger an ABEND, $JOBCODE can
 * be used in conjunction with the SYSOPT parameter. The 64 (X'40') option for
 * the SYSOPT parameter forces an ABEND without a dump at termination, when
 * the step completion code is nonzero.
 */
function INTEGER $JOBCODE(INTEGER code);


/**
 * @return
 * $LANGSPC returns a string containing the binary value of the specified
 * character in the specified language. You can use $LANGSPC to scan user
 * input for a special character in a language independent manner.
 * 
 * @param charname is a string containing one of the following values:
 * <ul>
 * <li>AT
 * <li>BACKSLSH
 * <li>DOLLAR
 * <li>DQUOTE
 * <li>EXCLAMAT
 * <li>NOT
 * <li>RBRACE
 * <li>SHARP
 * <li>VERTICAL
 * </ul>
 * @param langname specifies which language to use to obtain the desired code point
 * for the specified character. If the name is not found in NLANG$, the request
 * is cancelled with an error message.
 * <p>
 * If a langname value of asterisk (*) is specified, the value of the Model 204
 * LANGUSER parameter determines the language. If no langname value is
 * specified, the default is US English (even when the LANGUSER parameter
 * value is not US).
 *
 * @example
 * In the following example, the %PATH variable (presumably supplied by the
 * user from the terminal) is searched for the backslash character, regardless of
 * its location in the user terminal's code table:
 * <pre>
 * %BACKSLASH IS STRING LEN 1
 * %BACKSLASH = $LANGSPC('BACKSLSH','*')
 * %DIR = $SUBSTR(%PATH, $INDEX(%PATH,%BACKSLASH)+1)
 * </pre>
 */
function STRING $LANGSPEC(STRING charname, STRING langname='');


/**
 * @return
 * $LANGSRT translates a given string according to the specified language into
 * a language-neutral binary string against which you can sort.
 * By determining whether one string is greater or less than another string, you
 * can use $LANGSRT to compare two strings. First apply $LANGSRT to the
 * strings and then compare them using the User Language GT and LT operators.
 * 
 * @param string is the original data to be translated into collating sequence.
 * @param langname is the name of one of the defined languages, specifying which
 * collating sequence to use. The request is cancelled with an error message
 * if the name is not found in NLANG$.
 * <p>
 * If a langname value of asterisk (*) is specified, the value of the Model 204
 * LANGUSER parameter determines the language. If no langname value is
 * specified, the default is U.S. English (even when the LANGUSER
 * parameter value is not US).
 * <p>
 * If the given string contains VARIANT characters, the returned string has
 * encoding information appended. If the encoding information causes the length
 * of the string to exceed 255 characters, only complete byte pairs are appended
 * to the string.
 * <p>
 * If no complete byte pairs can be appended, nothing is appended (not even the
 * encoding separator) and resulting string lengths can be 253, 254, or 255 bytes.
 */
function STRING $LANGSRT(STRING string, STRING langname='');


/**
 * @return
 * $LANGUST translates back to its original form a string previously translated by
 * $LANGSRT. This is useful for applications that maintain sorted arrays of data
 * and need to display the values.
 * 
 * @param string is the data in collating sequence to be translated back to its original
 * form.
 * @param langname is the name of one of the defined languages, specifying which
 * collating sequence to use. The request is cancelled with an error message
 * if the name is not found in NLANG$.
 * <p>
 * If a langname value of asterisk (*) is specified, the value of the Model 204
 * LANGUSER parameter determines the language. If no langname value is
 * specified, the default is U.S. English (even when the LANGUSER
 * parameter value is not US).
 * <p>
 * If encoding information has been truncated, either during $LANGSRT
 * processing or during subsequent expression evaluation, then $LANGUST
 * cannot return the exact string that was originally translated by $LANGSRT.
 */
function STRING $LANGUST(STRING string, STRING langname='');


/**
 * @return
 * The $LEN function determines the current length of the value of a STRING. The
 * $LEN function takes a fieldname, character literal, or %variable as its one
 * argument.
 * 
 * @param string    character string to measure length of
 * 
 * @example
 * <pre>
 *    $LEN(STATE)
 * </pre>
 * equals 4 if the STATE field of the current record contains OHIO.
 * <pre>
 *    $LEN (%NAME)
 * </pre>
 * equals 13 if the %NAME variable has a current value of Richard Smith.
 */
function STRING $LEN(STRING string);


/**
 * @return
 * The $LOWCASE function translates an uppercase or mixed case string into a
 * lowercase string. The translation affects only the letters A-Z. If the first
 * character in the string is alphabetic, the character is converted to uppercase.
 * 
 * @param string represents the string to be verified. string must be one of:
 * <ul>
 * <LI> A quoted literal.
 * <li> A %variable.
 * <li> An unquoted field name, in which case the current value of the field is
 * verified. In this case, the function call must be embedded in a FOR
 * EACH RECORD loop.
 * </ul>
 * @param language_name (optional) specifies the language to use. Options are:
 * <ul>
 * <li> Omitting this argument, which instructs Model 204 to perform the vali-dation
 * for U.S. English, even if the value of the LANGUSER parameter
 * is not 'US.'
 * <li> A quoted asterisk ('*'), which instructs Model 204 to use the value of the
 * LANGUSER parameter to determine which language to use.
 * <li> The quoted literal name of a valid language, for example: NLANGFR1
 * for French Canadian, Version 1. The request is cancelled with an error
 * message, if the name is not present in NLANG$.
 * </ul>
 *
 * @example
 * <pre>
 *    $LOWCASE('NAME AND ADDRESS')
 * </pre>
 * returns this value:
 * <pre>
 * name and address
 * </pre>
 */
function STRING $LOWCASE(STRING string, STRING language_name='');


/**
 * @return
 * The $LSTFLD function returns field names in alphabetical order and the field
 * description for each field in a file into an image. $LSTFLD requires that you
 * have an image prepared with which Model 204 can create the field description.
 * <dl compact>
 * <dt><b>Setting</b> <dd style="marginleft:50pt"><b>Meaning</b>
 * <dt>0 <dd style="marginleft:50pt">Success
 * <dt>1 <dd style="marginleft:50pt">End of field list reached
 * <dt>2 <dd style="marginleft:50pt">Requested file not available
 * <dt>3 <dd style="marginleft:50pt">VTBL full or sort not available
 * <dt>4 <dd style="marginleft:50pt">Error occurred during function processing
 * </dl>
 * @param filename (required) is the name of the file that contains the fields. A file
 * synonym name can also be used. If you do not enter a location, specifying
 * a null argument, Model 204 uses the reference context (at compile time) of
 * the statement which calls the function. When filename=groupname the
 * $LSTDEF function assumes that the name passed is a file name, not a
 * group name.
 * @param imagename (required) is the name of the image where the information is to
 * return.
 * @param loopvar (required) is the loop variable of the image. You must initialize the
 * loop variable (as in the sample image shown with the {@link $FDEF} function)
 * before invoking $LSTFLD. The value returned in loopvar is used the next
 * time $LSTFLD is invoked to retrieve subsequent field names.
 * <p>
 * Note: Like {@link $LSTPROC}, changing any of the loop control information in
 * the $LSTFLD loop variable after the image is initialized is not
 * allowed and might cause the run to snap.
 * <p>
 * <b>The ZFIELD image</b>
 * <p>
 * An image is required by the {@link $FDEF} and $LSTFLD functions. The ZFIELD
 * image is provided on the Model 204 installation tape. It can give you complete
 * field attribute information; see the $FDEF discussion on page 27-45. The size
 * of the name field for the ZFIELD image is 255 bytes. The location of ZFIELD for
 * your site is listed in this table:
 * <dl compact>
 * <dt><b>Operating system</b> <dd style="marginleft:100pt"><b>Storage location of the ZFIELD image</b>
 * <dt>MVS <dd style="marginleft:100pt">The JCL library
 * <dt>VM  <dd style="marginleft:100pt">The 2nd tape file (193) as an EXEC
 * <dt>VSE <dd style="marginleft:100pt">The JCL library
 * </dl>
 * 
 * @example
 * In this example, the procedure DFIELDS displays the name and definition of
 * each field in the file specified by %FILE.
 * <pre>
 * PROCEDURE DFIELDS
 * B
 * **
 * * include ZFIELD IMAGE as defined for $FDEF*
 * **
 * PRINT 'DFIELDS STARTS'
 * %FILE = '??FILE'
 * NP
 * PREPARE ZFIELD
 * %ZFIELD:BIN1 = 0
 * %ZFIELD:BIN2 = 0
 * %ZFIELD:BIN3 = 0
 * %ZFIELD:BIN4 = 0
 * %X = 0
 * REPEAT WHILE %X = 0
 *    %X = $LSTFLD(%FILE, 'ZFIELD',%ZFIELD:LOOPVAR)
 *    IF %X = 0 THEN
 *       PRINT %ZFIELD:NAME
 *       PRINT %ZFIELD:FDEF
 *    END IF
 * END REPEAT
 * PRINT '-- END OF FIELDS RC=' %X
 * END
 * END PROCEDURE
 */
function STRING $LSTFLD(STRING filename, STRING location='', STRING imagename='', VAR loopvar);


/**
 * @return
 * $LSTPROC returns the following procedure information, which is stored in the
 * procedure dictionary:
 * <ul>
 * <li> Procedure name
 * <li> Date and time of last update
 * <li> ID of last user to update the procedure
 * <li> Length of the procedure (in bytes)
 * <li> Procedure security class (if available)
 * <li> Procedure file (if in multiple procedure file group context)
 * </ul>
 * <p>
 * <b>Status codes</b>
 * <p>
 * In addition to storing procedure information in an image, $LSTPROC returns a
 * status code that has one of these values:
 * <dl compact>
 * <dt><b>Code</b> <dd><b>Meaning</b>
 * <dt>0 <dd>$LSTPROC executed successfully.
 * <dt>1 <dd>The end of the procedure dictionary has been reached
 *           (there are no more procedure names to process).
 * <dt>2 <dd>The specified procedure is not available.
 * <dt>4 <dd>An error was encountered during $LSTPROC processing.
 * </dl>
 * 
 * @param imagename (required) specifies the name of the image into which the
 * information should be returned. The items that must be defined in the image
 * are listed below along with the data type and length of each item. In
 * addition, the position of each item is provided for use with the AT clause
 * where applicable.
 * <pre>
 * <b>Item              Type     Length   Position</b>
 * Loop variable        BINARY   4        1
 * Date                 PACKED   4        5
 * Time                 STRING   8        9
 * Length               BINARY   4        17
 * Security class       BINARY   1        21
 * Procedure name       STRING   255      22
 * Procedure file name  STRING   8
 * User ID              STRING   10
 * </pre>
 * <p>
 * For example:
 * <pre>
 * IMAGE PROCS
 *    LOOPVAR IS BINARY LEN 4
 *    DATE IS PACKED LEN 4
 *    TIME IS STRING LEN 8
 *    LENGTH IS BINARY LEN 4
 *    CLASS IS BINARY LEN 1
 *    NAME IS STRING LEN 255
 *    FILE IS STRING LEN 8
 *    USERID IS STRING LEN 10
 * END IMAGE
 * </pre>
 * <p>
 * The procedure file name and the user ID are both optional. If they are not
 * specified, they are not filled in by default values. If the user ID is included,
 * however, the file name must also be included.
 * <p>
 * If the image length is not increased, $LSTPROC executes when multiple
 * procedure files have been specified, but does not return file information for
 * each procedure or the user ID.
 * @param procname is the procedure for which information should be obtained. The
 * value of procname must be the name of a permanent procedure. If this
 * argument is omitted or null, information about the next procedure is
 * returned. You must specify this argument if the alias flag argument has a
 * value of 1.
 * @param loop variable is an image item that specifies where to begin the search in
 * the procedure dictionary. Because each invocation of $LSTPROC returns
 * information for only one procedure, this variable is used to control repeated
 * $LSTPROC calls. The loop variable must be the first item in the image. The
 * variable can have one of the following values:
 * <ul>
 * <li> A null value, if a procedure name is specified.
 * <li> 0, for the first iteration of a loop extracting data on all procedures.
 * <li> The value of loop variable returned by the previous iteration through the
 * loop, if data for the next procedure in the procedure dictionary is being
 * requested.
 * </ul>
 * You must not modify loop variable once it is initially set to 0; modifications
 * might result in snaps. A loop variable must be specified if one of the
 * following conditions exist:
 * <ul>
 * <li> A procname argument is not specified.
 * <li> The alias flag argument has a value of 1 (aliases is retrieved).
 * </ul>
 * @param flag (optional) specifies that alias names should be obtained for the
 * specified procedure. The value for the alias flag is 1 to obtain aliases. One
 * alias is returned for each $LSTPROC execution.
 * @param filename (optional) specifies the name of the file or group that contains the
 * procedure dictionary. If this argument is omitted, the current file at the time
 * that the request was compiled is used.
 * @param pattern (optional) lets you retrieve procedures that match the pattern
 * specified using the standard pattern matching rules beginning on "Pattern
 * matching" on page 4-19.
 *
 * @example
 * <li> For files created prior to Release 8.1, only the procedure name and security
 * class are provided. An image must be defined earlier in the request in order
 * to receive the information returned by $LSTPROC. For more information on
 * image definition, refer to "Defining an image" on page 17-6.
 * <li> $LSTPROC applies to local files only; it is not valid in remote context.
 * <li> For a file with a procedure stored in it that was created using Model V3R2.1
 * or later, then opened under Model 204 V4R1.0 or later with {@link $SYSDATE} set
 * to January 1, 2000 (or later), and the procedure is changed, the date
 * returned includes the century--in this example, 100001, in the cyyddd
 * format.
 * 
 * <p>
 * This request retrieves and prints all procedure names in the current file:
 * <pre>
 * BEGIN
 *    IMAGE PROC
 *       LOOPVAR IS BINARY LEN 4
 *       DATE IS PACKED LEN 4
 *       TIME IS STRING LEN 8
 *       LENGTH IS BINARY LEN 4
 *       CLASS IS BINARY LEN 1
 *       NAME IS STRING LEN 255
 *       FILE IS STRING LEN 8
 *       USERID IS STRING LEN 10
 *    END IMAGE
 *    PREPARE PROC
 *    REPEAT WHILE $LSTPROC('PROC',,%PROC:LOOPVAR) = 0
 *       PRINT %PROC:NAME
 *    END REPEAT
 * END
 * </pre>
 * <p>
 * This request retrieves alias names for a specified procedure:
 * <pre>
 * IMAGE PROCINFO
 *    LOOPVAR IS BINARY LEN 4
 *    DATE IS PACKED LEN 4
 *    TIME IS STRING LEN 8
 *    LENGTH IS BINARY LEN 4
 *    CLASS IS BINARY LEN 1
 *    NAME IS STRING LEN 255
 *    FILE IS STRING LEN 8
 *    USERID IS STRING LEN 10
 * END IMAGE
 * .
 * .
 * %PROCINFO:LOOPVAR = 0
 * GETALIAS: IF $LSTPROC('PROCINFO','MYPROC',%PROCINFO:LOOPVAR,1) = 0
 *           THEN
 *              PRINT %PROCINFO:NAME
 *           END IF
 * .
 * .
 * </pre>
 * <p>
 * This request retrieves procedures in a multiple procfile group that match a
 * pattern specified by the user:
 * <pre>
 * BEGIN
 * IMAGE PROCS
 *    LOOPVAR IS BINARY LEN 4
 *    DATE IS PACKED LEN 4
 *    TIME IS STRING LEN 8
 *    LENGTH IS BINARY LEN 4
 *    CLASS IS BINARY LEN 1
 *    NAME IS STRING LEN 255
 *    FILE IS STRING LEN 8
 *    USERID IS STRING LEN 10
 * END IMAGE
 * %PAT = '??PAT'
 * NEW PAGE
 * PREPARE PROCS
 * PRINT ' PROCEDURE NAME DATE TIME LENGTH -
 *       USERID CLASS' WITH ' FILE'
 * REPEAT WHILE $LSTPROC('PROCS',,%PROCS:LOOPVAR) = 0
 *    IF %PROCS:NAME IS LIKE %PAT THEN
 *       %DATE = $DATECNV('YYDDD','MM/DD/YY',%PROCS:DATE)
 *       PRINT %PROCS:NAME AND %DATE AT 25 AND %PROCS:TIME -
 *          AND %PROCS:LENGTH TO 50 AND %PROCS:USERID AT 52 -
 *          AND %PROCS:CLASS AT 68 -
 *          AND %PROCS:FILE AT 63
 *    END IF
 * END REPEAT
 * PRINT '-- END OF LIST FOR PATTERN = ' %PAT
 * END
 * END PROCEDURE
 * </pre>
 */
function INTEGER $LSTPROC(STRING imagename, STRING procname='',
                          VAR loop_variable=0, INTEGER alias_flag,
                          STRING filename='', STRING pattern='');

/**
 * The $MISGRUP function is used with the ON units ON MISSING FILE and ON
 * MISSING MEMBER.
 * 
 * @example 
 * The following is an example of an ON MISSING FILE unit that uses the
 * the {@link $MISGRUP}, {@link $MISLOC}, {@link $MISNAME}, and
 * {@link $MISNUM} functions:
 * <pre>
 * ON MISSING FILE
 *    %X = $MISGRUP
 *    IF %X = '' THEN
 *       * THIS IS FILE CONTEXT BECAUSE $MISGRUP RETURNED NULLS
 *       PRINT 'MISSING FILE' AND $MISNAME AND 'AT' AND $MISLOC
 *    ELSE
 *       PRINT 'MISSING GROUP' AND %X AND 'FILES FOLLOW:'
 *       FOR %I FROM 1 TO $MISNUM BY 1
 *          PRINT $MISNAME(%I) AT 13 AND 'AT' AND $MISLOC(%I)
 *      END FOR
 *    END IF
 * END ON
 * </pre>
 * @return It returns the group name if the error occurred in group
 *         context, or null if the error occurred in file context.
 */
function STRING $MISGRUP();


/**
 * The $MISLOC function is used with the ON units ON MISSING FILE and ON
 * MISSING MEMBER.
 *
 * @return It returns the location of a missing member or file. See the
 * example given for "{@link $MISGRUP}".
 */
function STRING $MISLOC();


/**
 * The $MISNAME function is used use with the ON units ON MISSING FILE and
 * ON MISSING MEMBER.
 *
 * @return It returns the file name of a missing member or file.
 * See the example given for "{@link $MISGRUP}".
 */
function STRING $MISNAME();


/**
 * The $MISNUM function is used with the ON units ON MISSING FILE and ON
 * MISSING MEMBER.
 *
 * @return It returns the number of files that failed in the group. See
 * the example given for "{@link $MISGRUP}".
 */
function STRING $MISNUM();


/**
 * The $MISSTMT function is used with the ON units ON MISSING FILE and ON
 * MISSING MEMBER.
 * 
 * @return  It returns the statement that caused the ON unit to be entered.
 * The possible return values (statement names) of $MISSTMT are:
 * <ul>
 * <li>ADD
 * <li>BACKOUT
 * <li>CHANGE
 * <li>CLEAR LIST
 * <li>COMMIT
 * <li>COUNT
 * <li>DELETE ALL RECORDS
 * <li>DELETE EACH
 * <li>DELETE FIELD
 * <li>DELETE RECORD
 * <li>FIND ALL VALUES
 * <li>FILE
 * <li>FIND
 * <li>FOR
 * <li>FOR EACH VALUE
 * <li>FOR RECORD NUMBER
 * <li>INSERT
 * <li>PLACE RECORD
 * <li>PLACE RECORDS
 * <li>RELEASE RECORDS
 * <li>RELEASE ALL RECORDS
 * <li>REMOVE RECORD
 * <li>REMOVE RECORDS
 * <li>SORT
 * <li>SORT VALUES
 * </ul>
 */
function STRING $MISSTMT();


/**
 * @return
 * The $MOD function returns the remainder that results when the first argument
 * is divided by the second argument (the first argument modulo the second
 * argument). Each argument is first rounded to an integer. $MOD (X,0) is defined
 * to be X.
 *
 * @example
 * <pre>
 * $MOD (5,3) = 2.
 * </pre>
 * @example
 * <pre>
 * IF $MOD (Z,2) THEN PRINT 'ODD'
 * </pre>
 * prints ODD only if the value of the field Z is odd.
 *
 * @param x             number to be divided
 * @param y             divisor
 */
function INTEGER $MOD(INTEGER x, INTEGER y);


/**
 * @return
 * The $OCCURS function interprets a character string argument as a field name
 * in the following manner:
 * <ul>
 * <LI>In file context, $OCCURS returns 0 if the field description in the current file
 * containing the specified field does not include the OCCURS field attribute.
 * $OCCURS returns a number representing the number of specified
 * occurrences if the field has OCCURS in its description.
 * <LI>In group context, $OCCURS returns 0 only when the field is described
 * without an OCCURS attribute in every file making up the group. Otherwise,
 * the function returns the minimum OCCURS specification included in all of
 * the files.
 * <LI>If the field specified as the $OCCURS argument is not defined in the current
 * file or group, $OCCURS returns a value of -1.
 * </ul>
 * @example
 * <code>$OCCURS ('AGENT')</code>
 * equals 1 if the description of AGENT contains OCCURS 1.
 *
 * @param field          field description
 */
function INTEGER $OCCURS(STRING field);


/**
 * The $ONEOF function is a table lookup function that can
 * replace a series of IF conditions.
 *
 * @param item          an element that might be in set.
 * @param set           one or more items
 * @param delimiter     (optional) the character used to separate the set items.
 * 
 * @return true or false
 *
 * @example
 * <pre>
 * $ONEOF('MALE', 'FEMALE/MALE','/') equals 1
 * $ONEOF('GRAY','BLACK*WHITE*GRAY','*') equals 1
 * </pre>
 * <li>If the third argument is omitted, a semicolon is assumed to be the delimiter
 * used in the second argument. For example:
 * <pre>
 * $ONEOF('FEMALE', 'FEMALE;MALE') equals 1
 * </pre>
 * <LI>If the second argument is null, or if the first argument is not an element of
 * the second argument, 0 (false) is returned. For example:
 * <pre>
 * $ONEOF('BOY','FEMALE;MALE') equals 0
 * $ONEOF(",'FEMALE;MALE') equals 0
 * $ONEOF('BOY',") equals 0
 * </pre>
 * <LI>You can enter null values as the following examples show.
 * <pre>
 * $ONEOF(",';FEMALE;MALE') equals 1
 * $ONEOF(",'FEMALE;;MALE') equals 1
 * $ONEOF(",'FEMALE;MALE;') equals 1
 * </pre>
 * <LI>If a long string of values is used frequently, a special record containing
 * those values can be useful. In the following example, a record is created
 * with a field consisting of a list of departments. The list is used in the second
 * request to locate and process records for which the department is not
 * known.
 * <pre>
 * BEGIN
 * DECLARE %DEPT STRING LEN 50
 *             STORE RECORD
 *                TABLE = VALS
 *                DEPT VALS = DEPT1/DEPT2/DEPT3/etc.
 *             END STORE
 * END
 *   .
 *   .
 * BEGIN
 * FIND.RECS: FIND ALL RECORDS FOR WHICH
 *               TABLE = VALS
 *            END FIND
 *            FOR EACH RECORD IN FIND.RECS
 *               %DEPT = DEPT VALS
 *            END FOR
 * PAY.RECS: FIND ALL RECORDS FOR WHICH
 *              TYPE = PAYROLL
 *           END FIND
 *           FOR EACH RECORD IN PAY.RECS
 *           IF NOT $ONEOF(DEPT,%DEPT,'/') THEN
 *            .
 *            .
 * </pre>
 */
function INTEGER $ONEOF(STRING item,STRING set,STRING delimiter=' ');


/**
 * The $PACK function returns the packed decimal representation of the
 * character string. $PACK is used as an item in an assignment to a %variable
 * that is written to a sequential USE dataset. $PACK should not be used as an
 * operand in an arithmetic expression, because the value returned cannot be
 * correctly interpreted as a number.
 * 
 * @param value     is a character string that can be a field name, a %variable, or any type
 *                  of string expression.
 * @param precision is the number of digits required in the number to be returned. You
 *                  must specify the precision.
 * @param scale     (optional) specifies the number of digits to be returned to the right of the decimal
 *                  point. The scale argument is optional. If the scale argument is omitted, the
 *                  returned result is an integer.
 * @param UNSIGNED  (optional) specifies that the packed decimal data has a sign code of X'F'
 *                  regardless of the sign of the data value. The UNSIGNED argument is
 *                  optional. If the UNSIGNED argument is omitted, the data contains the
 *                  appropriate code for the sign of the data value.
 * @return
 *         Model 204 pads the result with leading integer or trailing fractional zeros as
 *         appropriate. If the integer portion of the value string is too long, or if the value
 *         is nonnumeric, $PACK returns binary ones. Model 204 interprets the value
 *         returned by $PACK as a character string.
 *
 * @example 
 * If the user were to specify these statements:
 * <pre>
 * %X = 123.4
 * %A = $PACK(%X,8,3,'UNSIGNED')
 * </pre>
 * the result in %A would be X'0123400F'. The result would be identical if %X
 * were assigned a value of -123.4.
 */
function STRING $PACK(STRING value,INTEGER precision=0,INTEGER scale=0,INTEGER UNSIGNED);


/**
 * The $PAD function allows padding to the left with a designated character. The
 * $PAD function takes three arguments and returns a character string of the
 * length specified by the value of the third argument. The resulting string contains
 * the first argument, right-justified, and padded with the character indicated in the
 * second argument. The length argument is rounded if it is not an integral value.
 * 
 * @param s        input character string to pad out
 * @param pad_char character to use for padding, default is space
 * @param length   number of characters to pad string out to
 *
 * @return character string padded to the left with 'pad_char'
 * @see $PADR
 *
 * @example 
 * <pre>
 * $PAD('55449825','0',9) equals '055449825'
 * $PAD('123.65','*',8) equals '**123.65'
 * $PAD('123.65','*',7.66) equals '**123.65'
 * </pre>
 * <li> If the value of the length argument is greater than 255, 255 is used.
 * <li> If the value of the length argument is not greater than zero, a null string is
 * returned.
 * <li> If the second argument contains more than one character, the first
 * character in the string is the one used for padding. For example:
 * <pre>
 * $PAD('123.65','*4',8) equals '**123.65'
 * </pre>
 */
function STRING $PAD(STRING s, STRING pad_char, INTEGER length);


/**
 * The $PADR function allows padding to the right with a designated character.
 * $PADR works exactly like {@link $PAD} with the exception that
 * $PAD pads to the left, while $PADR pads to the right.
 *
 * @param s        input character string to pad out
 * @param pad_char character to use for padding, default is space
 * @param length   number of characters to pad string out to
 *
 * @return character string padded to the right with 'pad_char'
 * @see $PAD
 *
 * @example
 * <pre>
 * $PADR('123.65','*',9) equals '123.65***'
 * </pre>
 */
function STRING $PADR(STRING s, STRING pad_char, INTEGER length);


/**
 * The $RDPROC function sequentially retrieves the lines of a User Language
 * procedure that is stored in a Model 204 file. The lines of the User Language
 * procedure can reside in a file or in a group. A group can contain a single
 * procedure file or multiple procedure files. Multiple procedure files are searched
 * in the order in which they appear in the DEFINE GROUP command.
 * <p>
 * You can also read temporary procedures by specifying the procedure number,
 * for example, 0, -1, or -2, in place of the procedure name. An input file is not
 * required.
 * $RDPROC applies to local files only; it is not valid in remote context.
 * 
 * @param option        The four options for $RDPROC are:
 *                      <dl compact style="marginleft:10pt">
 *                      <dt><b>Option</b><dd style="marginleft:50pt"><b>Action</b></dd>
 *                      <dt>OPEN <dd style="marginleft:50pt">Locates and locks a procedure
 *                      <dt>GET <dd style="marginleft:50pt">Reads a line from a procedure
 *                      <dt>CLOSE <dd style="marginleft:50pt">Explicitly unlocks the procedure at any time
 *                      <dt>LINEND <dd style="marginleft:50pt">Reads a line end character from a procedure
 *                      </dl>
 * @param fgname_ctlid fgname is the name of the file or group that contains the procedure.
 *                      The format of fgname is:
 *                      <pre>
 *                      [[[TEMP | PERM] GROUP] | [FILE]] identifier
 *                      </pre>
 *                      where identifier is the name of the group or file.
 *                      <p>
 *                      ctlid is the integer ID of an internally maintained control ID that is assigned
 * @param procname (optional) the name of a procedure.
 * @return the next line of the procedure (null if end-of-procedure is reached).
 *
 * @example
 * <b>Single request:</b>
 * <p>
 * You must open and read a procedure within one request, without leaving the
 * request. $RDPROC does not support reading temporary procedures.
 * $RDPROC holds a share lock on the procedure while reading it, which prevents
 * other users from modifying the procedure. $RDPROC unlocks the procedure
 * automatically when it reads end-of-procedure.
 * <p>
 * The $RDPROC function uses 336 bytes of STBL and 8 bytes per $RDPROC
 * level (you can nest $RDPROC up to five levels).
 * <p>
 * <b>Syntax for locating and locking a procedure</b>
 * <p>
 * The format for the $RDPROC function to locate and lock a procedure is:
 * <pre>
 *    ctlid = $RDPROC('OPEN', fgname, procname)
 * </pre>
 * where:
 * <li><CODE>ctlid</CODE> is the integer ID of an internally maintained control field that is passed
 * into $RDPROC for GET, LINEND, and CLOSE processing.
 * <li><CODE>fgname</CODE> is a name of the file or group that contains the procedure. The
 * format of fgname is:
 * <pre>
 * [[[TEMP | PERM] GROUP] | [FILE]] identifier
 * </pre>
 * where identifier is the name of the group or file.
 * <li><CODE>procname</CODE> is the name of a procedure.
 * Note: With $RDPROC, you can open up to six procedures concurrently.
 * <p>
 * <b>Syntax for reading a line from a procedure</b>
 * <p>
 * The format for the $RDPROC function to read a line from a procedure is:
 * <pre>
 *    text = $RDPROC('GET', ctlid)
 * </pre>
 * where:
 * <li><CODE>text</CODE> is the next line of the procedure (null if end-of-procedure is reached).
 * <li><CODE>ctlid</CODE> is the integer ID of an internally maintained control ID that is assigned
 * during OPEN processing.
 * <p>
 * <b>Syntax for closing and unlocking a procedure</b>
 * <p>
 * The format for the $RDPROC function to close and unlock a procedure is:
 * <pre>
 *    text = $RDPROC('CLOSE', ctlid)
 * </pre>
 * where:
 * <li><CODE>text</CODE> is set to the null string.
 * <li><CODE>ctlid</CODE> is the integer ID of an internally maintained control ID that is assigned
 * during OPEN processing.
 * <p>
 * <b>Syntax for reading a line end from a procedure</b>
 * <P>
 * The format for the $RDPROC function to read a line-end character from a
 * procedure is:
 * <pre>
 *    text = $RDPROC('LINEND', ctlid)
 * </pre>
 * where:
 * <li><CODE>text</CODE> is the value of the line-end character parameter in effect when the
 * procedure was saved. By default, this is a semicolon (;).
 * <li><CODE>ctlid</CODE> is the integer ID of an internally maintained control ID that is assigned
 * during OPEN processing.
 * <P>
 * <b>How $RDPROC works</b>
 * <p>
 * Possible return status settings are summarized in this table:
 * <dl compact style="marginleft:10pt">
 * <dt><b>Setting</b> <dd style="marginleft:50pt"><b>Meaning</b>
 * <dt>0 <dd style="marginleft:50pt">Normal completion (a procedure line was read; more lines follow)
 * <dt>1 <dd style="marginleft:50pt">End-of-procedure reached (no more procedure lines exist)
 * <dt>2 <dd style="marginleft:50pt">Error occurred (see {@link $STATUSD} settings)
 * </dl>
 * If the completion status is 2 and indicates that an error occurred or that the EOP
 * was read, the procedure is automatically closed. A subsequent $RDPROC
 * CLOSE call is unnecessary and returns this message:
 * <pre>
 * $STATUS=2 / $STATUSD=11 ( invalid ctlid value)
 * </pre>
 * <p>
 * <b>$STATUSD setting</b>
 * <p>
 * The {@link $STATUSD} setting can be one of the settings
 * summarized in the following table:
 * <dl compact style="marginleft:10pt">
 * <dt><b>Setting</b> <dd style="marginleft:50pt"><b>Meaning</b>
 * <dt>1 <dd style="marginleft:50pt">Argument 1 is missing or null.
 * <dt>2 <dd style="marginleft:50pt">Argument 2 is missing or null.
 * <dt>3 <dd style="marginleft:50pt">Argument 3 is missing or null
 * <dt>4 <dd style="marginleft:50pt">Argument 1 must be OPEN, GET, CLOSE, or LINEND.
 * <dt>5 <dd style="marginleft:50pt">Invalid context specification in argument.
 * <dt>6 <dd style="marginleft:50pt">GROUP has no procedure file.
 * <dt>7 <dd style="marginleft:50pt">Could not lock on specified procedure.
 * <dt>8 <dd style="marginleft:50pt">Could not find procedure or access not allowed.
 * <dt>9 <dd style="marginleft:50pt">(unassigned)
 * <dt>10 <dd style="marginleft:50pt">Maximum number of procedures (five) are already open.
 * <dt>11 <dd style="marginleft:50pt">Ctlid contains an invalid value.
 * </dl>
 * @example 
 * <pre>
 * BEGIN
 * DECLARE %PROC IS STRING LEN 50
 * *       USE LEN 19 BELOW TO ALLOW FOR 'TEMP GROUP XXXXXXXX'
 * DECLARE %FILE IS STRING LEN 19
 * DECLARE %TEXT IS STRING LEN 255
 * DECLARE %CTLID IS FIXED
 * 
 * *        FILE MUST BE PREVIOUSLY OPENED
 * 
 *          %FILE = $READ('FILE/GROUP CONTEXT?')
 *          %PROC = $READ('PROCEDURE NAME?')
 * 
 * *        OPEN THE PROCEDURE
 * 
 *          %CTLID = $RDPROC ('OPEN', %FILE, %PROC)
 *          IF $STATUS > 0 THEN
 *            PRINT '$RDPROC OPEN ERROR, REASON CODE=' -
 *            AND $STATUSD
 *            STOP
 *          END IF
 * 
 * *        DETERMINE THE LINEND CHARACTER
 * 
 *          %TEXT = $RDPROC ('LINEND', %CTLID)
 *          IF $STATUS > 0 THEN
 *            PRINT '$RDPROC LINEND ERROR, REASON CODE=' -
 *            AND $STATUSD
 *            STOP
 *          END IF
 *          PRINT 'LINEND CHARACTER = ' WITH %TEXT
 *          PRINT
 * 
 * *        DISPLAY THE PROCEDURE
 * 
 *          REPEAT WHILE $STATUS = 0
 *          %TEXT = $RDPROC ('GET', %CTLID)
 *          PRINT %TEXT
 *          END REPEAT
 * 
 * *        SEE IF WE ENDED ABNORMALLY
 * 
 *          IF $STATUS > 1 THEN
 *          PRINT 'GET ERROR, REASON CODE=' AND $STATUSD
 *          END IF
 * 
 * *        CLOSE THE PROC (UNNECESSARY SINCE WE READ TO EOP)
 * 
 *          %TEXT = $RDPROC ('CLOSE', %CTLID)
 * END
 * </pre>
 * <p>
 * <b>Opening an empty temporary procedure</b>
 * <p>
 * If you attempt to open an empty temporary procedure, {@link $STATUS} returns a zero
 * and issues the following error:
 * <pre>
 * M204.1172 PREVIOUS REQUEST NOT DEFINED
 * </pre>
 * The current request continues as normal.
 * <p>
 * <b>$RDPROC and temporary procedures</b>
 * <p>
 * Using $RDPROC, create a temporary procedure named -1 and print procedure
 * -1 to procedure -2. In this example, the place for the input file name is blank (, ,)
 * or NULL.
 * <pre>
 * USE PROC -2
 * MONITOR
 * BEGIN
 *          %CTLID = $RDPROC('OPEN',,-1)
 *          IF $STATUS THEN
 *             JUMP TO BAILOUT
 *          END IF
 *          REPEAT WHILE NOT $STATUS
 *          PRINT $RDPROC('GET',%CTLID)
 *          END REPEAT
 * BAILOUT:
 * END
 * </pre>
 */
function STRING $RDPROC(INTEGER option=OPEN, STRING fgname_ctlid, STRING procname='');


/**
 * The $READ function enables the user to enter data from the terminal as a
 * request is evaluated. $READ is useful when creating generalized requests.
 * You can also use $READ to read a sequential input file; see "Using the $READ
 * function to read sequential input" on page 27-83.
 * 
 * @param prompt is the literal to appear on the terminal, prompting for input. This
 *               argument is optional.
 * @param option indicates how the input value is to be returned. The only valid option
 * is 'TRANSPARENT'. When this argument is present, $READ does not
 * translate LINEND characters as the logical end of line nor a hyphen as the
 * continuation character, remove trailing blanks, or convert lowercase
 * characters to uppercase. $READ simply returns the input line of up to 255
 * characters exactly as entered.
 * @return the input line of up to 255 characters exactly as entered.
 * 
 * @example
 * <b>Prompting the user for a line of input</b>
 * <p>
 * Each time $READ is evaluated, Model 204 prompts the user for a line of input.
 * The response becomes the character string value returned by the function. For
 * example:
 * <pre>
 *    $READ('HELLO')
 * </pre>
 * causes Model 204 to respond:
 * <pre>
 *    $$HELLO
 * </pre>
 * and wait for the user to enter a reply each time the function is evaluated.
 * <p>
 * If the user keys in:
 * <pre>
 *    GOODBYE
 * </pre>
 * in reply, the function returns a value equal to the quoted string 'GOODBYE'.
 * If no prompt argument is specified, as $READ (), the prompt is:
 * <pre>
 *    $$
 * </pre>
 * The end of the user's reply is delimited by a carriage return or a semicolon.
 * However, if the user ends the first line of reply with a hyphen, the carriage
 * return is ignored, and the reply can be continued on another line.
 * Including $READ functions and dummy strings in a procedure
 * If $READ functions are included in a procedure, one or more responses to the
 * $READs can be specified in the command that invokes the procedure, along
 * with responses to dummy strings included in the procedure. The following
 * procedure contains a typical data entry request.
 * <pre>
 * PROCEDURE ENTRY
 * BEGIN
 * NAME.AND.AGE: %A = $READ('NAME')
 *               %B = $READ('AGE')
 *               STORE RECORD
 *                  TYPE = ??TYPE
 *                  NAME = %A
 *                  AGE = %B
 *               END STORE
 *               IF $READ('MORE?') EQ 'YES' THEN -
 *                  JUMP TO NAME.AND.AGE
 *               END IF
 * END
 * END PROCEDURE
 * </pre>
 * You can include the procedure and specify responses for the $READ functions
 * and dummy strings included in the procedure by issuing the following:
 * <pre>
 * INCLUDE ENTRY, PERSONNEL, ROBERT, 27, YES, LOUISE, 28, NO
 * </pre>
 * Dummy string responses must appear first, followed by $READ responses. If
 * any $READ responses are included in the list, it also must include a response
 * for each dummy string encountered before the first $READ is executed.
 * <p>
 * As dummy strings and $READs are encountered in the procedure being
 * executed, entries are retrieved from the list specified in the INCLUDE or IF line.
 * No prompts are issued for responses taken from the list. If there are more
 * dummy strings and $READs than responses in the list, Model 204 prompts for
 * a response as if no list had been specified.
 * <p>
 * Alternatively, if the user responds to a request with several $READs in a row,
 * the user can wait for the first prompt and then enter several replies at once,
 * separating them by semicolons. Model 204 prints the prompts for the next
 * $READs but does not wait for the user to reply to each one.
 * <p>
 * <b>Results of $READ prompts</b>
 * <p>
 * Results of $READ prompts contain leading or intermediate blanks that the user
 * enters if the TRANSPARENT argument is not specified. However, trailing
 * blanks are dropped. This occurs when the ENTRY procedure shown earlier is
 * included. Note the stacking of responses on a single input line.
 * <pre>
 * <b>INCLUDE ENTRY</b>
 * ??TYPE
 * <b>PERSONNEL</b>
 * $$NAME
 * <b>ROBERT</b>
 * $$AGE
 * <b>27</b>
 * $$MORE?
 * <b>YES</b>
 * $$NAME
 * <b>LOUISE 28 28</b>
 * $$AGE
 * $$MORE?
 * <b>YES</b>
 * $$NAME
 * <b>DALE 24; YES; RICHARD; 37; YES: THO-
 * MAS 59; NO</b>
 * $$AGE
 * $$MORE?
 * $$NAME
 * $$AGE
 * $$MORE?
 * $$NAME
 * $$AGE
 * $$MORE?
 * </pre>
 * This example illustrates the differences between dummy strings and the
 * $READ function.
 * <p>
 * Dummy strings allow the user to fill in pieces of the request text just before
 * compilation begins. The user's replies to ?? prompts are substituted before the
 * text is compiled. ??TYPE is replaced only once, at compilation time, by
 * PERSONNEL.
 * <p>
 * $$ prompts and $READ function input not specified at INCLUDE time are
 * processed when the request is evaluated. Substitutions for these prompts are
 * accepted as character strings; no text or character evaluation is made.
 * Consider the following example:
 * <pre>
 * BEGIN
 * PRINT.COUNT: FIND AND PRINT COUNT
 *                 AGE = ??AGE
 *              END FIND
 * END
 * BEGIN
 *              %AGE = $READ('ENTER AGE')
 * PRINT.COUNT: FIND AND PRINT COUNT
 *                 AGE = %AGE
 *              END FIND
 * END
 * </pre>
 * In the first request, if the user replies "10 OR 11" to the ??AGE prompt, the line
 * AGE = 10 OR 11 is properly compiled and the request searches for records with
 * AGE either 10 or 11. However, if the user replies 10 OR 11 to the $$ENTER
 * AGE prompt in the second request, 10 OR 11 is considered a character string
 * and Model 204 searches for records with AGE fields containing the string
 * '10 OR 11'.
 * <p>
 * If the user presses the attention key (ATTN, BREAK, or PA1, depending on
 * terminal type) or enters *CANCEL in response to a $READ prompt, Model 204
 * performs the action specified in the ON ATTENTION unit (see "ON units" on
 * page 12-20) if one is specified in the request.
 * <p>
 * If ON ATTENTION is not specified, Model 204 terminates the request and all
 * nested procedures. Control is returned to the command level at the user's
 * terminal.
 * <p>
 * <b>Using the $READ function to read sequential input</b>
 * <p>
 * You can use the $READ function to read sequential input:
 * <ol>
 * <li>Run Model 204 in batch mode. $READ assumes terminal input in online
 * mode and sequential input (for example, tape or disk) in batch mode.
 * <li>Concatenate a User Language procedure to the sequential input to be
 * read. The following JCL is required:
 * <pre>
 * // CCAIN DD DSN=USER.LANG.PROCEDURE,DISP=OLD
 * DD DSN=SEQU.INPUT.FILE,DISP=OLD
 * <//pre>
 * <li>Use the {@link $SUBSTR} function to parse the input. For example:
 * <pre>
 * %FIELDA=$SUBSTR(%INPUT,1,10)
 * %FIELDB=$SUBSTR(%INPUT,11,5)
 * </pre>
 * </ol>
 * <p>
 * The input is read into the %variable (for example, INPUT). It cannot exceed 255
 * characters in length.
 */
function STRING $READ(STRING prompt='', STRING option='');


/**
 * The $READINV function is identical to the {@link $READ} function, except that:
 * <ul>
 * <li>Input from the terminal is not echoed. It is treated the same as a password
 * for the device would be treated.
 * <li>$READINV cannot take its response from arguments saved from the
 * INCLUDE line.
 * </ul>
 * <p>
 * The $READINV function takes a field name as its one argument.
 * 
 * @param field_name name of the field to read in
 * @return the input line of up to 255 characters exactly as entered.
 */
function STRING $READINV(STRING field_name);


/**
 * The $READLC function is identical to {@link $READ}, except that it deactivates case
 * translation, regardless of the current UPPER/LOWER setting. $READLC
 * takes one argument.
 * 
 * @param field_name name of the field to read in
 * @return the input line of up to 255 characters exactly as entered.
 */
function STRING $READLC(STRING field_name);


/**
 * The $REMOTE function returns the VTAM network ID (VTAM applid, or user
 * zero parameter VTAMNAME) of the Model 204 region from which a user is
 * transferred by the Transfer Control facility. This VTAM applid should be the
 * DEFINE PROCESSGROUP command REMOTEID value of the Model 204
 * region to which the user is transferred. $REMOTE simplifies a return transfer
 * to the region from which the user transferred: the $REMOTE value is used as
 * the target of the return transfer.
 * 
 * @return
 * It returns an 8-byte character string consisting of the VTAM applid of a remote
 * Model 204 region. If a user transferred into the Model 204 region from a non-Model
 * 204 region, $REMOTE returns blanks. $REMOTE can only be issued
 * from an IODEV=7 thread. The $REMOTE function takes no arguments.
 */
function STRING $REMOTE();


/**
 * The $REVERSE function reverses the order of a string.
 * 
 * @param string any character string.
 * @return 'string' in reverse order
 *
 * @example
 * <pre>
 * PRINT $REVERSE('AB CDEF')
 * </pre>
 * prints the value FEDC BA.
 * <p>
 * $REVERSE is particularly useful when the file manager defines an ORDERED
 * field to contain the characters of a frequently retrieved field in reverse order.
 * Thus, when leading wildcard patterns (for example, *SON) are used to retrieve
 * records or values, the patterns can be reversed to optimize the ordered
 * retrieval. If the patterns remain in leading wildcard form and the original,
 * unreversed field is used to retrieve values or records, the entire Ordered Index
 * is searched to find the values satisfying the pattern.
 * <p>
 * For example, an ORDERED field named WORD exists and values ending in
 * LY are to be retrieved frequently. To optimize this retrieval, another ORDERED
 * field named REVERSE.WORD can be defined to store the reversed values in
 * the WORD field, and the pattern *LY can be reversed to retrieve values in
 * REVERSE.WORD LIKE 'YL*'. The pattern YL* optimizes the Ordered Index
 * retrieval, providing much faster performance than *LY.
 * <p>
 * For more information on defining fields to optimize leading wildcard patterns,
 * refer to the Model 204 File Manager's Guide.
 */
function STRING $REVERSE(STRING string);


/**
 * @return
 * The $RLCFILE function returns the name of the file in which the last record
 * locking conflict occurred. If the file is remote, $RLCFILE also returns the
 * location of the file (in the form filename AT location). This function is most
 * useful when used within an ON FIND CONFLICT or ON RECORD LOCKING
 * CONFLICT unit.
 * <p>
 * The $RLCFILE function takes no arguments. At the beginning of a request,
 * $RLCFILE is set to null values. After a record locking conflict occurs, $RLCFILE
 * returns the name of the conflicting file.
 *
 * @example
 * This request prints the name of the file that invokes the ON RECORD
 * LOCKING CONFLICT unit:
 * <pre>
 * BEGIN
 * ON RECORD LOCKING CONFLICT
 *    PRINT 'UNABLE TO COMPLETE'
 *    PRINT 'CONFLICT OCCURING IN FILE = ' WITH $RLCFILE
 * END ON
 *
 * GET.NAME: FOR EACH RECORD WHERE -
 *              FULLNAME IS LIKE 'JOHNST*'
 *              CHANGE AGENT TO GOODRICH
 *           END FOR
 * END
 * </pre>
 */
function STRING $RLCFILE();


/**
 * @return
 * The $RLCREC function returns the internal record number for which the last
 * record locking conflict occurred. This function is most useful when used within
 * an ON FIND CONFLICT or ON RECORD LOCKING CONFLICT unit.
 * <p>
 * At the beginning of a request, $RLCREC is set to -1. After a record locking
 * conflict occurs, $RLCREC returns the internal record number of the record in
 * conflict. The $RLCREC function takes no arguments.
 *
 * @example
 * This request prints the internal record number of the record that invokes the ON
 * <pre>
 * RECORD LOCKING CONFLICT unit:
 * BEGIN
 * ON RECORD LOCKING CONFLICT
 *    PRINT 'UNABLE TO COMPLETE'
 *    PRINT 'CONFLICTING WITH RECORD # ' WITH $RLCREC
 * END ON
 *
 * GET.NAME: FOR EACH RECORD WHERE -
 *              (FULLNAME IS GREATER THAN COLLUM
 *              POLICY NO IS BETWEEN 100340 AND 100492)
 *              CHANGE STATE TO CALIFORNIA
 *           END FOR
 * END
 * </pre>
 */
function STRING $RLCREC();


/**
 * @return
 * The $RLCUID function returns the user ID that has caused an ON FIND
 * CONFLICT or ON RECORD LOCKING CONFLICT to occur. $RLCUID takes
 * no arguments and returns a variable length character string. If the conflicting
 * user is on a remote system the return value is in the form:
 * <pre>
 * userid AT location
 * </pre>
 */
function STRING $RLCUID();


/**
 * @return
 * The $RLCUSR function returns the user number of the user with which the
 * request conflicted when the last record locking conflict occurred. This function
 * is most useful when used within an ON FIND CONFLICT or ON RECORD
 * LOCKING CONFLICT unit.
 * <p>
 * At the beginning of a request, $RLCUSR is set to null values. After a record
 * locking conflict occurs, $RLCUSR returns the user number of the conflicting
 * user. The $RLCUSR function takes no arguments.
 *
 * @example
 * This request prints the user number of the user that invokes the ON RECORD
 * LOCKING CONFLICT unit:
 * <pre>
 * BEGIN
 * ON RECORD LOCKING CONFLICT
 *    PRINT 'UNABLE TO COMPLETE'
 *    PRINT 'CONFLICTING WITH USER # ' WITH $RLCUSR
 * END ON
 *
 * GET.NAME: FOR EACH RECORD WITH -
 *              FULLNAME LIKE 'BAKER*,DEROUCHE,TANGO*'
 *              CHANGE AGENT TO CASOLA
 *           END FOR
 * END
 * </pre>
 */
function STRING $RLCUSR();


/**
 * This function rounds a number to a specified number of decimal places.
 * 
 * @param number   the number to be rounded.
 * @param places   the number of significant decimal places to which the number
 * should be rounded.
 *
 * @return
 * $ROUND returns the first argument, rounded to the number of decimal places
 * specified in the second argument. If the second argument is negative,
 * $ROUND returns the first argument unaltered and prints an error message.
 * Omitted arguments are set to zero.
 *
 * @example
 * <pre>
 * $ROUND(200.565, 2) equals 200.57
 * $ROUND(200.565, 0) equals 201
 * $ROUND(200.565) equals 201
 * $ROUND(-200.565, 1) equals -200.6
 * $ROUND(-200.565, 2) equals -200.57
 * </pre>
 */
function STRING $ROUND(FLAOT number, INTEGER places=0);


/**
 * $SCAN is an alias for {@link $INDEX}.
 * 
 * @param haystack      character string to search
 * @param needle        string to search for
 * 
 * @return
 * $SCAN compares two character strings and returns a number equal to the first
 * position within the first string at which the second string appears.
 *
 * @example
 * <p>
 * $SCAN ('OTHER', 'THE') equals 2
 * $SCAN ('SAME', 'SAME') equals 1
 * </pre>
 *
 * @example
 * If the second string is not contained in the first or is a null string, zero is
 * returned:
 * <pre>
 * $SCAN ('SAME', 'OTHER') equals 0
 * $SCAN ('SOME', 'SOMEMORE') equals 0
 * $SCAN ('ABC', ") equals 0
 * </pre>
 *
 * @example
 * This request uses $SCAN to separate the last name from a field containing a
 * full name in the form "last name, first name":
 * <pre>
 * BEGIN
 * FIND.RECS: FIND ALL RECORDS FOR WHICH
 *               DATE OF BIRTH IS LESS THAN 660000
 *            END FIND
 *            FOR EACH RECORD IN FIND.RECS
 *               %LASTNAME = -
 *               $SUBSTR (FULLNAME, 1, -
 *               $SCAN (FULLNAME,',')-1)
 *               ADD LAST NAME = %LASTNAME
 *                .
 *                .
 * </pre>
 * 
 * @see $INDEX
 */
function INTEGER $SCAN(STRING haystack, STRING needle);


/**
 * @return
 * $SCLASS returns a variable length character string equal to the current user's
 * subsystem user class (SCLASS). $SCLASS returns a null string if the user is
 * not running in a subsystem. For more information on user classes and
 * subsystems, refer to Chapter 23.
 * <p>
 * The $SCLASS function typically is used when designing applications through
 * the Subsystem Management facility. $SCLASS can be used to determine the
 * user class of the current user. Control can then be transferred depending upon
 * the user's privileges. The $SCLASS function takes no arguments.
 *
 * @example
 * <pre>
 * GET.OPTION: JUMP TO (ADD.REC,VIEW.REC,UPD.REC) -
 *                %MAIN.MENU:SELECTION
 *                .
 *                .
 * UPD.REC: IF $SCLASS = 'UPDATE' THEN
 *                IF $SETG('NEXT','PRE-MAINT.PGM') THEN
 *                    PRINT 'GLOBAL TABLE FULL'
 *                END IF
 *                .
 *                .
 * </pre>
 */
function STRING $SCLASS();


/**
 * The $SETG function performs two tasks. It attempts to create or change an
 * entry in the global variable table and also informs the user if the operation was
 * successful.
 *
 * @return $SETG returns a 1 (true) if the global variable was not stored due
 * to lack of space. It returns a 0 (false) if the variable was successfully stored.
 * 
 * @param name         the name of the global variable
 * @param value        the value to assign to the variable.
 *                     Previously stored variables with the same name are deleted first.
 *
 * @example
 * The following statement attempts to store a global variable with a name of
 * GLOB and with a value equal to the character string returned from the {@link $READ}.
 * A message is to be printed if the operation was not successful.
 * <pre>
 * IF $SETG('GLOB',$READ('ENTER GLOBAL VALUE')) THEN
 * PRINT 'HELP'
 * END IF
 * </pre>
 * Refer to Chapter 20 for a detailed explanation of global variables and examples
 * of the $SETG function within a request.
 */
function INTEGER $SETG(STRING name, STRING value);


/**
 * The $SETL function sets the current line counter for the output device currently
 * in effect to the value specified as the $SETL argument. Use the $SETL function
 * only when routing output to an external dataset. You cannot use $SETL with
 * full-screen devices.
 *
 * @param line      value to assign to the current line counter
 *                  for the output device currently in effect.
 * @return
 * $SETL returns a number representing the maximum physical line length
 * allowed on the current output device. This line length is determined from the
 * OUTMRL and OUTCCC parameters or, if an alternate output device is being
 * used, from the LRECL specification on the USE dataset DD statement and the
 * UDDCCC parameter. All parameters are described in the Model 204
 * Command Reference Manual.
 *
 * @note
 * The $SETL function does not ordinarily reposition the output device or perform
 * any input/output operations. It simply alters the value of the line counter for the
 * device. When this counter is compared to the value of OUTLPP or UDDLPP,
 * the effective size is changed for the current page. If the counter is set to a value
 * equal to or greater than the effective lines-per-page value (OUTLPP or
 * UDDLPP), a NEW PAGE action is forced.
 */
function INTEGER $SETL(INTEGER line);


/**
 * This function sets the current page number for the output device currently in
 * effect. The current page number is used by Model 204 in formatting HEADER 0
 * or filling in a value for the {@link $HPAGE} function. The value specified as the $SETP
 * argument becomes the current page number. Note, however, that the current
 * page number is incremented before the next page is printed, so if you want the
 * next page to be page 5, use 4 as the argument to $SETP as shown in the
 * following example:
 * <pre>
 * %PAGENO = $SETP(4)
 * SET HEADER1 WITH $HPAGE(%PAGENO)
 * </pre>
 * The first line in the example is sufficient for setting the page number in
 * HEADER 0. If you want the page number to appear in any other header line,
 * you must do it indirectly (using the {@link $HPAGE} function), as in the second line of
 * the example. The $SETP function is not valid in a SET HEADER statement.
 * 
 * @param page      value to assign to the current page number
 *                  for the output device currently in effect.
 * @return
 * Although the effect of $SETP is to set the current page number, its return value
 * is a number representing the current number of output lines per page (the value
 * of the OUTLPP parameter or, if an alternate output device is being used, the
 * UDDLPP parameter). This is the value you would see if you printed the value
 * of %PAGENO in the example ( not the current page number).
 */
function INTEGER $SETP(INTEGER page);


/**
 * The $SLSTATS function lets you evaluate the relative expense of different
 * processes in a single request by resetting the recording of since-last statistics
 * at the point in a request where the function call appears.
 * <p>
 * The format of the $SLSTATS function is:
 * <pre>
 * $SLSTATS([' string' | % variable])
 * </pre>
 *
 * @param string_or_var (optional) 
 * Model 204 uses the first four characters in the quoted string, or in the current
 * value of the %variable, as a label to identify the section of the request to which
 * the corresponding since-last audit trail entry applies.
 * <p>
 * The default value for the argument is EVAL. Because the recording of since-last
 * statistics begins automatically with request execution, the first set of since-last
 * statistics in the audit trail for any request is always be labelled EVAL. This
 * is true even if the first statement in a request contains a $SLSTATS call.
 * @return
 * You can call the $SLSTATS function by embedding it in a PRINT statement or
 * assigning it to a %variable. For example, the following statement initiates a new
 * set of since-last statistics (labelled FND1) for the remainder of the request, or
 * until the next $SLSTATS call appears:
 * <pre>
 * %X = $SLSTATS('FND1')
 * </pre>
 * Note that each invocation of $SLSTATS produces a new SMF (System
 * Monitoring Facility) record. If the identifying label is specified, then it replaces
 * EVAL in the SMF record, as it does in the audit trail.
 * <p>
 * In addition to EVAL, there are several other labels generated by Model 204 for
 * audit trail and SMF records. These include:
 * <ul>
 * <li>CMPL
 * <li>COPY
 * <li>DUMP
 * <li>EDIT
 * <li>LOAD
 * <li>REST
 * </ul>
 * You can assume any label not listed above to be generated by an $SLSTATS
 * call. (Note, however, that there is no prohibition against using the above labels
 * with $SLSTATS.) For accounting purposes, any label generated by $SLSTATS
 * should be included as EVAL statistics.
 * <p>
 * See the Model 204 System Manager's Guide for detailed information on since-last
 * statistics.
 */
function STRING $SLSTATS(STRING string_or_var='EVAL');


/**
 * @param value input string to compute SOUNDEX code for.
 *
 * @return
 * The $SNDX function returns the SOUNDEX code of an argument. The $SNDX
 * function is commonly used with files containing unusual or frequently
 * misspelled names. You can create a field containing the SOUNDEX code for a
 * name and then use that field for retrievals.
 * <p>
 * The code is derived in the following manner:
 * <ol>
 * <li>All consecutive occurrences of the same letter are reduced to a single
 * occurrence.
 * <li>The first character of the string becomes the first character of the result.
 * <li>All vowels, special characters, and the letters H, W, and Y are eliminated.
 * </ol>
 * <p>
 * The rest of the characters are transformed as follows:
 * <ul>
 * <li>B, F, P, V are changed to 1.
 * <li>C, G, J, K, Q, S, X, Z are changed to 2.
 * <li>D, T are changed to 3.
 * <li>L is changed to 4.
 * <li>M, N are changed to 5.
 * <li>R is changed to 6.
 * </ul>
 *
 * @example
 * <pre>
 * $SNDX('MURRAY') equals M6
 * $SNDX('MARY') equals M6
 * $SNDX('O"MALLEY') equals O54
 * </pre>
 *
 * @example
 * <pre>
 * BEGIN
 *            %A = $SNDX($READ('ENTER NAME'))
 * FIND.RECS: FIND ALL RECORDS FOR WHICH
 *               NAME SOUND = %A
 *            END FIND
 * .
 * .
 * </pre>
 */
function INTEGER $SNDX(STRING value);


/**
 * @param x number to be squared
 * @return
 * The $SQUARE function multiplies a number by itself. $SQUARE takes the
 * number to be squared as its one argument. For example:
 * <pre>
 * $SQUARE(8) equals 64.
 * </pre>
 */
function INTEGER $SQUARE(INTEGER x);


/**
 * @return
 * The $STAT function returns the current value of any user final (LOGOUT) or
 * partial statistic. This function is useful for determining which resources are used
 * by various portions of a request.
 * 
 * @param statistic specifies the name of the user statistic to be returned. Refer to the
 * Model 204 System Manager's Guide for a complete list of user statistic
 * names and meanings.
 * @param user specifies the return of a user final or partial statistic.
 *
 * @example
 * <pre>
 * %X = $STAT('CPU','USER')
 * </pre>
 */
function STRING $STAT(STRING statistic, STRING type='USER');


/**
 * @return
 * The $STATUS function returns a numeric value that indicates the success or
 * failure of the last executed OPEN/OPENC statement, external I/O statement or
 * program communication statement.
 * <p>
 * $STATUS function takes no arguments.
 * <dl compact>
 * <dt><b>For a discussion of</b> <dd style="marginleft:200pt"><b>See</b>
 * <dt>Error handling with the OPEN and OPENC statements
 * <dd style="marginleft:200pt">Error handling" on page 16-16
 * <dt>External I/O statements 
 * <dd style="marginleft:200pt">Reading external files or terminal input" on page 17-4
 * <dt>Communication statements
 * <dd style="marginleft:200pt"> Chapter 18
 * </dl>
 * <p>
 * <b>List of $STATUS return values</b>
 * <dl compact>
 * <dt><b>Return value / Error level</b><dd style="marginleft:100pt"><b>Result/action</b>
 * <dt>0 Success <dd style="marginleft:80pt">The message text set to null.
 * <dt>1 Warning <dd style="marginleft:80pt">The statement generating this code has completed, but a warning
 *   condition was encountered. $STATUSD provides a detailed warning
 *   code.
 * <dt>2 Signal <dd style="marginleft:80pt">A SIGNAL has been received from the partner process.
 *   The $STATUSD function provides the SIGNAL value. If this code is
 *   received on a:
 *   <ul>
 *   <li>SIGNAL statement, then the SIGNAL was transmitted to the partner process.
 *   <li>SEND statement, the data transmitted was not received by the
 *       partner process and was discarded.
 *   <li>RECEIVE statement, no data was received and the contents of
 *       the receiving area are unpredictable.
 *   </ul>
 * <dt>3 <dd style="marginleft:80pt">The User Language statement is invalid in this conversation state.
 * <dt>>= 4  Serious Error <dd style="marginleft:100pt">If this code is generated by a CLOSE PROCESS statement, then the
 *    CLOSE PROCESS functions have been completed to the greatest
 *    degree possible. Any other statement that generates this code did
 *    not complete at all. $STATUSD provides a detailed error code.
 * </dl>
 *
 * @example
 * <pre>
 * READ IMAGE ACCT.RECV.REC
 *    IF $STATUS = 0 THEN
 *       CALL PROCESS.AR
 *    ELSE
 *       LOOPEND
 *    END IF
 * </pre>
 */
function STRING $STATUS();


/**
 * @return
 * The $STATUSD function returns a numeric value that indicates a more detailed
 * description of a condition reported by {@link $STATUS}. The $STATUSD function is
 * valid only for program communication statements. For more information on:
 * <ul>
 * <li>Communication statements, refer to Chapter 18
 * <li>A list of values that $STATUSD returns:
 * <dl compact>
 * <dt><b>Setting</b> <dd style="marginleft:40pt"><b>Description</b>
 * <dt><b>0</b> <dd style="marginleft:40pt"> Successful completion
 * <dt><b>300</b> <dd style="marginleft:40pt">Abnormal termination. Refer to CCAOUT for an error message.
 *    If a completion code of 300 is returned, an error message appears in the
 *    CCAOUT data stream. Some possible errors are:
 *    <ul>
 *    <li>Invalid channel name parameter value.
 *    <li>Invalid OMC parameter value.
 *    <li>CCAIN data stream could not be opened.
 *    </ul>
 * <dt><b>600</b> <dd style="marginleft:40pt">The CCAOUT data stream could not be opened.
 * </dl>
 * </ul>

 * @example
 * <pre>
 *   .
 *   .
 * SEND %CMSPROGRAM TO %CMSRECEIVE
 * IF $STATUS EQ 4
 *    IF $STATUSD EQ 1669 THEN
 *       READ IMAGE EMP.REC FROM VSAMDS1
 *    ELSE
 *     .
 *     .
 * </pre>
 */
function STRING $STATUSD();


/**
 * @return
 * The $STRIP function returns the contents of an argument with leading zeros
 * suppressed. $STRIP, like {@link $PAD}, is useful for report formatting.
 *
 * @param s      input string to strip leading zeroes from
 * 
 * @example
 * <pre>
 * $STRIP('055449825') equals '55449825'
 * $STRIP('00000') equals ''
 * </pre>
 * If a character other than zero is in the first position of the argument, zeros within
 * the string are not removed. For example:
 * <pre>
 * $STRIP(' 055449825') equals ' 055449825'
 * </pre>
 */
function STRING $STRIP(STRING s);


/**
 * @return
 * The$SUBSTR function returns a substring of a string. $SUBSTR is identical to
 * {@link $DEBLANK} except that {@link $DEBLANK} strips the resulting string of leading and
 * trailing blanks, and $SUBSTR does not.
 * 
 * @param string is the string from which the substring is derived.
 * @param position is the position in the string at which the substring is to begin.
 * @param length is the maximum length of the substring. If this argument is omitted,
 * a default value of 255 is used.
 *
 * The position and length arguments are rounded to positive integers.
 *
 * @example
 * <pre>
 * $SUBSTR('KITTREDGE', 4,3) equals 'TRE'
 * $SUBSTR('ANTELOPE', 7) equals 'PE'
 * $SUBSTR('TOO', 19, 2) equals " (null string)
 * $SUBSTR('ACCOUNT', -3, 5) equals 'ACCOU'
 * </pre>
 * This request searches the FIRST NAME field of all the Smiths and creates a
 * list of names that begin with A, B, C, or D.
 * <pre>
 * BEGIN
 * FIND.RECS: FIND ALL RECORDS FOR WHICH
 *               LAST NAME = SMITH
 *            END FIND
 *            FOR EACH RECORD IN FIND.RECS
 *               IF $ONEOF($SUBSTR(FIRSTNAME, 1, 1),-
 *               'A/B/C/D','/')
 *            THEN PLACE RECORD ON NAME
 *             .
 *             .
 * </pre>
 */
function STRING $SUBSTR(STRING string, INTEGER position, INTEGER length=0);


/**
 * The $SUBSYS function determines the status of a subsystem. This function
 * typically is used when designing applications through the Subsystem
 * Management facility. You can use $SUBSYS to determine whether a
 * subsystem is active before transferring control from one subsystem to another.
 * For more information about subsystems, refer to Chapter 23.
 * 
 * @param name a subsystem name
 * @return returns one of the following values:
 *         <dl compact>
 *         <dt>Value <dd>The subsystem is:
 *         <dt>0 <dd>Not active (not started).
 *         <dt>1 <dd>Active (started).
 *         <dt>2 <dd>Draining (the STOP command has been issued and users are in the subsystem).
 *         <dt>3 <dd>In test mode.
 *         </dl>
 * The $SUBSYS function without an argument returns the name of the
 * subsystem you are currently in. For example, the User Language statement:
 * <pre>
 *    %CURSYS = $SUBSYS
 * </pre>
 * assigns the name of the current subsystem to %CURSYS, if executed within a
 * subsystem, or returns null if at command level.
 * @example
 * <pre>
 * .
 * .
 * TRANSFER: IF $SUBSYS('AUTOS') = 1 THEN
 *           .
 *           .
 * *
 * * TRANSFER TO INSURANCE SUBSYSTEM
 * *
 *           .
 *           .
 * </pre>
 */
function INTEGER $SUBSYS(STRING name);


/**
 * @return
 * The $TCAMFHP is meaningful only for users of TCAM 3270s (IODEV 21),
 * which are no longer supported by CCA. See Appendix A for detailed
 * information.
 */
function STRING $TCAMFHP();


/**
 * @return
 * Returns the current time of day in the format specified.
 * <p>
 * The second-delimiter applies only if time-format is 2. You must enclose the
 * delimiters with single quotation marks.
 * You can suppress either the first-delimiter or second-delimiter character by
 * using a single quoted null string.
 *
 * @param time_format
 *             if "1", $TIME returns the time of day as hhdmmdss.
 *             if "2", $TIME returns the time of day as hhdmmdssdttt ( d=delimiter)
 * @param first_delimiter  (1 character only) Character to place between time units HH, MM, and SS (default is colon, ":")
 * @param second_delimiter (1 character only) Character to place between time units SS and TTT (default is period, ".")
 * 
 * @example
 * <pre>
 * $TIME             HH:MM:SS
 * $TIME(1)          HH:MM:SS
 * $TIME(1,'-')      HH-MM-SS
 * $TIME(1,' ')      HH MM SS
 * $TIME(1,'')       HHMMSS
 * $TIME(2)          HH:MM:SS.TTT
 * $TIME(2,'-')      HH-MM-SS.TTT
 * $TIME(2,'','')    HHMMSSTTT
 * </pre>
 */
function STRING $TIME(STRING time_format=1, STRING first_delimiter=':', STRING second_delimiter='.');


/**
 * @return
 * The $UNBIN function converts a value from its fixed-point binary form to the
 * corresponding character string representation. The $UNBIN function reverses
 * the effect of the {@link $BINARY} function.
 * 
 * @param value is a string argument. This argument must be either two or four bytes
 * long; its value is interpreted as a bit string. If the length of the argument is
 * not two or four bytes, Model 204 issues a counting error message and
 * returns a null string.
 * @param scale indicates the number of fractional digits (bits) in the specified value. If
 * the scale argument is omitted, a default value of 0 (integer) is used.
 */
function STRING $UNBIN(STRING value, INTEGER scale=0);


/**
 * @return
 * The $UNBLANK function returns the contents of an argument, removing
 * leading and trailing blanks, and compressing multiple embedded blanks to one
 * blank character. $UNBLANK is useful in conjunction with {@link $READ}. The user can
 * respond to prompts for retrievals or comparisons in free form, without regard
 * for leading, trailing, or embedded blanks. See the second example.
 *
 * @param s string to remove blanks from
 *
 * @example
 * <pre>
 * $UNBLANK(' JOHN JONES ') equals 'JOHN JONES'
 * $UNBLANK('WASH., D.C.') equals 'WASH., D.C.'
 * </pre>
 *
 * <pre>
 * BEGIN
 *    %A = $UNBLANK($READ('ENTER VALUE'))
 * FIND.RECS: FIND ALL RECORDS FOR WHICH
 *               FIELD = %A
 *            END FIND
 *             .
 *             .
 * </pre>
 */
function STRING $UNBLANK(STRING s);


/**
 * @return
 * The $UNFLOAT function converts a floating-point number from the standard
 * IBM floating point format to the corresponding character string representation.
 * Model 204 maintains 15 significant decimal digits of precision for 8-byte
 * floating-point numbers and 6 significant digits of precision for 4-byte floating-point
 * numbers. For an expanded discussion of rounding numbers, please refer
 * to "Mapping and precision adjustment" on page 31-3.
 * <p>
 * $UNFLOAT converts floating-point numbers from the internal form used by
 * Model 204 for storage efficiency to a printable string. $UNFLOAT also allows
 * the manipulation of these numbers by User Language.
 *
 * @param number can be either four bytes for a single-precision floating-point
 * number or eight bytes for a double-precision floating-point number.
 * 
 * @example
 * The result of the expression:
 * <pre>
 *    $UNFLOAT($FLOAT('1.234'))
 * </pre>
 * is the string 1.234. If the string argument is omitted or invalid, a null string is
 * returned.
 */
function STRING $UNFLOAT(FLOAT number);


/**
 * @return
 * The $UNPACK function converts data in packed decimal format into a string
 * that can be stored in a Model 204 file and processed by a request.
 * <p>
 * The resulting unpacked string is preceded by a minus sign if the packed
 * number was negative. If the scale provided is greater than the number of digits
 * in the value, the value is right-justified by the appropriate number of digits, the
 * decimal point is inserted in the appropriate location, and a leading zero is
 * inserted in the units position.
 * <p>
 * Leading zeros to the left of the decimal point and trailing zeros to the right of
 * the decimal point are truncated unless the result is zero. If there are no
 * significant digits to the right of the decimal point, the decimal point is removed
 * from the result as well.
 *
 * @param value is the data to be unpacked. If the data is not a valid packed decimal
 * string of as many as 18 digits, a null string is returned.
 * @param scale specifies the number of implied decimal places in the packed input. If
 * scale is greater than 18 or less than 0, a null string is returned. If scale is
 * omitted, a default value of zero is used, indicating an integer value.
 *
 * @example
 * These examples assume that %X contains a packed value of X'001234500C'.
 * <pre>
 *    %A = $UNPACK(%X,2)
 * </pre>
 * results in %A having a string value of 12345.
 * <pre>
 *    %A = $UNPACK(%X,4)
 * </pre>
 * results in %A having a string value of 123.45.
 * <pre>
 *    %A = $UNPACK(%X,10)
 * </pre>
 * results in %A having a string value of 0.00012345.
 */
function STRING $UNPACK(STRING value, INTEGER scale=0);


/**
 * @return
 * The $UNQREC function is used in conjunction with the ON FIELD
 * CONSTRAINT CONFLICT unit and the UNIQUE field attribute.
 * <p>
 * If $UNQREC is invoked from an ON FCC unit following the detection of a
 * uniqueness violation, it returns the record number of the record already
 * containing the field name = value pair. At all other times, $UNQREC returns -1.
 * <p>
 * Use $UNQREC in conjunction with $UPDREC to find the record number of the
 * unique record already stored ($UNQREC) and the record number of the non-unique
 * record you are attempting to store ({@link $UPDREC}). The $UNQREC
 * function takes no arguments.
 */
function INTEGER $UNQREC();


/**
 * @return
 * The $UPCASE function translates a lowercase or mixed-case string into an
 * uppercase-only string. The translation affects only the uppercase letters of the
 * specified language.
 *
 * @param string represents the string to be verified. string must be one of:
 *   <ul>
 *   <li> A quoted literal.
 *   <li> A %variable.
 *   <li> An unquoted field name, in which case the current value of the field is
 *        verified. In this case, the function call must be embedded in a FOR
 *        EACH RECORD loop.
 *   </ul>
 * @param language_name (optional) specifies the language to use. Options are:
 *   <ul>
 *   <li> Omitting this argument, which instructs Model 204 to perform the vali-dation
 *        for U.S. English, even if the value of the LANGUSER parameter
 *        is not NLANG.
 *   <li> A quoted asterisk ('*'), which instructs Model 204 to use the value of the
 *        LANGUSER parameter to determine which language to use.
 *   <li> The quoted literal name of a valid language, for example, NLANGFR1
 *        for French Canadian, Version 1. The request is cancelled with an error
 *        message if the name is not present in NLANG$.
 *   </ul>
 *
 * @example
 * <pre>
 *    $UPCASE('Name and address')
 * </pre>
 * returns the string NAME AND ADDRESS, using U.S. English.
 */
function STRING $UPCASE(STRING string, STRING language_name='');


/**
 * @return
 * The $UPDATE function returns the name of the group update file (in group
 * context) or the current file (in file context). If the file is remote, $UPDATE also
 * returns the location of the file (in the form filename AT location). If no group
 * update file is defined, $UPDATE returns a null (zero-length) string.
 * 
 * @param name argument overrides the default file or group context for the function.
 * The format for this argument is:
 * <p>
 * $UPDATE can be used to indicate the name of the update file in the current
 * group, but the name argument must not be specified. In addition to its use in
 * arithmetic expressions and PRINT specifications, $UPDATE also can be used
 * as the file name in an IN clause. {@link $CURFILE} and $UPDATE are described in
 * further detail in Chapter 16.
 * <p>
 * If the file name/group name argument is omitted or null, the default context is
 * the context of the statement that contains the function.
 * 
 * @note
 * You cannot use an IN clause that includes both MEMBER and
 * $UPDATE. See "IN GROUP MEMBER clause" on page 16-26 for
 * information.
 * <p>
 * Beginning with Model 204 V4R1.0 $UPDATE compresses consecutive spaces
 * to one space. For example, a pre-V4R1.0 $UPDATE might return:
 * 'OWNERS AT DALL'
 * V4R1.0 returns:
 * <pre>
 *    'OWNERS AT DALLAS'
 * </pre>
 */
function STRING $UPDATE(STRING name='');


/**
 * Use the $UPDFILE function in conjunction with the ON FIELD CONSTRAINT
 * CONFLICT unit.
 * 
 * @return
 * If $UPDFILE is invoked from an ON FCC unit following the detection of a field-level
 * constraint conflict, it returns the name of the file in which the constraint
 * violation occurs. If the file is remote, $UPDFILE also returns its location (in the
 * form filename AT location). At all other times, $UPDFILE returns a blank.
 * The $UPDFILE function takes no arguments.
 */
function STRING $UPDFILE();


/**
 * Use the $UPDFLD function in conjunction with the ON FIELD CONSTRAINT
 * CONFLICT unit.
 *
 * @return
 * If $UPDFLD is invoked from an ON FCC unit following the detection of a field-level
 * constraint conflict, it returns the name of the field in which the constraint
 * violation occurs. At all other times, $UPDFLD returns a blank. The $UPDFLD
 * function takes no arguments.
 */
function STRING $UPDFLD();


/**
 * The $UPDLOC function is used with Parallel Query Option/204 to determine
 * the location name of the current update unit.
 * 
 * @return
 * $UPDLOC takes no arguments, and returns a string indicating the location of
 * the update unit as follows:
 * <ul>
 * <li> If there is no update unit currently in effect, the string is null.
 * <li> For a local update, the return string is 'LOCAL'.
 * <li> For a remote update, the return string is the location name of the node
 * where the update is occurring.
 * </ul>
 *
 * @example
 * <pre>
 * %X = $UPDLOC
 * IF %X <> '' THEN
 *    PRINT 'UPDATE UNIT IS IN PROGRESS AT LOCATION ' WITH %X
 * END IF
 * </pre>
 */
function STRING $UPDLOC();


/**
 * The $UPDOVAL function is used in conjunction with the ON FIELD
 * CONSTRAINT CONFLICT unit.
 * 
 * @return
 * If $UPDOVAL is invoked from an ON FCC unit following the detection of an AT-MOST-
 * ONE field-level constraint conflict, it returns the value of the original field
 * occurrence which is causing the constraint violation. At all other times,
 * $UPDOVAL returns a blank. The $UPDOVAL function takes no arguments.
 */
function STRING $UPDOVAL();


/**
 * The $UPDREC function is used in conjunction with the ON FIELD
 * CONSTRAINT CONFLICT unit. Use $UPDREC in conjunction with $UNQREC
 * to find the record number of the unique record already stored ($UNQREC) and
 * the record number of the non-unique record you are attempting to store
 * ($UPDREC).
 *
 * @return
 * If $UPDREC is invoked from an ON FCC unit following the detection of a field-level
 * constraint conflict, it returns the file-relative number of the record whose
 * update causes the conflict. In all other cases, $UPDREC returns a -1. The
 * $UPDREC function takes no arguments.
 */
function STRING $UPDREC();


/**
 * The $UPDSTAT function is used in conjunction with the ON FIELD
 * CONSTRAINT CONFLICT unit and field attributes which have field-level
 * constraints (UNIQUE and AT-MOST-ONE). You must use $UPDSTAT in the
 * ON FCC unit when writing procedures for files which have (or might have in the
 * future) more than one type of field-level constraint defined. The $UPDSTAT
 * function takes no arguments.
 *
 * @return
 * If $UPDSTAT is invoked from an ON FCC unit following the detection of a field-level
 * constraint conflict, it returns a numeric value denoting the type of conflict
 * that has occurred:
 * <dl compact>
 * <dt><b>Value</b><dd><b>Meaning</b>
 * <dt>0<dd>No violation occurred
 * <dt>1<dd>A uniqueness violation occurred
 * <dt>2<dd>An AT-MOST-ONE violation has occurred
 * </dl>
 */
function STRING $UPDSTAT();


/**
 * The $UPDSTMT function is used in conjunction with the ON FIELD
 * CONSTRAINT CONFLICT unit.
 * @return
 * If $UPDSTMT is invoked from an ON FCC unit following the detection of a field-level
 * constraint conflict, it returns the type of User Language statement causing
 * the conflict. The possible values $UPDSTMT returns are:
 * <ul>
 * <li>ADD
 * <li>CHANGE
 * <li>INSERT
 * <li>STORE
 * </ul>
 * In all other cases, $UPDSTMT returns a blank. The $UPDSTMT function takes
 * no arguments.
 */
function STRING $UPDSTMT();


/**
 * @return
 * The $UPDVAL function is used in conjunction with the ON FIELD
 * CONSTRAINT CONFLICT unit. If $UPDVAL is invoked from an ON FCC unit
 * following the detection of a field-level constraint conflict, it returns the field value
 * which is causing the constraint violation. At all other times, $UPDVAL returns
 * a blank. The $UPDVAL function takes no arguments.
 */
function STRING $UPDVAL();


/**
 * @return
 * The $USER function returns a 5-character string equal to the user's user
 * number. In an n-terminal system, User 0 is user number 00000 and the terminal
 * users are numbered 00001 through n. The value of $USER is always unique to
 * a user during a terminal session. The value of $USER remains the same from
 * one session to another only in installations with hard-wired BTAM terminals or
 * static VTAM or CMS threads. This function takes no arguments.
 */
function STRING $USER();


/**
 * @return
 * The $USERID function returns a variable-length character string equal to the
 * user ID under which the user is logged into Model 204. If the login feature is not
 * in use, $USERID returns the string NO USERID.
 * <p>
 * The USERID parameter returns the same value as the $USERID function. See
 * the Model 204 Command Reference Manual. The $USERID function takes no
 * arguments.
 *
 * @example
 * <pre>
 * BEGIN
 * SET HEADER 1 'MONTHLY SALES REPORT' -
 *    AT COLUMN 10
 * SET HEADER 2
 * SET HEADER 3 'PREPARED BY: ' AT COLUMN 10 -
 *    WITH $USERID
 *    .
 *    .
 * </pre>
 */
function STRING $USERID();


/**
 * The $USRPRIV function is used to test whether a user ID has been granted
 * specific Model 204 privileges.
 *
 * @param privilege is the privilege that is to be validated. Privilege can be one of the
 * following values:
 * <UL>
 * <LI> ANY_ADMINISTRATOR -- 
 *    The ANY_ADMINISTRATOR privilege test verifies that the user is user
 *    zero or a system manager.
 * <LI> CHANGE_FILE_PASSWORD
 * <LI> CHANGE_LOGIN_PASSWORD
 * <LI> OVERRIDE_RECORD_SECURITY
 * <LI> SUPER_USER
 * <LI> SYSTEM_ADMINISTRATOR
 * <LI> SYSTEM_MANAGER
 * </UL>
 * @param logging_option specifies whether Model 204 should indicate that an error
 * message should be issued for security violations:
 * <UL>
 * <LI>LOG indicates that any privilege violation is logged.
 * <LI>NOLOG indicates that the privileges should be determined but any vio-lation
 * found is not logged.
 * </UL>
 * Currently, the logging option affects only the RACF or Top Secret interface.
 * The option has no effect on Model 204; the ACF2 Interface always logs a
 * security violation regardless of the logging option.
 * LOG is the default if a logging option is not specified.
 *
 * @return
 * $USRPRIV returns a numeric true/false value indicating the result of the
 * authorization check as follows:
 * <dl compact>
 * <dt>Value<dd>User is ...
 * <dt>0 <dd>Not authorized for the privilege or an unknown privilege name is specified.
 * <dt>1 <dd>Authorized for the specified privilege.
 * </dl>
 *
 * @example
 * The following statement could be used to test if the current user ID is authorized
 * as a system manager.
 * <pre>
 * IF $USRPRIV('SYSTEM_MANAGER','NOLOG') THEN
 *    .
 *    .
 *    .
 *    * PERFORM SYSTEM MANAGER AUTHORIZED CODE
 * END IF
 * * ELSE UNAUTHORIZED FOR SYSTEM MANAGER FUNCTIONS
 * </pre>
 */
function STRING $USRPRIV(STRING privilege, STRING logging_option);


/**
 * @return
 * The $VERIFY function returns a 1 (true) if every character contained in the
 * string is present in the second string. Otherwise, 0 (false) is returned. If the
 * second argument is a null string, 0 is returned. If the first argument is a null
 * string but the second argument is not, a 1 is returned.
 * <p>
 * $VERIFY can be used whenever {@link $ALPHA}, {@link $ALPHNUM}, and {@link $VNUM} do not
 * provide sufficient flexibility.
 *
 * @param needle        string to search for
 * @param haystack      string to search in
 * 
 * @example
 * <pre>
 * $VERIFY('1975','0123456789') equals 1
 * $VERIFY('-19.5','0123456789+-.') equals 1
 * $VERIFY('12A','0123456789') equals 0
 * </pre>
 *
 * <pre>
 * $VERIFY('ABC',") equals 0
 * $VERIFY(",") equals 0
 * $VERIFY(",'1234567890') equals 1
 * </pre>
 */
function INTEGER $VERIFY(STRING needle, STRING haystack);


/**
 * @return
 * The $VIEW function returns:
 * <ul>
 * <LI> The value of a parameter to the request. While $VIEW works for all
 * viewable Model 204 parameters in local context, it does not work for some
 * file parameters in remote context.
 * <li> File specific information
 * <li> Statistics fields. All Since Last, User, and System statistics fields can be
 * viewed by name.
 * </ul>
 *
 * @param parameter is a character string that represents the name of a viewable
 * Model 204 parameter or other information. For example:
 * <pre>
 *    $VIEW('ERASE')
 * </pre>
 * returns a value of @ if the ERASE parameter is set to the character @. If
 * the parameter name is invalid or the user is not authorized to display
 * parameter values for the file, a null string is returned.
 * @param name overrides the default file or group context for the function. The format
 * for this argument is:
 * <pre>
 *    [[FILE | [PERM | TEMP] GROUP] name | $CURFILE | $UPDATE]
 *     [AT location]
 * </pre>
 * If this argument is omitted or null, the default context is the context of the
 * statement containing the function. Thus, a default context is required for
 * this function.
 * <p>
 * You can specify {@link $CURFILE} as the name argument in place of a file/group
 * name.
 * 
 * @example
 * <b>Viewing file-specific information</b>
 * <p>
 * In addition to viewable parameters, the following file-specific information can
 * also be viewed with $VIEW:
 * <dl compact>
 * <dt><b>Name used with $VIEW</b> <dd style="marginleft:120pt"><b>Description</b>
 * <dt>DTSLBOPR <dd style="marginleft:120pt">Date and time transaction was backed out during roll
 * forward (for TBO files)
 * <dt>         <dd style="marginleft:120pt">Date and time partial transaction was applied during roll
 * forward (for non-TBO files)
 * <dt>DTSLCHKP <dd style="marginleft:120pt">Date and time of last checkpoint
 * <dt>DTSLRCVY <dd style="marginleft:120pt">Date and time of last recovery
 * <dt>DTSLUPDT <dd style="marginleft:120pt">Date and time of last update
 * <dt>DTSLDKWR <dd style="marginleft:120pt">Date and time of last DKWR
 * <dt>DTSLRFWD <dd style="marginleft:120pt">Date and time of last roll forward
 * <dt>FIWHEN   <dd style="marginleft:120pt">Date and time FISTAT was reset
 * <dt>FIWHO    <dd style="marginleft:120pt">Terminal ID that reset FISTAT
 * </dl>
 * <pre>
 *    $VIEW ('FIWHEN')
 * </pre>
 * returns:
 * <pre>
 *    FIWHEN 94.257 SEP 14 16.40.45. DATE AND TIME FISTAT WAS RESET
 * </pre>
 * <b>Syntax for viewing statistics fields</b>
 * <p>
 * The first argument is the category, SLSTATS, SYSSTATS, or USRSTATS. The
 * second argument is the name of the Statistic field to return. See the Model 204
 * System Managers Guide for the name of the statistics fields.
 * <pre>
 *    $VIEW( category, field-to-return)
 * </pre>
 * Where the following categories and fields are valid:
 * <dl compact>
 * <dt><b>Category / Statistics</b> <dd style="marginleft:150pt"><b>Statistics field-to-return Equivalent-to or returns-value-of</b>
 * <dt>'SLSTATS'  / 'USERID'            <dd style="marginleft:150pt"> $USERID
 * <dt>'SLSTATS'  / 'ACCOUNT'           <dd style="marginleft:150pt"> $ACCOUNT
 * <dt>'SLSTATS'  / 'SUBSYSTEM'         <dd style="marginleft:150pt"> $SUBSYS with no argument
 * <dt>'SLSTATS'  / 'LAST'              <dd style="marginleft:150pt"> LAST=field
 * <dt>'SLSTATS'  / 'PROC-FILE'         <dd style="marginleft:150pt"> Current procedure file
 * <dt>'SLSTATS'  / 'PROC'              <dd style="marginleft:150pt"> Current procedure
 * <dt>'SLSTATS'  / 'sl statistics name'<dd style="marginleft:150pt"> Statistics field
 * <dt>'SYSSTATS' / 'system stat name'  <dd style="marginleft:150pt"> Statistics field
 * <dt>'SYSSTATS' / 'DKBM stat name'    <dd style="marginleft:150pt"> Statistics field
 * <dt>'USRSTATS' / 'user stat name'    <dd style="marginleft:150pt"> Statistics field
 * <dt>'USRSTATS' / 'conflict ctr name' <dd style="marginleft:150pt"> Statistics field
 * </dl>
 * <b>Usage</b>
 * <p>
 * The time related Since Last statistics fields, CNCT, CPU, SCHDCPU, and
 * STCPU, are not valid during evaluation time.
 * <p>
 * Specifying an invalid statistics field name returns a null value with the message:
 * <pre>
 *    M204.1463: INVALID PARAMETER: fieldname
 * </pre>
 */
function STRING $VIEW(STRING parameter, STRING name='');


/**
 * @return
 * The $VNUM function returns a 1 if the given argument is in a valid format for a
 * SORT BY VALUE NUMERICAL statement or for any type of mathematical
 * operation. To be valid, the argument must be a quoted rational number with
 * optional sign. Leading or trailing blanks, or blanks between the sign and the
 * number, are ignored. If the contents of the argument do not have the required
 * form, 0 is returned. Numeric values with more than 63 significant digits are not
 * in the correct form; a 0 is returned.
 *
 * @param numeric_string_value   input string
 * @param option $VNUM takes one of the following options
 * <ul>
 * <li><b>'SORTKEY'</b> returns 1 if the numeric value is valid as a numeric string
 * sortkey. See "Proper form required" on page 9-3. A numeric string sortkey
 * value that is not acceptable to $VNUM as a SORTKEY value is sorted in
 * character order even if the SORT statement specifies numeric order.
 * The following compression rules apply to SORTKEY:
 * <ul>
 * <li> Leading plus (+) or minus (-) sign is compressed.
 * <li> Leading blanks before and after the (optional) leading +/- sign are com-pressed.
 * <li> Leading zeros after the (optional) leading +/- sign and blanks are com-pressed.
 * <li> 1-63 integer digits before the (optional) decimal point are allowed.
 * <li> Values greater than -1 and less than 1 require leading "0. nnn".
 * <li> Optional decimal point and fractional value are allowed.
 * <li> Trailing blanks are compressed.
 * <li> 1-253-byte total length is allowed.
 * </ul>
 * <li> <b>'FLOAT'</b> returns 1 if the numeric value is valid as an E-format floating point
 * numeric string.
 * <li> <b>'BINARY'</b> returns 1 if the numeric value is valid as a compressible binary
 * value (to be stored in a BINARY NON-CODED field). See "Storing values
 * in BINARY fields" on page 15-17. Otherwise returns a 0.
 * The following compression rules apply to BINARY:
 * <ul>
 * <li> 1--9 decimal integer values are allowed.
 * <li> No leading zeros are compressed.
 * <li> Leading plus (+) sign is compressed.
 * <li> Leading minus (-) sign is allowed.
 * </ul>
 * </ul>
 *
 * @example
 * <pre>
 * $VNUM(' + 256.73 ') equals 1
 * $VNUM('14') equals 1
 * $VNUM('-17.17') equals 1
 * $VNUM('.1794763') equals 1
 * </pre>
 * 
 * <pre>
 * $VNUM(' -256.73 AB') equals 0
 * $VNUM('256.73-') equals 0
 * $VNUM(' TWELVE') equals 0
 * </pre>
 * 
 * This example averages premium amounts. The amounts are included in the
 * average only if they meet the $VNUM specifications.
 * <pre>
 * BEGIN
 *           %CT IS FLOAT
 * GET.RECS: FIND ALL RECORDS
 *           END FIND
 *           FOR EACH RECORD IN GET.RECS
 *             IF $VNUM(TOTAL PREMIUM) THEN
 *                %TOT = %TOT + TOTAL PREMIUM
 *                %CT = %CT + 1
 *             END IF
 *           END FOR
 *           %AVERAGE = %TOT/%CT
 *           PRINT 'THE AVERAGE PREMIUM IS ' -
 *             WITH '$' WITH %AVERAGE
 * END
 * </pre>
 */
function STRING $VNUM(STRING numeric_string_value, STRING option);


/**
 * @return
 * The $WORD function searches a string from the left for a complete word and
 * returns the nth word in a specified string, delimited by a blank or optionally
 * specified character.
 *
 * @param inputstring is the input from which the specified word is to be extracted.
 * inputstring can be a quoted literal or a %variable.
 * @param delimiter is an optional quoted character or string to be used as a delimiter
 * in parsing the input string into words. If delimiter is not specified, it defaults
 * to a blank space. If delimiter consists of more than one character,
 * Model 204 uses the first character in the string as the delimiter.
 * @param n is the ordinal number of the word to be extracted. $WORD returns a null
 * string under any of the following conditions:
 * <ul>
 * <li> n is not specified
 * <li> n is less than 1 (0 or negative)
 * <li> n is greater than the number of words in inputstring
 * </ul>
 * The commas which separate the three arguments are required, even if one or
 * both of the optional arguments ( delimiter and n) is not specified.
 *
 * @example
 * The following function returns "THE," the third word in the string when a blank
 * delimits a word:
 * <pre>
 *    $WORD ('Now is the time',,3)
 * </pre>
 * The following function returns " TIM," the second word in the string, where a
 * word is composed of the characters that precede a delimiting E:
 * <pre>
 *    $WORD ('Now is the time','E',2)
 * </pre>
 */
function STRING $WORD(STRING inputstring, STRING delimiter=' ', INTEGER n=0);


/**
 * @return
 * The $WORDS function returns the number of words in a specified string,
 * delimited by a blank or optionally specified character.
 * 
 * @param inputstring is the input from which the specified word is to be extracted.
 * inputstring can be a quoted literal or a %variable.
 * @param delimiter is an optional character to be used as a delimiter in parsing the
 * input string into words. If delimiter is not specified, it defaults to a blank
 * space.
 * <p>
 * The comma which separates the two arguments is required, even if delimiter is
 * not specified.
 *
 * @example
 * The following function returns 4, the number of words in the string when a blank
 * delimits a word:
 * <pre>
 *    $WORDS ('Now is the time')
 * </pre>
 */
function STRING $WORDS(STRING inputstring, STRING delimiter=' ');


/**
 * @return
 * The $X2C function changes a 2-byte character of input into 1-byte
 * hexadecimal-equivalent EBCDIC characters. Called with a character string,
 * $X2C returns a character string that is half as long. The maximum input length
 * is 255 bytes. If the input length is more than 255 bytes or if input contains invalid
 * hexadecimal data, a null string is returned. There is no function to translate 2-
 * byte hexadecimal characters to ASCII characters.
 *
 * The output is one half the length of the input. Each pair of hexadecimal
 * characters in the output becomes an EBCDIC character. For example,
 * <pre>
 *    C'01' = X'01' or E8C5E2 = 'YES.'
 * </pre>
 *
 * @param inputchar is the input character string (either a %variable or a quoted
 * literal) to be converted to one-byte hexadecimal-equivalent characters.
 * <p>
 * Input must be an even number of bytes (divisible by 2) and contain only
 * combinations of the following characters:
 * <pre>
 *    0123456789ABCDEF
 * </pre>
 * If the input character string is invalid for any reason and cannot be converted,
 * then the output string returned by the function is set to a null.
 *
 * @example
 * <pre>
 * BEGIN
 * %INPUT_IN_HEX = '05'
 * %PAD_CHAR = $X2C(%INPUT_IN_HEX)
 * END
 * </pre>
 * 
 * <pre>
 * BEGIN
 * PRINT $X2C('C1C2C3')
 * END
 * (output is ABC)
 * </pre>
 * 
 * <pre>
 * BEGIN
 * PRINT $X2C('F1')
 * END
 * (output is 1)
 * </pre>
 */
function STRING $X2C(STRING inputchar);



///////////////////////////////////////////////////////////////////////////////////////////
// Mathematical Functions
//
// The mathematical functions are an optional feature of Model 204 that might not
// be available at every installation. If the option was not installed, attempts
// to use the mathematical functions generate compile-time errors. The notation |x|
// indicates the value of the argument x, rounded to the nearest integer.
//
// Precision:
// The Model 204 internal numeric data representation can maintain 15 significant
// digits of accuracy. However, some of IBM's FORTRAN routines use algorithms
// that are not accurate to 15 places. You should be aware that some of the low-order
// digits returned by these routines might not be meaningful.
//
// Error handling:
// If invalid numerical values are passed to the mathematical functions (for
// example, a negative number to $SQRT), an error message is printed at the
// user's terminal and 0 is returned as the function's value.

/**
 * @return
 * The $ABS function returns the absolute value of x. For example:
 * <PRE>
 * $ABS(-50) = 50
 * $ABS(6) = 6
 * </PRE>
 * 
 * @param x             Number to take the absolute value of
 */
function FLOAT $ABS(FLOAT x);


/**
 * @return
 * The $ARCCOS function returns the value of the arc cosine of x in radians. If the
 * magnitude of x exceeds 1, an error message is printed and a 0 is returned.
 * 
 * @param x             Number to compute the arc cosine of
 */
function FLOAT $ARCCOS(FLOAT x);


/**
 * @return
 * The $ARCSIN function returns the value of the arc sine of x in radians. If the
 * magnitude of x exceeds 1, an error message is printed and a 0 result is
 * returned.
 *
 * @param x             Number to compute the arc sine of
 */
function FLOAT $ARCSIN(FLOAT x);


/**
 * @return
 * The $ARCTAN function returns the value of the arc tangent of x in radians.
 * 
 * @param x             Number to compute the arc tangent of
 */
function FLOAT $ARCTAN(FLOAT x);


/**
 * @return
 * The $ARCTAN2 function returns the value arctan(x/y) in radians. If the second
 * argument is 0 (or omitted), an error message is printed and a 0 is returned.
 * 
 * @param x             numerator of ratio to compute arc tangent of
 * @param y             divisor of ration to compute arc tangent of
 */
function FLOAT $ARCTAN2(FLOAT x,FLOAT y);


/**
 * @return
 * The $COS function returns the value of the cosine of x in radians. If the
 * argument exceeds 10<sup>15</sup> radians, an error message is printed and a 0 is
 * returned.
 * 
 * @param x             number to compute the cosine of
 */
function FLOAT $COS(FLOAT x);


/**
 * @return
 * The $COSH function returns the value cosh(x) in radians. If the argument
 * exceeds the value 175.366, an error message is printed and a 0 is returned.
 * 
 * @param x             number to compute the hyperbolic cosine of
 */
function FLOAT $COSH(FLOAT x);


/**
 * @return
 * The $COTAN function returns the value cotan(x). If the magnitude of the
 * argument exceeds 10<sup>15</sup> radians, an error message is printed and a 0 is
 * returned.
 * 
 * @param x             number to compute the cotangent of
 */
function FLOAT $COTAN(FLOAT x);


/**
 * @return
 * The $ERF function returns the integral (from 0 to infinity)
 * of u<sup>x-1</sup> * e<sup>-u</sup>
 * 
 * @param x             constant to compute ERF of
 */
function FLOAT $ERF(FLOAT x);


/**
 * @return
 * The $ERFC function returns the integral (from 0 to infinity)
 * of u<sup>x-1</sup> * e<sup>-u</sup>
 * 
 * @param x             constant to compute ERFC of
 */
function FLOAT $ERFC(FLOAT x);


/**
 * @return
 * The $EXP function returns the value e<sup>x</sup>.
 * If x exceeds 174.63, an error message
 * is printed and a 0 is returned.
 * 
 * @param x             number to exponentiate
 */
function FLOAT $EXP(FLOAT x);


/**
 * @return
 * The $GAMMA function returns the integral (from 0 to infinity)
 * of u<sup>x-1</sup> * e<sup>-u</sup>
 * <p>
 * If x is not within the range 0 < x < 57.5744, an error message is printed and a
 * 0 is returned.
 * 
 * @param x             number to compute the gamma coefficient of
 */
function FLOAT $GAMMA(FLOAT x);


/**
 * @return
 * In the $IXPI function, both arguments are rounded to the nearest integral
 * values, and the value |x| is raised to the |y| power. If |x| equals 0 and |y| is less
 * than or equal to 0, an error message is printed and a 0 is returned. For example:
 * <pre>
 * $IXPI(8,2) = 8 2 = 64
 * $IXPI(2.4,.5) = $IXPI(2,1) = 2
 * </pre>
 * 
 * @param x             base number to exponentiate
 * @param y             exponent
 */
function INTEGER $IXPI(FLOAT x,FLOAT y);


/**
 * @return
 * The $LGAMMA function returns the natural logarithm of
 * the integral (from 0 to infinity) of u<sup>x-1</sup> * e<sup>-u</sup>.
 * <p>
 * If x is not in the range 0 < x < 4.2913 * 10<sup>73</sup> ,
 * an error message is printed and a 0 is returned.
 * 
 * @param x             number to compute the log of the gamma cofficient of
 */
function FLOAT $LGAMMA (FLOAT x);


/**
 * @return
 * The $LOG function returns the natural logarithm (the logarithm base e) of a
 * number x. If x is not greater than 0, an error message is printed and a 0 is
 * returned.
 * 
 * @param x             number to compute the natural logarithm of
 */
function FLOAT $LOG(FLOAT x);


/**
 * @return
 * The $LOG10 function returns the logarithm base 10 of a number x. If x is not
 * greater than 0, an error message is printed and a 0 is returned.
 * 
 * @param x             number to compute the log (base 10) of
 */
function FLOAT $LOG10(FLOAT x);


/**
 * @return
 * The $MAX function returns the highest value in a list of as many as five
 * arguments. For example:
 * <pre>
 * $MAX(-6, 5, 0, 4, 3) = 5
 * $MAX(-6,4) = 4
 * $MAX(4,-6,70.3) = 70.3
 * $MAX(-6, ,-5) = -5
 * $MAX(-6,0,-5) = 0
 * Omitted arguments to $MAX are ignored.
 * </pre>
 
 * @param X1            number to compare
 * @param X2            number to compare
 * @param X3            (optional) number to compare
 * @param X4            (optional) number to compare
 * @param X5            (optional) number to compare
 */
function FLOAT $MAX(FLOAT X1, FLOAT X2, FLOAT X3=0, FLOAT X4=0, FLOAT X5=0);


/**
 * @return
 * The $MIN function returns the value of the smallest argument in a list of as
 * many as five arguments. For example:
 * <pre>
 * $MIN(-6, 5, 0, 4, 3) = -6
 * $MIN(-4, -7, 2) = -7
 * $MIN(4, ,2) = 2
 * $MIN(4, 0, 2) = 0
 * </pre>
 * Omitted arguments to $MIN are ignored.
 * Arguments to $MAX and $MIN typically are the results of other computations.
 * For example:
 * <pre>
 * A = $MAX($ABS(B),$ABS(C))
 * </pre>
 
 * @param X1            number to compare
 * @param X2            number to compare
 * @param X3            (optional) number to compare
 * @param X4            (optional) number to compare
 * @param X5            (optional) number to compare
 */
function FLOAT $MIN(FLOAT X1, FLOAT X2, FLOAT X3=0, FLOAT X4=0, FLOAT X5=0);


/**
 * @return
 * The $PI function returns the value of p to 15 significant digits
 * 3.14159265358979).
 */
function FLOAT $PI();


/**
 * @return
 * In the $RXPI function, the second argument (y) is rounded to the nearest
 * integer and the value of x raised to the |y| power is returned. Omitted arguments
 * are set to 0. If x = 0 and |y| is less than or equal to 0, an error message is printed
 * and a 0 is returned. For example:
 * <pre>
 * $RXPI(2, 3) = 2 3 = 8
 * $RXPI(.5, 1.4) = $RXPI(.5, 1) = .5
 * $RXPI(.5, 2) = .25
 * </pre>
 * 
 * @param x             base number to exponentiate
 * @param y             exponent
 */
function FLOAT $RXPI(FLOAT x,FLOAT y);


/**
 * @return
 * The $RXPR function returns the value x to the y power. If x < 0, or x = 0 and y
 * is less than or equal to 0, an error message is printed and a 0 is returned. For
 * example:
 * <pre>
 * $RXPR(10, 2) = 10 2 = 100
 * $RXPR(64, .5) = 8
 * $RXPR(256, .25) = 4
 * </pre>
 * 
 * @param x             base number to exponentiate
 * @param y             exponent
 */
function FLOAT $RXPR(FLOAT x,FLOAT y);


/**
 * @return
 * The $SIN function returns the value of the sine of x. If the magnitude of x
 * exceeds the value of 10 15 radians, an error message is printed and a 0 is
 * returned.
 * 
 * @param x             number to compute the sine of
 */
function FLOAT $SIN(FLOAT x);


/**
 * @return
 * The $SINH function returns the value sinh(x). If the magnitude of x exceeds
 * 175.366, an error message is printed and a 0 is returned.
 * 
 * @param x             number to compute the hyperbolic sine of
 */
function FLOAT $SINH(FLOAT x);


/**
 * @return
 * The $SQRT function returns the value of the square root of x. If x is negative,
 * an error message is printed and a 0 is returned. For example:
 * <pre>
 * $SQRT(64) = 8
 * $SQRT(2) = 1.41421356
 * </pre>
 * 
 * @param x             number to compute the square root of
 */
function FLOAT $SQRT(FLOAT x);


/**
 * @return
 * The $TAN function returns the value of the tangent of x. If x exceeds 10 15
 * radians, an error message is printed and a 0 is returned.
 * 
 * @param x             number to compute the hyperbolic tangent of
 */
function FLOAT $TANH(FLOAT x);


/**
 * @return
 * The $TANH function returns the value tanh(x).
 *
 * @param x             number to compute the tangent of
 */
function FLOAT $TAN(FLOAT x);


